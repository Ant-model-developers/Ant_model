
1   Introduction
1.1	Business process management
This book is about Business Process Model and Notation (BPMN 2.0). To understand why BPMN was invented, it is helpful to gain some understanding of business process manage-ment (BPM).
1.1.1	Deﬁnition
Experts use different deﬁnitions for business process management. We use the deﬁnition given by the European Association of BPM (EABPM) in its reference work, BPM Common Body of Knowledge [Eur09]:
Business process management (BPM) is a systemic approach for capturing, de-signing, executing, documenting, measuring, monitoring, and controlling both au-tomated and non-automated processes to meet the objectives and business strate-gies of a company. BPM embraces the conscious, comprehensive, and increasingly technology-enabled deﬁnition, improvement, innovation, and maintenance of end-to-end processes. Through this systemic and conscious management of processes, companies achieve better results faster and more ﬂexibly.
Through BPM, processes can be aligned with the business strategy, and so help to improve company performance as a whole thanks to the optimization of processes within business divisions or even beyond company borders.
What end-to-end process really means is from start to ﬁnish.  The goal is to understand and thus to assess and improve an entire process —not just its components. We ﬁnd the EABPM’s deﬁnition helpful because it treats automated and non-automated processes as both equally important and equally subject to the power of BPM. This understanding is essential to applying BPM successfully because it is rarely sufﬁcient to improve only orga-nizational procedures or the supporting technologies; most often we must improve both the procedures and the technology cooperatively.
2	1  Introduction
1.1.2	BPM in practice
As consultants who specialize in BPM, our new projects almost always involve one of the following three scenarios:
1.  The client wants to improve a process using Information Technology (IT). 2.  The client wants current processes documented.
3.  The client wants to introduce entirely new processes.
A vast majority of the time, we encounter the ﬁrst scenario: the client seeks to improve a process with IT. The motivation often is a desire to improve efﬁciency, for example, to use software to eliminate manual keying or re-keying of data. A client may want to implement IT-based monitoring and analysis of routine processes based on key performance indica-tors (KPIs).
The second scenario, documenting processes, usually comes about because the client needs the documentation to guide the work of the people involved.  Another rationale is that the documentation is mandated by regulation or required to obtain certiﬁcation such as ISO 9000.
The third scenario happens least often. We ﬁnd that when companies want to introduce entirely new processes, it is usually because they are being forced to adapt to changed mar-ket conditions, develop new channels of distribution, or introduce new products.
In public announcements companies may speak in generalities: they have an interest in exploring BPM or they want to increase their process orientation. In practice, especially in large organizations, the argument for BPM is usually well-deﬁned and speciﬁc, but it can take two forms:
1.  There is an acute reason for using BPM. The project concerns essential processes that need to be created, improved, or documented.
2.  The reason for BPM is strategic. There will be no direct or immediate beneﬁt, and the project likely was initiated by some manager trying to advance his or her career.
As you can imagine, serious people don’t greet the second argument with enthusiasm. It is our own experience, however, which makes us advocate for this view strongly:  BPM, process management, or whatever you want to call it, is not an end in itself.
We always recommend introducing BPM in steps. Each step should yield a practical, mea-surable beneﬁt that justiﬁes the time and effort that it took to accomplish. Once the justi-ﬁcation of the ﬁrst step is established, take the next step. You may think that this approach produces solutions isolated from each other, but what we mean to emphasize here is the controlled nature of the approach. Each step contributes to the big picture: the company’s process orientation. A hiker may use a map and a compass to guide his or her steps. Like-wise, when you introduce BPM, you should use a good procedure model and common sense as your guides.
1.1.3	Camunda BPM life cycle
Procedure models always seem to be either too simple or too complex. The overly-simple ones contain only the most painfully obvious elements.  They may be useful for market-ing presentations, but not much else. On the other hand, overly complex models work so
1.1 Business process management	3
Workshops, interviews, monitoring

Current state process model
Weak points?

New process Diagnose problems,
search for causes,
estimate potential
Existing process

Process survey	documentation
Process
Modeling, process maps, flow diagrams

Yes
No
Process controlling

Process
analysis	Modeling targetstate design,
process simulation, assessment of alternatives, ROI estimate
Current state process
model
Process
Design
Process
conception
Continuous until process improvement is required
Process implementation
Change management, conventional IT projects, process automation

Target state process model
BPM governance
FIGURE 1.1  The Camunda BPM life cycle.
hard at anticipating every contingency that they trap the user like a ﬂy in amber. They are unrealistically rigid. Still, without a model, we wouldn’t have our map to orient ourselves.
After examining the simple BPM life cycle, which is the most well-established BPM pro-cedure model, we reﬁned it according to our experience. We wanted to create a relatively lightweight model without too many restrictions.  We thought this would be more prac-tical than the brightly colored marketing materials we see so often at conferences and in meetings. We call ours the Camunda BPM life cycle. See it in ﬁgure 1.1.
We intend the Camunda BPM life cycle to describe one process at a time. Any process can run through the life cycle independently of any other process, and the process can be at a different stage each time it repeats. The cycle triggers when one of the following situations arises:
■      An existing process is to be documented or improved. ■      A new process is to be introduced.
We have to start by examining an existing process. The process discovery clearly differen-tiates the subject process from other processes both upstream and downstream. The dis-coveryrevealstheoutputgeneratedbythesubjectprocessaswellastheimportanceofthat output for the client. We use e.g. workshops or one-on-one interviews to identify not only what needs to be accomplished, but also who needs to be involved, and which IT systems.
We document the ﬁndings from the process discovery in a current state process model. This process documentation may include many different charts and descriptions; it usu-ally has multiple ﬂow charts. A systematic examination of the current state process clearly identiﬁes weak points and their causes.
We conduct process analysis either because ﬁrst-time documentation or continuous pro-cess control has revealed a weakness of a process that cannot be remedied easily.
The causes of weak points identiﬁed by a process analysis become the starting point for anotherprocessdesign. Ifnecessary,differentprocessdesignscanbeevaluatedbymeansof
4	1  Introduction
theprocesssimulation. Wealsoconductaprocessdesignwhenintroducinganewprocess. The result in either case is a target state process model.
In reality, we normally want to implement the target state process model as a change in business or organizational procedures as well as an IT project. Change management, es-pecially process communication, plays a decisive role in successful organizational change. For the IT implementation, the process can be automated or software can be developed, adapted, or procured. The result of the process implementation is a current state process corresponding to the target state process model that, conveniently, has already been doc-umented.
In most cases, we ﬁnd all the stages from process discovery to process implementation to be necessary. Because process monitoring takes place continuously, however, it reveals more about the ongoing operation of the process.
The most important tasks of process control are the continuous monitoring of individual process instances and the analysis of key data so that weak points can be recognized as quickly as possible.  Problems with individual entities require direct remedies, and so do structural problems if that’s possible. If necessary, the current state process model has to be adjusted.
If the structural causes of the problems are unclear or complex, this calls for an improve-ment project that —once again —starts with a systematic process analysis of the weak points. The decision to initiate such a project lies with the process owner and anyone else who depends on the process. It is common to regard continuous process control as some-thing that follows process implementation, though it may be better to have it follow the initial documentation. This is especially true when doubt exists about the necessity of the improvement.
Given the importance of the process model within the BPM life cycle, you can imagine the importance of a modeling standard such as BPMN. Yet you may also notice that process modeling is not a stage in the Camunda BPM life cycle. That’s because process modeling is a method that affects all stages, especially process documentation and process design. As consultants, we constantly encounter people who try to insert process modeling as a stage at the same level as current state documentation. We think that’s a misconception.
The BPM life cycle describes a simple way to achieve continuous improvement. Applying it requires coordination of the triad: The responsible parties, the applied methods, and the supporting software tools. Getting the triad moving toward a common goal is the task of BPM governance, which has authority over all processes and all BPM projects in an organi-zation.
The EABPM’s deﬁnition of BPM used the term process automation, and we’ve also used that term in describing the Camunda BPM life cycle.  BPMN was developed to automate processes better.  Even if you are not an IT expert, you need to understand what process automation means because it will help you to grasp how BPMN builds bridges between business and technology.
1.1 Business process management	5
1.1.4	Process automation
Here’s a simple process: A potential bank customer mails a paper credit application, which ends up on the desk of a bank accountant. The accountant examines the application, then checks the potential customer’s creditworthiness through the web site of a credit rating agency. The results are positive, so the accountant records the application in a special soft-ware —let’s call it BankSoft —and then forwards the documents to a manager for approval.
Here’s the same process automated: A potential bank customer mails a paper credit appli-cation. At the bank, a clerk scans the application into electronic form. Software known as a workﬂow engine takes over the document and routes it to the bank accountant’s virtual task list. The accountant accesses the task list, perhaps through the bank’s web site or an email program like Microsoft Outlook, examines the application on screen, then clicks a button. The workﬂow engine accesses the credit rating agency, transfers the pertinent de-tails, andreceivesthereport. Sincethereportispositive, theenginepassestheinformation to BankSoft, and it creates an approval task in the manager’s task list.
Whether this example represents optimal processing is not the point. It’s here only to illus-trate the following principles of process automation:
■      Processautomationdoesnot necessarilymeanthattheentireprocessisfullyautomated.
■      The central component of process automation is the workﬂow engine, which executes an executable process model.
■      The workﬂow engine controls the process by informing humans of tasks that they need to do, and it handles the result of what the people do.  (This is human workﬂow man-agement.) It also communicates with internal and external IT systems. (This is service orchestration.)
■      The workﬂow engine decides which tasks or service calls take place or not, under what conditions, and according to the result of the task execution or service call.  Thus the people involved still can inﬂuence the operational sequence of an automated process.
Figure 1.2 on the following page illustrates these principles.
If you think that process automation is just a kind of software development, you are right. Theworkﬂowengineisthecompilerorinterpreter,andtheexecutableprocessmodelisthe program code. A workﬂow engine is the mechanism of choice where process automation is concerned.
■      The workﬂow engine specializes in representing process logic. The services it provides would have required extensive programming in the past; using a workﬂow engine now can make you considerably more productive than before.  (Or perhaps productivity is not an issue for you, and so you develop your own spreadsheet, word-processing, and drawing programs!)
■      A workﬂow engine combines workﬂow management with application integration. This makes it a powerful tool for implementing all kinds of processes from start to end, re-gardless of other applications or the geography of people in the process. In some BPM software solutions, we can add a separate Enterprise Service Bus (ESB) or other compo-nents to the workﬂow engine to make the whole more versatile.
■      As the workﬂow engine controls the process, it tracks everything.  It always knows the current stage of the process and how long each task took to complete. Because the work-
6	1  Introduction
Executable process model

Modeling
Monitoring and reporting
Workflow engine

Human workflow management
Measure running time
Task assignment

Automated service call

Automatic decision

Automated service call

Task assignment
Service orchestration
Process participant	IT system	IT system	Process participant
FIGURE 1.2  Process automation with a workﬂow engine.
ﬂowenginemonitorskey performanceindicatorsdirectly, itprovidesameansto analyze performance as well. This offers huge potential for successful process control.
The three features above would themselves justify using a workﬂow engine, but there is a fourth justiﬁcation:  The workﬂow engine works on the basis of an executable process model. In the best cases, this model can be developed —or at least understood —by some-one who is not a technician. This promotes genuinely good communication between busi-ness and IT, and it can even result in process documentation that corresponds to reality.
1.2	The BPM standards
Our focus in this book is on BPMN as a standard for modeling and automating processes. But there is at least one standard that relates closely to BPMN, and complement BPMN well. This is Decision Model and Notation (DMN) for managing decisions.
In this section, we provide an overview of the standards, and then we describe how they can be used in combination.
1.2.1	Workﬂows with BPMN
Initially, BPMN stood for Business Process Modeling Notation.  The ﬁrst version was de-veloped predominantly by Stephen A. White from IBM before it was published in 2004 by Business Process Management Initiative (BPMI). From the outset, the aim was to provide a standardized graphical process notation that also could be used for process automation.
1.2 The BPM standards	7
In 2005, Object Management Group (OMG) took over BPMI along with the further devel-opment of BPMN. OMG is an important institution in the world of IT. It is known especially for its Uniﬁed Modeling Language (UML), a modeling standard for software design.  The merger of BPMI with OMG was also the beginning of a global triumph for BPMN, as it pro-vided incentive for many companies to switch.
In February 2011, OMG released the current version, BPMN version 2.0. We were able to play a part in that. Version 2.0 came with a new deﬁnition of BPMN: Business Process Model and Notation, because not only did version 2.0 deﬁne the notation but also the so-called formal metamodel. Then in September 2013, BPMN was published as an ISO standard by the International Organization for Standardization (ISO) under ISO/IEC 19510:2013. Since then, the notation has been deliberately kept stable, because a proliferation of versions woulddestroymanyoftheadvantages,becausethen,forexample,eachtoolwouldsupport a different version, or books would have to take account of many version differences.
By now you may be wondering what this mysterious BPMN is in a material sense. BPMN is a speciﬁcation. It exists in the form of a PDF document that you can download free from the OMG [Obj09] website. Whereas the speciﬁcation document for BPMN version 1.2 was about 320 pages, version 2.0 has expanded to 500 pages.  The documents deﬁne all the BPMN symbols, their meanings, and the rules on combining them.
With version 1.2, BPMN had not yet deﬁned all the technical attributes necessary for direct execution of BPMN models in workﬂow engines. This led to several unfortunate attempts to convert ("map") BPMN models to BPEL models (see section 6.2.3 on page 172). BPMN version 2.0, however, made direct execution possible. That’s an important factor in terms of the use of BPMN models. Another important factor is standardization, which offers the following advantages:
■      You become more independent from certain BPM tools when you do not have to learn a new notation every time you change tools. Today more than 100 BPMN tools exist; many of them are free.
■      There’s a good chance that your partners in other companies (customers, suppliers, con-sultants, and so on) are familiar with BPMN and can therefore understand your process models quickly.
■      When hiring new staff, it’s likelier that more of them already can read or generate your BPMN process models.
■      When universities and private companies invest time and money to develop additional solutions based on BPMN, this is to your beneﬁt as well. Our BPMN framework, which we present later, is an example of this commitment —we never would have developed it if BPMN were not a standard.
1.2.2	DMN for rule-based decisions
DMN is short for Decision Model and Notation.  Like BPMN, it is administered by OMG. DMN is the newest of the three standards.  Version 1.0 was released in September 2015. Version 1.2 is the current version when releasing this edition of the book.
A decision in the DMN sense means deriving a result (output) from given facts (input) on the basis of deﬁned logic (decision logic).
8	1  Introduction
Unlike BPMN, DMN is not about activities or processes. DMN works in an operationally similar fashion: decisions can be modeled by a business user and then executed by a deci-sion engine. Another similarity to BPMN is that the DMN standard speciﬁcation contains both a written description of the notation and an XML-based formal metamodel.
The DMN standard offers different ways to model decisions. The most popular way is the decision table described in section 5.2.1 on page 151. Within decision tables you must de-ﬁne the speciﬁc conditions needed to determine a result. The deﬁnition has to be under-standable and implementable on a technical level —BPMN users will recognize how this corresponds to BPMN —and it is why we use a formal language called Friendly Enough Expression Language (FEEL). FEEL is part of the DMN standard, and we introduce it in section 5.2.4 on page 159.
Often, complex decisions are made up of comparatively simple decisions.  The Decision Requirements Diagrams (DRDs) described in section 5.2.5 on page 162 help us to dissect complex decisions into their components and make them clearer.
Similar to BPMN, the value of DMN peaks when modeled decisions are executed by a com-patible decision engine. This offers the following advantages:
■      Transparency:  Everyone can easily understand how decisions are being made.  This knowledge is no longer buried either in the heads of certain employees nor in barely intelligible application source code.
■      Traceability: Every decision can be logged automatically by the decision engine.  It is possible to trace why certain decisions were made.
■      Flexibility: The decision logic can be adapted more readily. It does not have to be rolled out accompanied by lengthy training or documentation; it can just be deployed. In this regard, DMN is slightly superior to BPMN because changing BPMN diagrams intended for execution by a process engine can be too risky for a non-programmer. (This may be hard to appreciate —after all, how hard can it be to add, move, or delete a few symbols? True, but the technical process is only one part of an entire application architecture that can be affected by the unintended consequences of small changes.) Something similar can happen with a DMN decision table, but the consequences are more easily recogniz-ableand, unlikeinBPMN,therearenotechnicalattributesbehindthesymbolsthathave to be maintained. It is thus more easily possible for the business department to design or adapt software solutions independently of IT.
Activities and decisions are closely entwined in business processes. BPMN version 2.0 de-ﬁned a business rule task more than four years before the ﬁrst version of DMN. Even then it was assumed that when completing processes, rules would be assessed constantly as part of making decisions. The term decision management was not common at that time, how-ever; we spoke instead of business rule management, which explains the description of that task type in BPMN.
1.2.3	Structured vs. unstructured workﬂows
BPMN focuses on business processes, but there is an important limitation: There are some processes that are poorly suited to modeling or automation in BPMN. These are the un-structured processes —processes that do not always take place in a predictable and repeat-
1.2 The BPM standards	9
able way. An example of an unstructured process is that of a doctor coming upon the scene of an accident with injuries. She is unlikely to work through a BPMN diagram but instead willquicklyplungein,makingdecisionsbasedonherknowledgeandexperience,ofcourse, but also in reaction to the chaos of the scene. We could draw other examples from practi-cally every sector or industry, though many are less obvious.
This is why the CMMN standard was invented alongside BPMN. CMMN is short for Case Management Model and Notation. OMG published CMMN version 1.0 in March 2014 and the current version when writing this edition is 1.1. We introduced that notation in some detail in the 3rd edition of this book, used it a lot when working with customers and also added support for it in our software platform. We gave CMMN two years to take off, but, within that time, we experienced limited value from CMMN in our projects, especially if you compare it to BPMN or DMN. One observation was, for example, that most logic in CMMN models was hidden in complex rule-sets if certain activities are possible, impossi-ble, mandatory or unnecessary. These rules were often expressed elsewhere and also not represented graphically. Exaggerating a bit, the CMMN model becomes kind of a graphical bullet point list. So we decided to remove CMMN from this book to not confuse anybody that just embarks on their BPM journey.  Instead we want to emphasis how to tackle un-structured processes with BPMN in section 4.5.5 on page 142 and point out the limits of this approach.
Close your eyes (metaphorically speaking) and imagine that you are hosting a workshop to design a business process. You have a room full of people who have a stake in the pro-cess, and your mutual goal is to come up with a BPMN process model.  You start with a manageable circle of participants, and you ask them what the ﬁrst task should be.
The answer to your question depends, they tell you, and they proceed to pepper you with anentirelistofconditions. Itseemsthatyouwillhavetomodeltheevaluationofconditions ﬁrst, and you’ll use a gateway with many possible paths leading out of it.
During the course of the meeting, participants also point out the frequent need to jump back within the process and to repeat a previous task. While it is easy enough to represent such jumps in BPMN, if they have to be represented for more than half of the tasks, your model quickly starts to resemble a bowl of spaghetti. There are two ways out of this mess:
1.  You explain that they will have to start working in a more structured manner, with fewer exceptions, deviations, backtracks and the like. This will limit their ﬂexibility when act-ing within the process, which may frustrate employees and customers alike.  On the other hand, the process will become predictable, repeatable, and less dependent on the implicit knowledge of the humans controlling the process.
2.  You accept that every case may be different, and that this process cannot be structured homogeneously. You need to ensure that the people working on cases have enough lat-itude to make use of all their knowledge and experience.  BPMN might be at its limit here and you need to ﬁnd another way of approaching a solution. CMMN might be an option, but proprietary products might be as well. Very often these problems boil down to individual software, groupware, Trello- or IFTTT-alike tools or case management so-lutions.
BPMN assumes a clear order, a basic sequence in which the tasks are expected to be car-ried out. But of course there are possibilities to deﬁne branches, backﬂows, and reactions to events. In our projects, these possibilities are often sufﬁcient to properly model partly
10	1  Introduction
unstructured models. We will further examine this in section 4.5.5 on page 142. In the real world, an entire process seldom ﬁts a completely structured or unstructured pattern. More commonly, there are some structured parts within a process —and these can be captured in BPMN —as well as some unstructured parts for which you will need other possibilities.
So let’s get going and look at our ﬁrst example, including some ﬂexibility for human inter-vention.
1.3	First example
Ourscenario comes fromtheinsuranceindustry. Itissimpliﬁed, butitrepresentsthekinds of real-life situations we have encountered repeatedly. Note that the models used here are more than theoretical constructs or documentation; they are executable by engines, one of which is our own product, Camunda BPM. Camunda BPM allows you both to model and execute models in BPMN as well as DMN.
IfyouhavenoexperiencewithBPMN,orDMN,thefollowingmayseemlikeaforcedmarch through notational language you don’t yet know. To help, we have added cross references to the sections of the book in which we detail the notational elements.
Let’s get started.
Supposeyouwanttotakeoutcarinsurance. NowadaysyourﬁrststopistheInternet,where you compare offers and decide on a provider. You visit the website of your chosen insur-ance company —in this case, the ﬁctitious Camundanzia Insurance. You complete an ap-plication form (see ﬁgure 1.3) with the following data:
FIGURE 1.3  The Camundanzia website.
1.3 First example	11
■      Your date of birth is January 1, 1980. At the time we wrote this, you were 39.
■      The manufacturer of your vehicle is BMW.
■      The vehicle model is an X3.
You click to submit the form and lean back, eagerly awaiting your insurance policy.
The data from the form immediately creates an instance of a business process at Camun-danzia, which has been modeled in BPMN and is technically implemented in Camunda BPM (see ﬁgure 1.4). We can tell this from looking at the start event application received. The BPMN-compatible workﬂow engine ﬁrst mentioned in section 1.1.4 on page 5 now goes to work.

FIGURE 1.4  Request processing in BPMN.
The process starts with the determine risks business rule task. On the model side, this task is linked to the DMN decision table risk assessment (see ﬁgure 1.5) that is now carried out by the decision engine. The decision engine evaluates the input values for applicant age, vehicle manufacturer, and car model. The workﬂow model transferred these values to the decision engine when the business rule task was carried out.
Risk assessment
C	Age	Vehicle manufacturer	Vehicle type	Risk	Risk rating
1     <= 21	-
2     <= 25	"Porsche" 3     <= 30	"BMW"
4     -	"Porsche" 5     -	"BMW"

-	"Beginner"
"911"	"Too young and fast" -	"Young and fast" "911"	"Pointless speeding" "X3"	"High value vehicle"

"yellow" "red" "yellow" "yellow" "yellow"
FIGURE 1.5  Risk assessment in DMN.
Because you said you drive a BMW X3, rule number 5 applies regardless of your age. This rule states that any driver of a high-value vehicle gets a yellow risk rating.
The decision engine feeds two output values —one for the vehicle and one for the risk rat-ing—backtotheworkﬂowengine,whichcontinuestoexecutetheprocess. Inthefollowing step we encounter an XOR gateway (see section 2.3.1 on page 28), which decides how the process should continue based on the risk assessment.
12	1  Introduction
If no risks had been recognized, the gateway would have selected the path labeled none. This would have led to the issue policy service task (see section 2.7 on page 61). The work-ﬂow engine would have called Camundanzia’s backend system through an interface, and the backend system would have generated a document. In turn, the document would have been fed back to the workﬂow engine. The next step would have been the send policy task, which would have forwarded the document to you.
Your risk, however, fell into the yellow category because you drive a BMW X3.  The XOR gateway activates the Decide on application user task (see section 2.7 on page 61) and waits for some clerk to decide manually, because he got some task in his inbox.  The workﬂow engine is patient, but because of the attached time event (see section 2.6.3 on page 49), after two days of waiting it will launch an escalation. It will initiate another user task called accelerate application assessment.  The user task could be assigned, for instance, to the team leader of the worker who was responsible for this application assessment.
Let’s assume that the ofﬁce clerk with the expert knowledge processes the application im-mediately. He asks himself: "Should this applicant be insured despite the high value of this vehicle?" Maybe he needs to be ﬂexible in handling the application, so in our example he can request further documents.  This leads to a call activity (see section 2.8.2 on page 69) which is linked to a separate BPMN process model.
Requesting additional documents (or other activities you model accordingly) above can be carried out or skipped, that decision is up to the ofﬁce clerk. In ﬁgure 1.6, we see what the clerk’s task form looks like.
FIGURE 1.6  Oﬃce clerk’s task form when deciding on the application.
1.4 Can BPMN bridge the gap?	13
Iftheendresultistoaccepttheapplication, theBPMNprocesscontinues, thatis, thework-ﬂow engine reaches the XOR gateway decision and selects the path application accepted. Now the possibility described above becomes reality —the service task retrieves the insur-ance policy from the back-end system, and the send task sends it to the applicant by email.
Perhaps only half an hour has elapsed since you sent your application for car insurance. You spent it idly snoozing at your desk, didn’t you? But your reverie ends when a new email arrives. You are thrilled at the speed with which Camundanzia was able to issue your in-surance policy.
This concludes our example. We hope it was enlightening.
As you can see, each of the BPM standards has a role to play, but they also overlap. A ques-tion we get asked is why we need decision tables if business rules can also be represented in BPMN by gateways? We answer this question in section 4.5.6 on page 144.
1.4	Can BPMN bridge the gap?
1.4.1	The dilemma
First, BPMN provides a set of symbols.  Second, it implies a methodology that expresses itself as rules for combining the symbols graphically. Third, the symbol deﬁnitions and the rulesforapplyingthemiscalledsyntax. Fourth,themeaningofthesymbolsandconstructs that you can model with the symbols is called semantics.
Unfortunately, just knowing the BPMN symbols is not enough for you to create useful pro-cess models. Since 2007, we have used BPMN extensively and often, and you can believe that we have suffered terribly!  Mainly, we suffered because we always aimed for models withcorrectsyntaxandconsistentsemantics—inotherwords,unambiguousmodels. Oth-ers took the easy way out by saying: "Our process model is not really syntactically correct, and it’s not really unambiguous. But that doesn’t matter because the main thing is that the consumer understands it!" This attitude backﬁres because:
■      When you apply BPMN in a syntactically incorrect way, you lose all beneﬁts of standard-ization. After all, what do you need a standard for if the models all look different in the end? Many BPMN tools won’t even enable syntactically incorrect modeling.
■      Semantic inaccuracies or inconsistencies always create the risk that your model will be misinterpreted.  This risk is particularly high if you create an inconsistent target state process model and then send it to IT to implement.
If you want to supply your process model directly to the workﬂow engine, you must make your model correct, precise, and consistent. At that point, you still have to reconcile two contradictory objectives:
1.  Differentconsumersmustunderstandandaccepttheprocessmodel. Makingthemodel easy to comprehend helps to reach agreement.
2.  Because the process model has to meet the requirements of formal modeling, there’s usually an unavoidable level of complexity to it.  This makes it harder to achieve the comprehension that leads to agreement.
14	1  Introduction
Failure to reconcile the objectives, to bridge the gap in understanding between business and technology, is the main reason that process models have had limited success in the past. The really bad news is that BPMN alone also will not succeed!
Just as with spoken language, you can use BPMN and either succeed or fail. As with spoken language, successful use of BPMN depends on whom you want to communicate with and about what. You speak to your colleagues about the work you all know so well differently than you speak to your three-year-old about why the cat doesn’t like to be pulled by its tail.  Similarly, you will need other BPMN process models for coordinating with your co-workers than for presenting the future process to upper management. Decide for yourself if the latter scenario is akin to the toddler-and-cat situation.
On the one hand, different BPMN process models are required for speciﬁc audiences and topics so that they can be understood. On the other hand, each model must contain all the detail necessary for the topic. BPMN may be a common language for business and IT, but the phrasing will remain different nevertheless.
The following understanding is therefore imperative for your work with BPMN:
The precision and formal correctness of the process model must vary depending on the modeling objective and the expected consumers.
1.4.2	The customers of a process model
Whenever we model processes, we have to work in a customer-focused way. We must al-ways keep the consumer of our model in mind. We must put ourselves in his or her place. This sounds simple, but few process models actually support this orientation.
As we have been saying, the knowledge, skills, and interests of the people who view our process models vary a great deal.  In the following list, we have compiled the types we encounter in our BPM projects. These descriptions are for the roles played in relation to the project; they are not the titles of people in any organization. What we ﬁnd is that the moreexperienceanenterprisedevelopswithBPM,themoreconsistentlyweseetheseroles fulﬁlled. We recommend that you become familiar with:
■      Process owner: Process owners have strategic responsibilities for their processes. They are vitally interested in optimizing performance. They often have budget authority, but before they sign off, they need to be convinced that your improvement plan will work. In most companies, process owners inhabit the ﬁrst or second tier of management. They may be members of management committees or heads of major divisions.
■      Process manager: Process managers have operational responsibility for their processes. They report directly or indirectly to the process owners.  They apply for improvement projects, acting as the ordering party for external services. Process managers are often low- or middle-level managers.
■      Process participant: Process participants work with the processes and actually create value. Their relationship to the process manager varies greatly. In companies organized by functional divisions —sales, logistics, and so on —a process manager is a functional executive for the division in which the process is carried out. Process participants report directly to that functional executive.  If the process is carried out across departments, which is common, especially in process matrix organizations (see ﬁgure 1.7) conﬂicts
1.4 Can BPMN bridge the gap?	15
A
can arise between department executives. Process modeling alone cannot resolve such issues, which is why we do not examine them further in this book.
■      Process analyst:  The core competencies of process analysts are BPM in general and BPMN in particular.   They support process managers as internal or external service providers through all stages of the BPM life cycle. A process analyst may be the contact for external service providers or may act as the process manager’s representative. Within the company, process analysts usually have either their own sphere of competence in BPM, such as the business organization, or they are part of their IT divisions. It is rare, however, for a process analyst to be responsible for technical implementation.
The analyst may like technical work, may know BPMN from back to front, but his or her strengthsareasanorganizerandcommunicator. Asthebuilderofbridgesbetweenbusi-ness and IT, the process analyst is the center of every BPM project. About 70 percent of the people who claim or are assigned to this role, in our experience, are poorly qualiﬁed because they lack the proper analytic predisposition. The most important qualiﬁcation of a process analyst is not a facility for sending out information, but a facility for receiv-ing it. Good process analysts naturally want to understand everything thoroughly. At the sametime,theyhaveplentyofempathyinrelatingtotheotherpeopleinvolved,andthey can tailor their communication for every group. They remember every detail, but they also sensibly shield details from those for whom the details would just be a distraction.
Do project managers make good process analysts? No, nor should the project manager be the same person as the process analyst.  Most project managers see themselves as "dynamic, action-oriented individuals" who constantly have to "get someone on board" or "pull chestnuts out of the ﬁre." They may be extremely skilled at delegating respon-sibility although, to be honest, some are clueless windbags. It may seem ideal to have a good process analyst also manage a BPM project, but it rarely works.
■      Process engineer: Process engineers use technology to implement the target state pro-cess modeled by process analysts. In the best cases, they do so in the workﬂow engine, which automates the process.  You can call a programmer who programs the process logic in Java, C#, or another language a process engineer. The programmer’s major work takes place during the implementation stage of the BPM life cycle, though the process analyst may get the process engineer involved at other stages as well.
FUNCTIONAL DIVISIONS
A
Functional Manager A

B
Functional Manager B

C
Functional Manager C

D
Functional Manager D
Process Manager A
Process Manager B
B
PROCESSES
Process Manager C
C

Process Participant AA
Process Participant BA
Process Participant CA

Process Participant AB
Process Participant BB
Process Participant CB

Process Participant AC
Process Participant BC
Process Participant CC

Process Participant AD
Process Participant BD
Process Participant CD
FIGURE 1.7  The process matrix organization.
16	1  Introduction
Now that we’ve outlined the potential customers of a process model, we can talk about what the models should look like to keep these customers happy.
1.5	A method framework for BPMN
In our consulting projects and workshops, we have introduced a great many people from all kinds of enterprises to BPMN. From that collected experience, we have developed a practical framework for applying BPMN.
This framework helps us decide which BPMN symbols and constructs to use in which sit-uations —and also when to hold back in the interest of simplicity. The framework focuses on projects with processes that need improved technological support and in which it is the target state that needs to be modeled. In principle, what we show as modeling patterns can also be applied to other scenarios such as the discovery, documentation, and analysis of current-state processes.
For this edition of the book, we revamped the way we visualize the framework.  The fol-lowing section introduces the new visualization, and then we explain why we changed it. Basically, we now ﬁnd fault with a widespread approach to process-focused IT projects, and we want to present an alternative that our experience suggests is better.
1.5.1	The Camunda house
Strategic process model

Content:  Process overview Goal:  Fast comprehension
Semantics:  Logically abstract
Operational process model
Human process flow

Technical process flow

Content:  Operational processes Goal:  Coordinate details between
human process flow and technical process flow (automation)
Semantics:  Physically specific
FIGURE 1.8  Camunda BPMN framework.
The Camunda BPMN framework in ﬁgure 1.8, or Camunda house for short, distinguishes between strategic and operational process models:
■      Strategic process model: The primary target group for strategic process models are pro-cess owners and process managers. A secondary group early in the project may include process participants and process analysts. We provide the strategic model as a general,
1.5 A method framework for BPMN	17
results-oriented representation of the process because we want to create the quickest possibleunderstandingforanaudiencethathasnospecialBPMNknowledge. Wesketch the process in a few steps, but we don’t show errors or variations. See chapter 3 for more detailed information on creating strategic process models.
■      Operationalprocessmodel: At this level, we investigate operational details of the actual process. It may contain human or technical process ﬂows, and we model them accord-ingly.  A human ﬂow is handled by a participant while a technical ﬂow is handled by software —preferably a workﬂow engine. Of course, the human and technical ﬂows can interact. A human may trigger a technical ﬂow in the course of doing his or her work, as in the case of calling a software function. Equally, a technical ﬂow may require a partici-pant to send an email, assign a task, and so on. The human ﬂow thus is triggered by the technical ﬂow.  We handle developing human and technical process ﬂows in chapter 4 and chapter 6.
The Camunda house is a purely methodological framework. In other words, it works inde-pendently of particular software tools, although certain tool functions may make it easier to apply. We deal with this in section 7.4.2 on page 204.
About half of this book is a detailed description of this framework.  Because those chap-ters offer so much practical information, we encourage you to read them even if you are unconvinced of our framework’s utility. If that’s the case, just think of our framework as a classiﬁcation system for our advice on applying BPMN practically.
Eitherway, welookforwardtoyourcommentsandfeedback, notjustonthisbook, butalso on the framework itself. By nature it’s not a perfect approach, and it is subject to constant change and development. With your help, perhaps we can make it better for everyone!
Tooling
We developed the Camunda house speciﬁcally to represent projects involving a lone pro-cess or a manageable group of related processes. For now, we won’t deal with modeling entire process landscapes. BPMN’s portfolio does not encompass process landscapes. We have modeled process landscapes at a customer’s request (we primarily used col-lapsed pools and message ﬂows as described in section 2.9 on page 78), but we cannot recommend it.  If you want a process landscape, you should use a more appropriate tool —perhaps a proprietary one that uses block arrows and rectangles and lots of col-ors. Of course, you can reﬁne a process landscape with BPMN diagrams by linking the individual elements with ﬂow charts.
1.5.2	The great misunderstanding
This is a confession. We declare ourselves guilty of spreading a deceptive image. The Ca-munda BPMN framework shown in ﬁgure 1.9 on the following page was used in a previous edition of this book.  Released in German in 2009 and in English in 2012, it was a huge success. Hundreds of BPMN projects used the pyramid depiction of the framework for ori-entation. Alarge,internationalsoftwarevendorevenincludedthepyramidinitsmarketing material. Unfortunately, it resulted in some misunderstandings.
18	1  Introduction
Level 1 Strategic process model
Level 2 Operational process model

Strategic process model
Operational process model
Level 3a Executable process model
with workflow engine

Level 3b
IT specification
Level 4b Implementation

Human process flow

Technical process flow
without workflow engine
FIGURE 1.9  From old to new: The Camunda BPMN framework.
In the pyramid, we distinguished between strategic, operational, and technical levels.  It seems similar at ﬁrst to the Camunda house, but the Camunda house deﬁnes the technical level as a component called technical process ﬂows within the operational process model, and not as a level of its own. The pyramid put the operational level in a position equivalent to what we now call human process ﬂows.
This change was necessary because people too often assumed that the technical level was a reﬁnement of the operational level, in other words, that the technical level merely added more detail. In reality, operational-level models (in the sense of the earlier framework) are often more detailed than their corresponding technical-level models. For example, think of a simple technical process ﬂow —that triggers a complex manual task —which then re-quires a complex manual process.
Two related misunderstandings came up.
The ﬁrst was a perception that the modeling on three levels had to take place in a ﬁxed sequence, that the target-state process must be created ﬁrst on the strategic level, and then on the operational level, and ﬁnally on the technical level. There’s no need for that. It often makes more sense to create the operational or technical model ﬁrst.  Doing it this way allows you to develop a clearer understanding of the way process participants will have to do their work before you attempt to summarize or abstract it into a strategic process model.  It is, in fact, common practice to conceive the technical and human ﬂows of a process model concurrently, for example, in a workshop.
The second misunderstanding related to a strict separation of responsibilities.  It was as-sumed that only the business side would deﬁne the strategic and operational levels while only the IT Department would deﬁne the technical level. We found this assumption most frequently in enterprises with difﬁcult political situations, where cooperation between IT, operations, and business departments was less than ideal.
We should all understand that even a technical ﬂow represents a business model. After all, it describes business requirements. It differs from a classic request document only in that the technical ﬂow anticipates the executable source code —a major advantage of BPMN. The risk in such a strict segregation of responsibilities is that the technical model, while
1.6 Domains, boundaries and the risk of BPMN monoliths	19
compliant with requirements, may become incomprehensible and unsatisfactory to the business.
It is a similarly serious matter not to involve IT sufﬁciently in the design of human pro-cesses.  To believe that you can deﬁne a process purely from an operational perspective and only then align the technical implementation with it is ...naive. Experience shows us repeatedly that operational decisions can and should be inﬂuenced by technological re-alities, either because what the business wants is technologically impossible (or perhaps infeasible for cost reasons), or because the technology can offer solutions that are not on the radar for the people deﬁning operational requirements.
To summarize, you could say that the operational process model belongs both to the busi-ness and to IT. As a shared artifact, both parties should share in its development.
What does this thinking mean in terms of our approach to projects? Basically, it aligns with that of agile project organizations: The strict separation of concept from realization is as outmoded as the classic waterfall pattern of development. Most IT projects go better with iterative development, either in sprints within Scrum or otherwise, and it doesn’t matter if the project is about process improvement or automation.  The business and IT shouldn’t work in isolation.
To be abundantly clear: Project participants may need to be shaken out of their comfort zones and motivated sufﬁciently to work honestly with "the other side." In our engage-ments during the last few years, the result of our strong encouragement for cooperation always has been the same: massive amazement at how productive a project can be. When IT and the business work side-by-side to deﬁne the target-state process at the strategic and operational levels, including technical ﬂows, the technical ﬂows can become executable within days or even hours.
As Thorsten Schramm of LVM Versicherung (a large insurance ﬁrm) put it during one of our workshops:
"It took only a few days to highly inspire the whole project team (consisting of people from both IT and business departments) for process modelling with BPMN, and right now the ﬁrst improved processes are already emerging."
Thorsten distills our message nicely.  Sometimes, the cooperation experienced within a workshop is just as meaningful as learning the BPMN methodology. BPMN thus can oper-ate synergistically to produce positive change within the enterprise.
1.6	 Domains, boundaries and the risk of BPMN monoliths
The microservice architectural style is currently on the rise.  For example, in a 2018 sur-vey ([Cam18]) 63% of participating companies had already adopted microservices archi-tectures. The idea is that software is no longer built as large monolithic applications, but rather as a bunch of smaller microservices that focus on exactly one business capability each. Every services is owned by one team that cares about design, development, deploy-ment, operations and maintenance. A microservice has a clear responsibility and API, and
20	1  Introduction
only these are known to the rest of the company Without implementation details. This is contrary to horizontal teams you see so often, like the business analysts, the software de-velopers, the database admins and operation folks. Instead, you will have the "customer onboarding" team, that bundles all these roles and can act on its own.
Splitting up logic into microservices inﬂuences business processes and their models in BPMN. There are only rare cases where a business process will be handled completely by one microservice, instead you will see microservices that need to collaborate to implement end-to-end business processes.
If you now think of the Camunda house, this means that several operational processes (in the respective microservices) interact to achieve the overall goal. If we wanted to drive the metaphor further, it would probably be a village consisting of different Camunda houses. The end-to-end process from the customers’ point of view would probably be the gate in the city wall and... But let’s drop that and look at a small example in ﬁgure 1.10.
Microservice Insurance Application
Microservice Policy
FIGURE 1.10  Several microservices need to collaborate to implement an end-to-end business process. Every microservice has its own local process.
The microservice inbound application is responsible for end-to-end processing applica-tions for an insurance policy. Therefore it includes a BPMN process, which we’ve already looked at. Now, however, the policy itself is an independent task and will probably be dealt with in a separate microservice. This is perhaps only a facade in front of an existing legacy system. The two microservices must now work together to process a new application.
1.6 Domains, boundaries and the risk of BPMN monoliths	21
The challenge, by the way, is usually to determine the boundaries of the services and the exact responsibility of individual services.  There is no right or wrong, only more or less suitable. In our example, there are different variants that can all make sense. For example, the policy microservice could send out documents itself to the customer, but that could also be part of the application microservice. However, there may also be a separate service for sending documents. It is important to make a conscious decision and then design the processes accordingly.  For this topic we can recommend the literature around domain-driven design.  And if you are in need of a distraction anyway, please take a look on the Internet and search for the "bounded context".
At this point we just want to explicitly warn against, as we call it, "BPMN monoliths".  A BPMN monolith is a process model that mixes details from different microservices, thus not respecting their responsibilities and boundaries. Such a model does not have a single person responsible for the process and is usually very cumbersome to coordinate because too many stakeholders want to participate. You cannot automate this model directly be-cause it has to be distributed among different microservices.
Determine risks
Application received
Insurance Application

Risks?
None
Only yellow

Decide on application

Issue policy
Decision?          Application accepted
Application rejected

Trigger first invoice

Wait for first invoice to be paid
3 weeks

Invalidate policy

Send policy
Policy issued
Application approved but policy   timed   out
Note rejection in back-end
Red	system

Send rejection
Application rejected
FIGURE 1.11  Antipattern BPMN monolith: This model includes details about responsibilities from other microservices.
Figure 1.11 shows an example of such a BPMN monolith. In addition to the processing of the application, there is business logic of the policy included, like the fact that policies only become valid if the ﬁrst invoice is paid within a deﬁned period. The application microser-vice should not know this detail - it only wants to know whether a policy was successful or not - and perhaps how long it has to wait at most.
Weknowfromourownexperiencethatintheheatofasuccessfulmodelingworkshopthese monoliths can be created very quickly, as many details bubble out of the participants very naturally at this moment. Often it is even helpful to understand the overall situation and to allow these models. However, they may not be continued, let alone automated, so they are clearly an intermediate step before the process is sliced into individual parts. When doing so, the microservices boundaries must be taken into account.
And, of course, it can still make sense to design a monolithic system. In this case you can model and execute a BPMN monolith accordingly.
In chapter 4.5.3 on page 140 we will follow-up on this topic again with another example.
2   The notation in detail
2.1	Understanding BPMN
What does a monkey know about the taste of ginger?
This Indian proverb expresses the truism that you can’t fully appreciate what you don’t un-derstand. We see a corollary in the English expression, "Don’t cast pearls before swine."
BPMN is a pearl not everyone can appreciate because not everyone understands it. If you are new to the standard, you won’t regret spending some time to familiarize yourself with itsunderlyingprinciples. ForthosewhoalreadyknowtheBPMNspeciﬁcation, thischapter provides explanation and tips beyond the speciﬁcation itself.  It also describes the visual conventions we use when applying symbols. This is our modeling etiquette.
AfullunderstandingmakesBPMNanextremelypowerfultoolforanymodernBPMproject. Inourexperience, however, eventhosewithhighconﬁdenceintheirBPMNknowledgestill mayfailtounderstandcertainfundamentalprinciples,andtheyoftenexpresssurprisethat sequence ﬂows must not be drawn across pool boundaries.
2.1.1	Things BPMN does not do
BPMN was developed to model processes:  logical, chronological sequences of events. That’s all. Nonetheless, you often hear BPMN criticized for not representing:
■      Process landscapes
■      Organizational structures
■      Data
■      Strategies
■      Business rules
■      IT landscapes
We appreciate how important it is to incorporate these topics into process documentation. WealsoknowthatmanyprocessprofessionalscomefromthesystematicworldofArchitec-ture of Integrated Information Systems (ARIS) (see section 2.12.1 on page 89). They have worked with event-driven process chains (EPCs), and they may regard BPMN as insufﬁ-cient. But feasible (and even partly standardized) notations exist for the topics in the list
24	2  The notation in detail
Lane
above, and we are glad for it! It relieves BPMN of over-complication and keeps BPMN from being a monstrosity that nobody would want to compile, develop, or even understand. We remind those professionals that:
■      BPMN process models are easy to combine with other types of diagrams.  It is just a question of the tools used.
■      BPMN provides extension options, including custom symbols.  We explain this in sec-tion 2.11.2 on page 88.
Obviously it would be wonderful if BPMN could provide a complete, out-of-the-box alter-native for the ARIS methodology. We admit that’s not the case for the pure standard, but precisely because BPMN is a standard, software tools are now being created to use BPMN for the other necessary views.
2.1.2	A map: The basic elements of BPMN
When you draw a process diagram in BPMN, you use symbols that can be assigned to the categories shown in ﬁgure 2.1. We refer to these categories as the basic elements of BPMN.
In general, certain tasks have to be carried out during a process (activities), perhaps under certain conditions (gateways), and things may happen (events). What connects these three ﬂow objects are sequence ﬂows, but only within a pool. If connections cross pool bound-aries, the process resorts to message ﬂows.
Furthermore, artifacts provide additional information on the process, but these cannot in-ﬂuence the order of ﬂow objects directly.  Every artifact can connect to every ﬂow object
Flow objects	Connecting objects	Artifacts
Activity
Event
Gateway

Sequence flow
Message flow
Association

Annotation
Group
Custom artifacts

Text
?
Participants	Data
Data object
Data store
Lane
Pool

Data input
Data output
FIGURE 2.1  The basic elements of BPMN
2.1 Understanding BPMN	25
through associations. (You can also incorporate your own symbols as additional artifacts into a BPMN palette all your own. We detail this option in section 2.11.2 on page 88.)
BPMN contains an additional data category.  This refers to the creation, processing, and ﬁling of information that may become relevant within the scope of process handling, thus the category’s symbols usually connect to activities through associations.
There are three more aspects necessary to a full understanding of BPMN:
■      The advanced ideas and rules behind this simple scheme
■      The full range of symbols and
■      The practical know-how to apply this stuff
The ideas and rules and the full range of symbols are explained later in this chapter. The practicalknow-howisacquiredthroughexperience, butweofferourknowledgeinthesub-sequentchapterstohelpspeedyourprogress. We’vealsodevisedafewrecipesforapplying BPMN. They may help you to avoid some traps that often snare beginners.
2.1.3	Perspectives in process analysis
Someone accustomed to modeling processes with other notation systems may have trou-ble adjusting to an extremely important aspect of BPMN: everything depends on perspec-tive.
BPMN is based on the assumption that one or more participants can exist within one di-agram.  Do not, however, jump to the conclusion that a participant functions like a role, a department, or an employee!  In BPMN, a participant is a logical element to which the following rules apply:
■      There can be only one participant for each process.  (This means logical participants; there may be many human participants.)
■      The participant has complete control over the process ﬂow.
■      The participant is fully responsible for its process.
■      Otherparticipantscannotinﬂuenceaparticipant’sprocess;theymaynotevenknowhow it works.
■      If a participant wants to interact with other participants within the context of the pro-cess, the participant must communicate with the others, and they affect their own pro-cesses accordingly.
The same process may look completely different for each participant, and how it looks depends on its perspective. This results in different process models.
In BPMN, the symbol for a participant and for its process is the pool; each process gets its own pool. Logically, however, a participant can control more than one process.
If you learn to handle pools properly, you will have mastered the most signiﬁcant principle of process modeling —assuming you’re aiming for modern BPM aligned with necessary business IT. In section 2.9 on page 78, we detail this subject and also solve the riddle of why there can be only one logical participant for each process.
26	2  The notation in detail
2.1.4	Models, instances, tokens, and correlations
In the speciﬁcation for BPMN 2.0, Chapter 7 contains a section titled Understanding the behavior of diagrams.  It introduces the idea that the behavior of the diagrams must be understood as well as the processes they describe. (Note: Because a diagram may contain severalpools,asinglediagramimpliesnprocesses). Thisiseasierintheorythaninpractice because some process models are so complex that it becomes hard to know how to handle some circumstances. Remember the following:
■      Process model: The basic description of a process. A diagram may describe one or more process models.
■      Process instance: A process carried out in reality. One single customer complaint is an instance of the complaint process, for example.  Some processes may be instantiated only a few times in a year, such as end-of-quarter reporting in the accounting depart-ment. Other instances occur more often. Think of the millions of credit-report requests in a year’s time.
■      Token: You can apply the token model, if you have a process model in mind and want to ﬁnd out which process paths must or may be used during a process instance. A token is a concept we compare to a car: A car follows a road. At an intersection, its driver must decide to continue in a straight path or to turn left or right. Or perhaps the car turns and acloneofthecarcontinuesstraighton. Thisiswherethecarmetaphorbreaksdown, but we hope you get the gist: that the road system corresponds to a process model and that any particular route the car takes represents an instance. The token model can help you understand even the most complex BPMN process models, so tokens are also explained in the above-mentioned section of the BPMN speciﬁcation. We apply this method fre-quently in examples throughout this book.
■      Correlation: Do you ever get letters with a transaction key or a ﬁle number? When you reply, you are expected to reference the key or number to make it easier for your corre-spondent to allocate your communication properly. This allocation based on an unam-biguous key is called correlation. Another example is when you pay a bill, and you are asked to write the invoice number on your check.  If you don’t comply, your payment may not be properly allocated, and the lack of correlation can lead to reminder notices, late-payment fees, and other unpleasantness. Correlation is often crucial to the success ofprocesses,frombothorganizationalandtechnicalpointsofview. Someofthecostliest mistakes come from carelessness with the issue of appropriate correlation.
2.1.5	Symbols and attributes
The BPMN speciﬁcation describes the symbols provided for process modeling. It also de-scribes the many attributes that you can assign to the symbols. Many of these attributes don’t appear in diagrams, though they are stored in the modeling tool and used when a workﬂow engine executes the modeled process.
2.2 Simple tasks and none events	27
2.2	Simple tasks and none events
None start	Task event

None intermediate event

None end event
Hunger noticed

Acquire groceries

Prepare meal	Eat meal
Meal prepared Sequence flow

Hunger satisfied
FIGURE 2.2  Our ﬁrst process
Figure 2.2 shows a simple process triggered by someone being hungry.  The result is that someone must shop for groceries and prepare a meal.  After that, someone will eat the meal and have his or her hunger satisﬁed. You will easily recognize the following symbols and their meanings in the diagram:
Tasks
Tasks are the heart of the process. Ultimately, something has to happen to bring about a desired outcome. In BPMN, a task technically is part of the activities category, which also includes the subprocess explained in section 2.8 on page 66.
Our modeling etiquette
When naming tasks, we try to adhere to the object-oriented design principle of using the [verb] + [object] pattern. We would say acquire groceries, for example, not ﬁrst take care of shopping for groceries.
Events
Events describe signiﬁcant things that happen before, during, or at the end of a process. The example in Figure 2.2 uses only none events. None events can be used in a process ﬂow to indicate a status or a milestone. We explain about more event types later.
■      Start events show which event causes the process to start.
■      Intermediateevents stand for a status that is reached in the process and that is modeled explicitly. They are used infrequently, but intermediate events can be useful, for exam-ple, if you regard reaching a certain status as a milestone and you want to measure the time until the milestone is reached.
■      End events mark the status reached at the end of the process path. Even for these simple events, we have to make further distinctions:
■      Start events are catching events. That means something happened independent of the process, but the process has to wait for this event, or react to it.
■      Intermediate events may occur, or they may be caused or triggered by the process itself (throwing events). The none intermediate event marks a status reached by the process and is therefore a throwing event. (Again, we will explain about more event types later, including more types of intermediate events to be classiﬁed as catching events.)
28	2  The notation in detail
■      End events take place when the process can no longer react to them. As a consequence, only the process can trigger them.
Our modeling etiquette
Events refer to something that has already happened regardless of the process (if they are catching events) and as a result of the process (if they are throwing events). For this reason, we use the [object] and make the [verb] passive in voice, so we write hunger noticed. BPMN does not require you to model start and end events for a process —you can leave them out —but if you model a start event, you must model an end event for each path. The same is true for end events that require start events. We always create our models with start and end events for two reasons:  ﬁrst, that way it’s possible to determine the process trigger, and second, you can describe the ﬁnal status of each path end.  We only sometimes abandon this practice with subprocesses.  More on this later.
Sequence ﬂows
The sequence ﬂow describes the time-logic sequence of the ﬂow elements: tasks, events, and the gateways we describe later.
The process path taken by our token is also a sequence ﬂow.  It is born with the process instance because of the start event. Through the sequence ﬂow and by means of the tasks andtheintermediateevents,itreachestheendevent,whereitisconsumedanddisappears. This also leads to the death of our process instance.
Our modeling etiquette
We always draw our process diagrams horizontally, from left to right, but there is nothing to keep you from orienting your ﬂow diﬀerently. You may orient your diagrams vertically instead of horizontally, for example, although that is unusual.
2.3	Design process paths with gateways
2.3.1	Data-based exclusive gateway
Certain things can only be done under certain circumstances, so few processes always take the same course.
In our simple example (ﬁgure 2.3 on the facing page), we want to go into the details of cookery. Driven by hunger, we think about what we are going to cook today. We only know three recipes, so we choose one.  We can either cook pasta or cook a steak or prepare a salad. Let’s say that these options are exclusive —we will never prepare more than one at a time. The point of decision on what to do next is called a gateway. We decide based on available data (the chosen recipe) and we follow only one of the paths, which is a data-based exclusive gateway. We abbreviate exclusive gateway as XOR.
2.3 Design process paths with gateways	29
Desired dish?
Hunger noticed

Choose recipe
Data-based exclusive gateway (splitting)

Pasta	Cook pasta
Pasta done
Steak	Cook steak
Steak done
Salad
FIGURE 2.3  The XOR gateway.

Prepare salad
Salad done
Bear in mind that a gateway is not a task!  You have to determine facts and needs before reaching a gateway. We will encounter this again in Business Decision Management (see section 4.5.6 on page 144).
= FIGURE 2.4  Both symbols mean the same.
BPMN uses two symbols for XOR gateways (see ﬁgure 2.4). They are identical in meaning. We always use the version with the X because it seems less ambiguous, but use what works for you.
Our modeling etiquette
As in ﬁgure 2.3, we place the crucial question before the gateway. This is our convention, which has proved its value in our projects.  Possible answers go on parallel paths after the gateway, which is how the BPMN speciﬁcation shows them.  We always work with XOR gateways as follows:
1.  Model the task that requires a decision for the XOR gateway.
2.  Model the XOR gateway after that.  Create a question with mutually exclusive an-swers.
3.  Model one outgoing path (or sequence ﬂow) for each possible answer, and label the path with the answer.
An XOR gateway can have as many outgoing paths as you like. We start some paths in the upper left corner and the others in the bottom left corner, but these are just our style conventions.
By the way, it is not unusual to have three end events nor for the process to result in three end states. Recognizing this possibility can help you with more complex diagrams. Later,
30	2  The notation in detail
we will give more reasons for working with different end events.  BPMN is not a block-oriented process notation, so you need not merge a split process path later —you can, but you don’t have to.
Certainly, it may make semantic sense to merge the three paths. The meal is eaten after it’s prepared, regardless of the recipe chosen. We can use the XOR gateway for merging also, and doing so leads the tokens from the three incoming paths into a single outgoing path. (See ﬁgure 2.5.)
Desired dish?
Choose recipe	Pasta	Cook pasta
Hunger noticed

Eat meal
Hunger satisfied
Steak	Cook steak
Salad	Prepare salad

Data-based exclusive gateway (merging)
FIGURE 2.5  XOR gateways can also merge.
The double application of the XOR gateway —splitting and merging or XOR split and XOR merge —may confuse beginners.  You can even model an XOR gateway that merges and splits at once! (See ﬁgure 2.6.) You have to decide if you prefer to compact your diagrams this way.  For our part, we usually choose not to do that, and instead draw the two XOR gateways in succession. This method prevents misinterpretation.
Data-based exclusive gateway (merging and splitting)
Is xy applicable?

Data-based exclusive gateway (merging)

Data-based exclusive gateway (splitting)
Is xy applicable?
...	Yes	...
...	No	...

=	...	Yes	...
...	No	...
...	...
...	...
FIGURE 2.6  Two ways of representing a combined merge/split.
2.3.2	Parallel gateway
Suppose that now we want a salad on the side. If you want salad no matter what, you could model it as we have done in ﬁgure 2.7 on the facing page.
Here, we’ve introduced another symbol, the (text) annotation. This is an artifact that you can associate with any ﬂow object (in this case, tasks). You can enter any text; in our ex-
2.3 Design process paths with gateways	31
Desired dish?
Hunger noticed

Choose recipe
3 minutes

Prepare salad
10 minutes

Pasta	Cook pasta
15 minutes

Eat meal
20 minutes

Hunger satisfied
Association	Annotation	Steak	Cook steak
10 minutes
FIGURE 2.7  Preparing salad and main course.
ample, we entered the average time to carry out the associated task. The total of the task times equals the running time of the process, which was a total of 48 minutes for pasta and 43 minutes for steak. Congratulations: you’ve just analyzed your ﬁrst process based on key data!
Still,thismeanswaiting23oreven28minutesuntilyoucanstarttoeat. Insufferable! You’re really hungry, but what can you do? Maybe you don’t prepare the salad ﬁrst and then cook thepastaorthesteak, butyouworkonbothatthesametime—inparallel. Theappropriate symbol is the parallel gateway, or the AND gateway for short, as shown in ﬁgure 2.8.
Parallel gateway (parallelized)
Desired dish?

Parallel gateway (synchronizing)
Hunger noticed

Choose recipe
3 minutes

Pasta	Cook pasta
15 minutes

Eat meal
20 minutes

Hunger satisfied
Steak	Cook steak
10 minutes
Prepare salad
10 minutes
FIGURE 2.8  Preparing salad and main course at the same time.
Diagramming tasks as parallel does not make simultaneous processing compulsory.  In contrast to the example shown in ﬁgure 2.7, it is also not imperative that you prepare the salad before starting other tasks. Parallel preparation does, however, reduce our total time by 10 minutes. It is classic process optimization to make tasks parallel as much as possible.
As the example shows, the process is not only parallel (it uses an AND split), but the paths also synchronize later (an AND merge).  The reason is easy to understand: you can only start to eat after both main course and side dish are prepared.
How would the concept of tokens apply to an instance of this process? The token is born at the start event, it runs through the choose recipe task, and then it plunges into the AND split. One token emerges from the gateway for each path. That means two tokens in this
32	2  The notation in detail
example: The ﬁrst token enters the XOR split, and its outgoing path depends on the recipe selected.
Let’s assume we want to cook pasta. The token enters the task and stays there 15 minutes. At the same time, the second token enters the second, prepare salad task, where it stays only10minutes. After10minutes, itmovesontotheANDmerge. Thenumberofincoming paths determines the number of related tokens the gateway is waiting for, so here, it waits for two tokens of the same process instance.
In our scenario, the second token arrives at the AND merge after 10 minutes, while the ﬁrst token stays in cook pasta for a total of 15 minutes. This means the AND merge waits until the ﬁrst token arrives —an additional 5 minutes. At that point, the tokens happily merge into a single token, which continues on the outgoing path.
Does that sound too abstract or technical? It is not. The AND merge behavior is identical to your own: The salad is ready, but the pasta is not, so you wait. When the pasta ﬁnally is ready, you eat.
Why the seemingly complicated token concept then? Think of 90 million process instances created by credit agencies, for instance, every year.  Surely, these aren’t executed in strict sequence. They overlap. To deﬁne and carry out such complex processes and their various parallel operations, branchings, mergings, and synchronizations correctly every day, the token approach is not only extremely helpful in conceptual design and implementation, but also necessary.  We hope it is clear by now that process instances are not identical to tokens: Many tokens can run within the bounds of a single process instance.
Check your understanding with the following questions:
Question: Figure 2.9 shows the same process, but the AND merge was left out for lack of space, and the path from the prepare salad task leads directly to the XOR merge.  What happens if we instantiate the process, and we decide in favor of pasta?
Desired dish?
Hunger noticed

Choose recipe
3 minutes

Pasta	Cook pasta
15 minutes

Eat meal
20 minutes

Hunger satisfied
Steak	Cook steak
10 minutes
Prepare salad
10 minutes
FIGURE 2.9  What happens in this process?
Answer: The token is generated and then cloned as always at the AND split. As soon as we ﬁnish preparing the salad, the token passes through the XOR merge and eat meal executes. Five minutes later, cook pasta also completes. Its token passes through the XOR merge and eat meal executes again! That’s not the behavior we wanted.
Question: Figure 2.10 on the facing page shows a process that consists of two tasks only. Once instantiated, how long does the process instance live?
2.3 Design process paths with gateways	33
Task 1
Start	End
30 days
Task 2
End
45 days
FIGURE 2.10  How long does the process instance live?
Answer: It lives 45 days, which corresponds to the run time of the process. Even though the token generated in the AND split passes through task 1 after 30 days and then is consumed by the upper end event, the second token stays in task 2 for an additional 15 days.  The process instance continues to live until the second token is consumed by the lower end event.
Note: As long as just one token lives within the process, the process instance lives too! The instance cannot ﬁnish until all tokens generated are consumed.
2.3.3	Data-based inclusive gateway
We want to make our process even more ﬂexible: When we are hungry, we want to eat
■      Only a salad,
■      A salad and "something real," like pasta or steak, or
■      Only something real.
Using the symbols you have learned so far, you could model the situation as shown in ﬁg-ure 2.11.
Something real
desired?         Desired dish?
Hunger
noticed

Choose recipe
3 minutes

Yes	Pasta
No

Cook pasta
15 minutes

Eat meal
20 minutes

Hunger
satisfied
Steak	Cook steak
10 minutes
Salad desired?
Yes	Prepare salad
No	10 minutes
FIGURE 2.11  Various options in the combination of our meal.
If you want a more compact representation, you can use the data-based inclusive gateway —the OR gateway for short.  (See ﬁgure 2.12 on the following page.)  Use OR gateways to describe and/or types of situations, in which processing can ﬂow along one, many, or all outgoing paths. OR gateways can keep diagrams from becoming overly complex.
34	2  The notation in detail
Data-based inclusive gateway (splitting/parallelizing)
Desired components?

Data-based inclusive gateway (merging/synchronizing)
Desired dish?
Hunger noticed

Choose recipe
3 minutes

Something real

Pasta	Cook pasta
15 minutes

Eat meal
20 minutes

Hunger satisfied
Steak	Cook steak
10 minutes
Salad	Prepare salad
10 minutes
FIGURE 2.12  The OR gateway enables the compact representation of complex path variants.
We can use OR gateways to combine paths too: Depending on whether we want to eat just a salad or something real, or a salad and something real, we have to wait either for one token to arrive (merge) or for both tokens (synchronize) before we can eat. Note the differ-encebetweenthisandﬁgure2.11onthepreviouspage,however. Intheversionwithoutthe OR gateway, we could have resolved not to prepare anything (neither salad nor something real), but we ate after this decision. The OR gateway excludes this absurdity. We have to de-cide at least in favor of a salad and/or something real, otherwise the token gets stuck in the gateway. Strictly speaking, the BPMN speciﬁcation determines that a runtime error occurs in such a case, and that’s important when it comes to technical process implementation.
In practice, handling OR gateways is not as simple as these examples imply.  It’s easy to understand that progress depends on waiting for another token to reach an OR merge. It can be harder to trace the synchronization rules with complex diagrams that sprawl across several pages. Just memorizing the conditions that apply at the OR split isn’t a solution.
1st question
Answer 1	Task 1	Task 3
Start	End
Answer 2	30 days
Task 2

2nd
question    Answer 2
Answer 1
45 days
End
FIGURE 2.13  How long does the second gateway have to wait?
Consider ﬁgure 2.13:  whether the OR merge needs to synchronize or not depends on whether the OR split runs through one or more paths. Here’s the scenario: The ﬁrst token reaches the OR merge after 30 days.  Because answer 2 applied to the previous OR split too, another token is on its way, and it will stay in task 2 for another 15 days.  This task
2.3 Design process paths with gateways	35
is completed, so it becomes possible that a decision made at the XOR split results in the second token being routed through the answer 1 path, and being consumed by the end event.  What happens to the ﬁrst token at the synchronizing OR merge?  The OR gateway must register that the second token has vanished, and it must forward the ﬁrst token.
This could cause problems in three circumstances:
■      You come across an OR merge in your process manual on page 10, and you have to rum-magethroughtheprevious9pagestounderstandwhatconditionsrequirewhichwaiting times.
■      You implement such a process in an organization that makes a person responsible for task 3 but permits that person no control over the process.
■      A workﬂow engine runs the process and controls the synchronizing behavior.  It is ex-pensive to implement such a check, and it is bound to fail.  In some cases it may be impossible.
There are a couple of reasons for using the OR gateway —with caution.
Question: Can we model the process as shown in ﬁgure 2.14?
Desired dish?
Hunger noticed

Choose recipe
3 minutes

Pasta	Cook pasta
15 minutes

Eat meal
20 minutes

Hunger satisfied
Steak	Cook steak
10 minutes
Salad	Prepare salad
10 minutes
FIGURE 2.14  An incredibly (?) compact version.
Answer: Sure, this makes the model more compact, but it changes the meaning. This pro-cess model produces the following outcomes:
■      We eat only pasta.
■      We eat only steak.
■      We eat only salad.
■      We eat pasta and salad.
■      We eat steak and salad.
■      We eat pasta and steak.
■      We eat pasta, steak, and salad.
And the last two outcomes aren’t what we intend!
36	2  The notation in detail
2.3.4	Default ﬂow and getting stuck
There’s another aspect to working with XOR and OR gateways.  (To simplify matters, let’s set the salad aside for now and focus on real meals.)  What happens if we want neither pasta nor steak? In the previous models, this situation meant that our token could never getbeyondtheXORsplitfordesireddish. AccordingtotheBPMNspeciﬁcation, thatthrows an exception. In other words, a runtime error occurs.
Don’t get angry because we are talking about throwing exceptions! We’ll come back to this issue and show why it doesn’t concern only IT.
The so-called default ﬂow protects us from runtime errors.  We indicate the default ﬂow with the small slash shown in ﬁgure 2.15. The principle behind default ﬂows is simply that all outgoing paths are examined; when none of the other paths apply, the process uses the default. Don’t mistake the default ﬂow for the usual ﬂow, however. The symbol does not mean that the default applies most of the time. That’s a different question.
Desired dish?
Choose recipe	Pasta	Cook pasta
Hunger noticed

Eat meal
Hunger satisfied
Default flow
(to be recognized by the small slash)

Steak	Cook steak
Have pizza delivered
FIGURE 2.15  The default ﬂow.
Our modeling etiquette
You don’t have to use a default ﬂow, of course.  You can draw a normal sequence ﬂow instead and label it other or whatever you like. We use the default ﬂow any time there’s a risk of getting stuck, and we want to avoid disruption to the organization.   If a dia-grammed decision has Yes or No outﬂows only, risk is zero; more complex decisions present greater risk.
In our models, default ﬂows help us to determine if we have limited the risk of getting stuck. In terms of aligning business and IT goals, this is certainly good business practice.
2.3.5	Complex gateway
The complex gateway is a category apart. While it isn’t used often, there are situations that justify its use.  An example: we want to order pizza.  We peruse the menu of our favorite supplier, but just for a change, we also look on the Internet. Once we ﬁnd something we want to try after researching both sources, we order the pizza.
How can we model that?  The attempt shown in ﬁgure 2.16 on the next page results in ordering the pizza only after the research in both sources completes.
2.3 Design process paths with gateways	37
Hunger noticed

Read menu
Research on the Internet

Have pizza delivered

Eat meal
Hunger satisfied
FIGURE 2.16  Pizza research with AND merge.
Inﬁgure2.17, neitherisanoption: Basedonthetokenconcept, wewouldexecutetheorder pizza task twice. (Remember the test question in section 2.3.2 on page 30?)
Hunger noticed

Read menu
Research on the Internet

Have pizza delivered

Eat meal
Hunger satisifed
FIGURE 2.17  Pizza research with XOR merge.
Nor does the OR merge in ﬁgure 2.18 solve the problem: When a token arrives at the OR merge, the process waits for corresponding tokens that may never get there. The OR merge behavior is thus the same as an AND gateway.
Hunger noticed

Read menu
Research on the Internet

Have pizza delivered

Eat meal
Hunger satisfied
FIGURE 2.18  Pizza research with OR merge.
Thesolutionisthecomplexgatewaycombinedwithanannotation, asshowninﬁgure2.19. As soon as one of the two tasks completes, the complex merge sends the token to the order pizza task. When the next token reaches the complex merge, it is consumed. It vanishes.
Hunger noticed

Read menu
Research on the Internet

Complex gateway
Have pizza delivered
Proceed as soon as a result is available

Eat meal
Hunger satisfied
FIGURE 2.19  Pizza research with complex merge.
Here’s a similar situation:  Assume we execute four tasks at once.  There’s a ﬁfth task to execute once three of the ﬁrst four tasks complete. For example, we ask four friends what
38	2  The notation in detail
pizza place they want to order from. Once three friends have offered opinions, we decide. We can model our synchronizing behavior with a complex gateway. (See ﬁgure 2.20.)
Ask Christian	Proceed as soon as three of them have given their opinions.
Hunger noticed

Research pizza delivery service

Ask Falko
Ask Robert

Make purchase decision

Purchase decision made
Ask Stefan
FIGURE 2.20  Using complex gateways to realize m out of n merges.
Inprinciple,acomplexgatewayalsocanbeappliedasasplit—tosummarizeseveraldiffer-ent gateways in one symbol to save some space, for instance. The OR split from the process in ﬁgure 2.14 on page 35 could be replaced with a complex gateway by writing the split se-mantics in an annotation. That doesn’t really make sense, though, and we have never used the complex gateway as a split nor seen it used in any practical model.
2.4	 Design process paths without gateways
Some people don’t like gateways.  They think gateways make process diagrams too com-prehensive or even inﬂated, and they would rather do without all those diamonds. While gatewaysare optional—youcaninsteadmodelthelogicoftheXOR,AND,andORgateways directly with the tasks —you have to be careful. It’s rare that you can eliminate gateways entirely.
Figure 2.21 on the facing page illustrates an alternative to the OR split as well as to the XOR merge. Theupperandthelowerprocessmodelsareequivalent,buttheuppermodelshows two ﬂows routing directly to task 4.  It also represents the OR split with conditional ﬂow symbols: the small diamonds connected to task 1. Conditional ﬂow symbols may connect only to tasks or subprocesses, and only as outlets. They may not be used with gateways or events.
If you read section 2.3 on page 28 carefully, you likely see the problem with this: If only one ofthetwoconditionsapplies,everythingisokay,butifbothapply,theygeneratetwotokens in the OR split and so trigger task 4 twice thanks to the XOR merge. This isn’t necessarily wrong, but it probably isn’t intended.  And that brings us to the ﬁrst problem associated with gateway abstinence:
We cannot model synchronizations (that is, AND merges) without gateways.
2.4 Design process paths without gateways	39
Conditional flow
Condition 1	Task 2
Task 1	Task 4
Start	Condition 2	Task 3	End
=
Condition 1	Task 2
Task 1	Task 4
Start	Condition 2	Task 3	End
FIGURE 2.21  OR split with conditional ﬂows and XOR merge.
The second problem is that we can’t combine conditional checks. We can’t represent the process logic shown in ﬁgure 2.22 without gateways because of the intermediate event.
Answer 1	Task 2 Status 1
reached
Question
Answer 1
Answer 2	Task 3
Task 1	Question	Task 5
Start	Answer 2	End
Task 4
FIGURE 2.22  Combined XOR gateways.
The third problem is that conditional ﬂows follow the same semantics as the OR split. In other words, the deﬁned conditions must not exclude each other. Because the OR split is compatible with the subsequent XOR split, this isn’t crucial, but modelers and those who use their diagrams need to be aware of this. Otherwise, in our experience, misunderstand-ings quickly result.
Would it be better to use gateways all the time? No, there’s no need for that either. A simple loop, for example, can be better off without XOR merges because it’s less confusing for the inexperienced. And because BPMN permits multiple ﬂows from start events to end events, the diagrams can be nicely compact.  We modeled the process in ﬁgure 2.23 on the next page with and without gateways to illustrate this.  (Yes, technically speaking, the models are not identical: The upper one includes the XOR gateway syntactically, so several paths
40	2  The notation in detail
must be used. It requires that conditions 1 and 2 never occur at the same time. This is not the case in the lower model, where both conditions can apply.)
Task 3
Task 1
Task 4
Start		End Question
Task 2	Condition 1
Condition 2
=
Task 3
Task 1
Task 4	End Start
Task 2	Condition 1 Condition 2
FIGURE 2.23  Both models describe (almost) the same process.
2.5	Lanes
We have talked about what to do in our processes, but we have not yet explained who is responsible for executing which tasks. In BPMN, you can answer this question with lanes.
Figure 2.24 on the facing page shows that the tasks in our sample process were assigned to particular people. We can derive the following process description from the assignments: If Christian is hungry, he chooses a certain recipe. Depending on what Christian chooses, he can either take care of it himself (cook pasta), or he can get his roommates on board. If thelatter,FalkocookssteakandRobertpreparessalad. Intheend,Christianeats. Thethree
2.5 Lanes	41
Lane
Desired components?

Desired dish?
Choose recipe
Hunger noticed
Christian
Flat-sharing community

Something real

Pasta	Cook pasta	Eat meal
Hunger satisfied
Steak	Cook steak
Falko
Salad	Prepare salad
Robert
FIGURE 2.24  Responsibilities represented using lanes.
lanes (Christian, Falko, Robert) are united in one pool designated ﬂat-sharing community. We discuss pools in detail in section 2.9 on page 78.
Intheexample, lanesequatetopeople, butthismeaningisnotspeciﬁedbyBPMN.Youcan designate the lanes as you like. In practice, lanes are often used to assign:
■      Positions in the primary organization, for example, accounting clerk.
■      Roles in the secondary organization, for example, data protection ofﬁcer. ■      General roles, for example, customer.
■      Departments, for example, sales.
■      IT applications, for example, CRM system.
Tooling
Some tools enable you to assign the elements in your diagram to diﬀerent categories or views, such as executing positions, responsible positions, supporting IT applications, and so on. You can also show the process from the respective view. This changes the lanes, and arranges the elements accordingly.
Incidentally, lanes have a long history in the world of process modeling. They’re analogous to a swimming pool in which swimmers swim only in the lanes to which they are assigned. Swimlane representations are common to different process notations.
Our modeling etiquette
BPMN does not specify that you have to order tasks either vertically or horizontally.  In ﬁgure 2.25 on the following page, the process starts in the top left corner and ends in the bottom right, and that is our convention, but you can model it from the bottom left to the top right as well. The essential thing is that you decide on a style for structuring your diagrams, and then apply it consistently. Keeping to your standard makes your diagrams easier to read from one to the next.
42	2  The notation in detail
Lane 3
Pool
In BPMN, lanes can also interlace to illustrate reﬁned responsibilities. (See ﬁgure 2.25.)
Task 1
Lane 1
Start
Task 2
Lane 2
Task 3
Lane 3.1
Task 4
Lane 3.2
FIGURE 2.25  Interlacing lanes.
Handling lanes often is trickier than you may expect. In our little process, for example, we assume that the tasks are clearly distributed. But what if Falko and Robert want to eat too? A representation like that in ﬁgure 2.26 would be syntactically wrong. It is not permissible to have a ﬂow object (activity, event, gateway) positioned outside a single lane.
The solutionforkeepingFalko andRoberthappyisto duplicate the eat meal taskandto as-sign this task to each person (ﬁgure 2.27 on the next page). This also makes sense content-wise, because the task actually is completed three times.  There is still the possibility of misconception, however, since it is not evident that the three men eat together. It may not matter if Falko and Robert dine with Christian, but in cases where cooperation is intended —perhaps the task is furnish expert opinion and you want a joint opinion, not a collection of individual ones —you could apply a group frame as shown in section 2.11.1 on page 87.
Note: In our process diagrams, we don’t separate lane captions from the lanes themselves. This complies with BPMN version 2.0, which explicitly forbids such a separation. This is a change from version 1.2, where it was permitted. You may encounter BPMN diagrams like ﬁgure 2.28, and the tool you work with may only allow lanes with separate lane headers.
Desired components?

ERROR: This representation is not permissible in BPMN!
Desired dish?
Choose recipe
Hunger noticed
Christian
Flat-sharing community

Something real

Pasta	Cook pasta
Hunger satisfied
Eat meal Steak	Cook steak
Falko
Salad	Prepare salad
Robert
FIGURE 2.26  Incorrect lane handling.
2.6 Events	43
Pool
Falko
Lane 3
Desired components?

Desired dish?
Choose recipe
Hunger noticed
Christian
Flat-sharing community

Something real

Pasta	Cook pasta	Eat meal
Hunger satisfied
Steak
Salad
Robert
FIGURE 2.27  Correct lane handling.

Cook steak
Prepare salad

Eat meal
Eat meal

Hunger satisfied
Hunger satisfied
This separator was permissible only until BPMN version 1.2!
Task 1
Lane 1
Start
Task 2
Lane 2
Task 3
Lane 3.1
Task 4
Lane 3.2
End
FIGURE 2.28  The lane separators between lane header and lane body were allowed only until BPMN 1.2.
2.6	Events
2.6.1	Relevance in BPMN
Tasksandgatewaysaretwoofthreeﬂowelementswe’vecometoknowsofar: Things(tasks) have to be done under certain circumstances (gateways). What ﬂow element is still miss-ing?  The things (events) that are supposed to happen.  Events are no less important for BPMN process models than tasks or gateways. We should start with some basic principles for applying them. In section 2.2 on page 27, we saw:
■      Catching events and throwing events
■      Start events, intermediate events, and end events
Catching events are events with a deﬁned trigger. We consider that they take place once the trigger has activated or ﬁred. As an intellectual construct, that is relatively intricate, so
44	2  The notation in detail
we simplify by calling them catching events. The point is that these events inﬂuence the course of the process and therefore must be modeled. Catching events may result in:
■      The process starting
■      The process or a process path continuing
■      The task currently processed or the subprocess being canceled
■      Another process path being used while a task or a subprocess executes
Throwing events are assumed by BPMN to trigger themselves instead of reacting to a trig-ger. You could say that they are active compared to passive catching events. We call them throwing events for short, because the process triggers them. Throwing events can be:
■      Triggered during the process
■      Triggered at the end of the process
Start events are therefore events that always occur.  The process cannot trigger an event before it has even started. The simplest application of a start event is shown in ﬁgure 2.29. When the event occurs, the process starts.
?	Task 1	...
Event 1
FIGURE 2.29  Once event 1 occurs, the process is started.
Note: The question mark in the circle indicates that this event can be allocated to a certain type. So far, we have only covered none events. The possible event types are explained in the following sections.
Different events may trigger the process, which could be modeled as shown in ﬁgure 2.30. It is important that each event triggers its own process instance.
?
Event 1	Task 1	...
?
Event 2
FIGURE 2.30  Once events 1 or event 2 occurs, the process is started.
Ontheotherhand,supposeyouwanttomodelseveraleventsthathavetotakeplacebefore the process starts. A lot of people would model this situation as shown in ﬁgure 2.31 on the next page.
This is intuitive, but unfortunately it is not correct, and few BPMN beginners understand why it is not correct. The reason is that the AND merge does not support the correlation already mentioned in section 2.1.4 on page 26, so the process will not recognize the two events as being associated. We will explain this problem in greater detail in section 2.6.14 on page 58, and we will describe how BPMN provides the solution.
The process may require that a speciﬁc intermediate event occurs, as shown in ﬁgure 2.32. After task 1 completes, event 1 has to occur before task 2 can complete.  With the token
2.6 Events	45
?
Event 1	Task 1	...
?
Event 2
FIGURE 2.31  Bad: Technically speaking, this model would lead to a deadlock.
approach, the token waits at event 1 until it occurs.  Only then does the token continue, and it starts task 2.
...	Task 1	?	Task 2	...
Event 1
FIGURE 2.32  After task 1, the process waits until event 1 has occurred. Only then does it proceed to task 2.
Note: The none event (as explained in section 2.2 on page 27) is not a catching event.  It belongs to the throwing events.
Howcanwerepresentthataprocesshastowaitfortwoevents? Whatweshowinﬁgure2.33 isﬂawed. Aftertask1completes,thetokencontinuesandwaitsforevent1tooccur. Ifevent 2 occurs while the token is waiting on event 1, the token will not notice it. Even worse, if event 1 occurs after event 2, the token continues and then waits for event 2 to occur. Since event 2 already occurred, the token will wait forever.
...	Task 1	?	?	Task 2	...
Event 1	Event 2
FIGURE 2.33  Sequential intermediate events can only be recognized one after the other.
The semantics of catching events is therefore not to check for a condition that already may have been fulﬁlled, but to treat the catching event as a transitory signal that vanishes im-mediately after the occurrence. The process therefore can handle the event only if it is in a ready-to-receive state at exactly the moment it occurs. This details can usually be ignored in purely functional process modeling, however, it must be adhered to in technical process modeling (section 6.4.5).
Ifweneedtowaitfortwoeventsthatmayoccurindependently,butbotheventsmustoccur before the process can continue, we represent the situation as in ﬁgure 2.34 on the next page.
We can model attached intermediate events with BPMN. These do not explicitly require waiting, but they do interrupt our activities, both tasks and subprocesses (which will be discussed later). Such intermediate events are attached because we position them at the boundary of the activity we want to interrupt. A token running through the process shown in ﬁgure 2.35 would behave this way:
46	2  The notation in detail
?
Event 1
...	Task 1	Task 2	...
? Event 2
FIGURE 2.34  Using the AND gateway to wait for several events at the same time.
■      The token moves to task 1, which starts accordingly.
■      If event 1 occurs while task 1 is being processed, task 1 is immediately canceled, and the token moves through the exception ﬂow to task 3.
■      On the other hand, if event 1 does not occur, task 1 will be processed, and the token moves through the regular sequence ﬂow to task 2.
■      If event 1 occurs only after task 1 completes, it ceases to matter.
...	Task 1	Task 2	...
? Event 1
Task 3	...
FIGURE 2.35  Event 1 cancels task 1 and starts task 3.
Attached intermediate events do not have to result in canceled activities because of the non-interrupting intermediate event. It sounds awkward, but it is useful. The token moves through the process section shown in ﬁgure 2.36 on the next page as follows:
■      The token moves to task 1, which starts accordingly.
■      If event 1 occurs while task 1 is being processed, the token is cloned. Task 1 continues to be processed while the second token moves to task 3, which is now also processed. This procedure may even take place repeatedly, that is, the event can occur many times. Each occurrence results in another cloned token.
■      If event 1 does not occur, task 1 will be completed, and the token moves through the regular sequence ﬂow to task 2.
■      If event 1 occurs only after task 1 completes, it ceases to matter.
Throwing intermediate events are triggered by the process. That means a token occurring at such an event triggers it, then immediately moves on. Throwing events do not lead to canceled activities, which is why they can never be attached.  They occur only in the se-quence ﬂow. We already know the none intermediate event, which can be used to model the entry into a deﬁned status. This is a throwing event too.
In the following sections, we introduce the event types to be used when working with BPMN. We also explain how you can react to different events using the event-based gate-way. The event types are:
2.6 Events	47
...	Task 1	Task 2	...
? Event 1
Task 3	...
FIGURE 2.36  The occurrence of event 1 results in starting task 3, while task 1 is being further processed.
■      Message ■      Timer
■      Error
■      Conditional ■      Signal
■      Terminate ■      Link
■      Compensation ■      Multiple
■      Parallel
■      Escalation ■      Cancel
2.6.2	Message events
Sooner or later, most processes require communication, which can be represented in BPMN by means of the message event.   You’ll recognize it as the small envelope.   The general application of the message event is shown in ﬁgure 2.37 on the following page.
Start
Attached (interrupting)

Intermediate   Intermediate (catching)       (throwing)
...	BPMN 2.0: Attached (non-interrupting)

End
...
FIGURE 2.37  Applying the message event.
The meaning of message in BPMN is not restricted to letters, e-mails, or calls. Any action that refers to a speciﬁc addressee and represents or contains information for the addressee is a message.  In ﬁgure 2.38 on the next page for example, the pizza ordering issue has been fully modeled: We choose a pizza, and we order it. We then wait for the pizza to be delivered. After delivery, we eat. Notice that there is no order pizza task.
48	2  The notation in detail
Choose pizza
Hunger noticed

Pizza ordered

Pizza received

Eat pizza
Hunger satisfied
FIGURE 2.38  Ordering and getting pizza as a message event.
What’s shown in ﬁgure 2.39 on the following page would in fact be wrong: The throwing intermediate event pizza ordered implies that we have ordered a pizza. If a corresponding task were added, it would result in a double deﬁnition and therefore be meaningless.
Choose pizza
Hunger noticed

Order pizza
Pizza ordered

Pizza received

Eat pizza
Hunger satisfied
FIGURE 2.39  Wrong content: According to this process model, we would order the pizza twice.
In ﬁgure 2.40, we show a message leading to cancellation. In this scenario, we administer a web application. When a user notiﬁes us that the website does not work, we immediately search for the error.  But maybe the user is mistaken, and the website is ﬁne.  Maybe the user’s Internet connection is defective. If the user tells us about the false alarm, we cancel thesearchandswearattheuserforwastingourtime. Iftheerrorisactuallyfound,however, we eliminate it and simultaneously ﬁgure out who caused the error. If the user caused the error, we can swear at the user for a different reason. If the user is not at fault, however, we thank him or her graciously for letting us know about the problem.
2.6 Events	49
8VHU¶VRZQ fault?
Search for error	Eliminate error	No	Thank the user
User reports: ³The website broke down!´

User reports: ³Sorry, false alarm!´

Yes	User thanked
Swear at user
User sworn at
FIGURE 2.40  The attached message event results in the cancellation of the task Search for error.
Choose pizza
Hunger noticed

Order pizza
Pizza received

Eat pizza
Hunger satisfied
FIGURE 2.41  Our convention: tasks for sending, events for receiving messages.
Our modeling etiquette
We are not always happy with the throwing intermediate event. Implying a send message task without modeling it explicitly can easily confuse inexperienced consumers of our models. We choose not to use throwing intermediate events for messages and instead use a task. (See ﬁgure 2.41.) In section 2.7 on page 61, we explain that there are special BPMN task types for sending and receiving messages.
2.6.3	Timer events
The timer event is often used when working with BPMN because it is so ﬂexible to apply. A clock icon represents the timer event. You can see it applied in ﬁgure 2.42. You can use timer events to start processes:
■      Once, at a scheduled time
■      Repeatedly at scheduled times
■      At timed intervals
Start
Attached (interrupting)

Intermediate (catching)
...

BPMN 2.0: Attached (non-interrupting)

...
...
FIGURE 2.42  Applying a timer event.
50	2  The notation in detail
■      Relative to other events
As an intermediate event, a timer event can stop a process until:
■      A scheduled time arrives.
■      A deﬁned span of time has elapsed.
■      A time relative to another event expires.
Figure 2.43 on the next page shows a few examples of applications.  Time moves on no matter what we or our processes do, so timer events can exist only as catching starts or intermediate events.
Work day
Monday-Friday At 07:00 a.m.
Every 2 hours
User support
Two months before trip starts
Vacation
2/14/2014 08:00 a.m.
9DOHQWLQH¶VGD\
2014

Get up
Check incoming e-mails
Choose destination
Get up

Use the bathroom
Screen for most pressing issue
Book trip
Buy flowers

08:00 a.m.
Coffee break (10 minutes)
Two days before trip starts
2/14/2014 09:00 a.m.

Take bus to work
Attend to most pressing issue
Pack suitcases
Wake partner up with flowers

...
...
...
...
FIGURE 2.43  Examples of timer events.
You can model countdown times with an attached timer event.  They are used this way frequently. Youcanspecifyuppertimelimits—themaximumtimeallowedforaprocessing task —for instance. Figure 2.44 on the following page shows a process in which a task may take a maximum of 30 minutes. If the time expires before the task completes, the choose pizzataskiscanceled, andwecookpastainstead. Ineithercase, weeatthemealattheend.
Timer events can be non-interrupting. Figure 2.45 on the preceding page shows another example of this. Before we can eat, we have to prepare the meal and set the table, but we only start setting the table 10 minutes before the meal is ready.
2.6 Events	51
Hunger noticed

Choose pizza
30 minutes

Order pizza
Pizza received

Eat meal
Hunger satisfied
Cook pasta
FIGURE 2.44  The timeout for the choose pizza task is 30 minutes.
Choose recipe
Hunger noticed

Prepare meal
10 minutes before finishing
Set the table

Eat meal
Hunger satisfied
FIGURE 2.45  You can attach timer events that do not lead to cancellation, but instead generate another token.
2.6.4	Error events
Do your processes run completely error-free?  If not, you can identify potential errors in your models as a step toward eliminating them, or as part of modeling escalation pro-cesses.  In BPMN, error events are represented by a ﬂash symbol.  Apply them as shown in ﬁgure 2.46.
...
End
Attached
(interrupting)	...
FIGURE 2.46  Applying an error event.
The BPMN speciﬁcation does not specify what an error may be. As the modeler, you have to decide that. Section 4.5.1 on page 134 has some hands-on tips.
An error is a serious event in BPMN, so it can be modeled only as an attached intermediate event. Thismeansthatanerrorduringtaskexecutionmustbehandledinaspeciﬁcway: As athrowingevent, itcanbemodeledonlyattheendofaprocesspathsothattheparticipant knows the process has failed. The parentprocess shouldlikewise recognize the failure. (We explain the interaction between parent and subprocesses in section 2.8 on page 66. You’ll also ﬁnd an example of applying an error event there.)
52	2  The notation in detail
2.6.5	Conditional
Sometimes we only want a process to start or to continue if a certain condition is true. Anything can be a condition, and conditions are independent of processes, which is why the condition (like the timer event) can only exist as a catching event (ﬁgure 2.47).
Start

...
Intermediate (catching)
Attached (interrupting)

BPMN 2.0: Attached ...	(non-interrupting)

...
FIGURE 2.47  Applying a conditional event.
We can enhance our pizza process with conditions.  If we want to have frozen pizza, the process starts as shown in ﬁgure 2.48 on the next page. We take the pizza from the freezer
andturnontheoven. Butweonlyputthepizzainafterthetemperatureintheovenreaches 180 ◦ C, and we only take it out to eat after it is done.
Frozen pizza wanted

Take pizza out of freezer

Start oven
Oven at 180°C

Put pizza into oven
Pizza done

Eat pizza
Hunger satisfied
FIGURE 2.48  Baking pizza under fully modeled conditions.
If we know how long the pizza needs to cook, we can specify this in the process model by substituting a timer event for the last conditional event. The whole thing would then look as shown in ﬁgure 2.49.
Frozen pizza wanted

Take pizza out of freezer

Start oven
Oven at 180°C

Put pizza into oven
20 minutes

Eat pizza
Hunger satisfied
FIGURE 2.49  Baking pizza with indicated baking time.
2.6.6	Signal events
Signals are similar to messages, which is why you can model them in BPMN as events just as you can with messages (ﬁgure 2.50).  The symbol for a signal is a triangle.  The essen-tial difference between a signal and a message is that that latter is always addressed to a speciﬁc recipient. (An e-mail contains the e-mail address of the recipient, a call starts with dialing the telephone number, and so on.) In contrast, a signal is more like a newspaper advertisement or a television commercial. It is relatively undirected. Anyone who receives the signal and wants to react may do so.
We saw a new frozen pizza on TV, and we are keen to try it. Figure 2.51 illustrates this new situation.
2.6 Events	53
Start
Attached (interrupting)

Intermediate   Intermediate (catching)       (throwing)
BPMN 2.0: Attached
...	(non-interrupting)

End
...
FIGURE 2.50  Applying the signal event.
Pizza TV ad seen

Buy pizza	Eat pizza
In the mood for pizza

Rated pizza on Pizzatest.de
FIGURE 2.51  Pizza signals.
We buy the pizza, but we keep it in the freezer until we’re really hungry for pizza. That’s a conditional event. After trying the new pizza, we go to Pizzatest.de to rate the new product. That’s a signal. It is a signal for the general public too. (Pizzatest.de actually exists, by the way, which proves again that you can ﬁnd simply everything on the Internet!)
2.6.7	Terminate events
Let’s look at the abstract example in ﬁgure 2.52.  We already discussed (simple) Key Per-formance Indicator (KPI) analysis in section 2.3.2 on page 30, and we therefore know that this process always takes 55 minutes. After task 1, tasks 2 and 3 can be processed simul-taneously. Processing task 2 takes more time than does processing task 3, which is why it determines the runtime of the process. A token that runs through the process is cloned in the AND split. The ﬁrst token stays in task 2 for 45 minutes; the second token stays in task 3 for 30 minutes. The second token arrives at the none event ﬁrst, where it is consumed. After15moreminutes,theﬁrsttokenarrivesattheuppernoneevent,whereitisconsumed too. Since no more tokens are available, the process instance ﬁnishes after 55 minutes.
Task 1
Start
10 minutes

Task 2
End 1
45 minutes
Task 3
End 2
30 minutes
FIGURE 2.52  The process always takes 55 minutes.
So far, so good, but what happens if we already know that, after having completed task 3, task 2 has become redundant?  This is a frequent situation with parallel task executions related to content. In such cases, we can apply the pattern shown in ﬁgure 2.53.
54	2  The notation in detail
Task 1
Start
10 minutes

Task 2
45 minutes
Task 3
30 minutes

End 1
Task 2 invalid?
No
End 2
Yes
Terminate
FIGURE 2.53  Potentially, the process terminates immediately after task 3 completes.
We use the terminate event to make sure that all available tokens are consumed immedi-ately. That leads to the termination of the process instance, consequently, you can use the terminate event as an end event only. (See ﬁgure 2.54 on the following page.)
...
End
FIGURE 2.54  Applying a terminate event.
2.6.8	Link events
The link event is a special case. It has no signiﬁcance related to content, but it facilitates the diagram-creation process. As shown in ﬁgure 2.55, you can draw two associated links as an alternative to a sequence ﬂow. Here, associated means there is a throwing link event as the exit point, and a catching link event as the entrance point, and the two events are marked as a pair —in our example by the designation A. Sometimes we use color coding to mark the association.
...	Task 1	Task 2	...
A	= A
...	Task 1	Task 2	...
FIGURE 2.55  Associated link events can replace a sequence ﬂow.
Link events can be very useful if:
■      You have to distribute a process diagram across several pages.  Links orient the reader from one page to the next.
■      You draw comprehensive process diagrams with many sequence ﬂows. Links help avoid what otherwise might look like a spaghetti diagram.
2.6 Events	55
Link events can be used as intermediate events only (ﬁgure 2.56).
...	...
Intermediate   Intermediate (throwing)       (catching)
FIGURE 2.56  Applying a link event.
2.6.9	Compensation events
In practice, we apply compensation icons (see ﬁgure 2.57 on the next page) only to trans-actions even though BPMN permits other uses.  (See section 2.8.5 on page 74.)  We exe-cute tasks in our processes that sometimes have to be canceled later under certain circum-stances.
Throwing compensation event acts within the process
...	Task 1
Attached

Intermediate	End (throwing)
Compensate Association	Task 1

Compensation is a special task type
FIGURE 2.57  Applying a compensation event.
Typical examples are:
■      Booking a train or airline ticket
■      Reserving a rental car
■      Charging a credit card
■      Commissioning a service provider
In ﬁgure 2.58, we see this process: On Friday at 1 p.m.  we agree with our partner either to go to the theater or to spend the evening with friends.  In both cases, we have to do something binding, either to reserve the theater tickets or make the arrangements with our friends. When evening arrives, perhaps we no longer feel like going out at all. We then have to cancel the arrangements we made with the theater or our friends before we can collapse in front of the TV in peace.
We can represent the latter part of the model more compactly with a compensation event, as shown in ﬁgure 2.59 on the following page.  If we don’t feel like going out, we have to cancel all our arrangements; we don’t have to check which ones to cancel.
There are special rules for handling compensations:
56	2  The notation in detail
Arrange to meet partner
Friday 1300

Planned action?
Theater
Friends

Reserve tickets
Agree To appointment

Still in the mood?
Yes      Perform action
Friday 1800
What was planned?
No	Theater         Cancel tickets	Watch TV
Friends
Cancel appointment
FIGURE 2.58  A possible process for the weekend.
Arrange to meet partner
Friday 1 p.m.

Planned action?
Theater
Friends

Reserve tickets
Action canceled

Still in the mood?
Yes      Perform action
Friday 6 p.m.
Cancel tickets	No	Watch TV
Action canceled
Arrange appointment
Action canceled
Cancel appointment
FIGURE 2.59  The same process as shown in ﬁgure 2.58 on the previous page, applied to the compensation event.
■      Throwingcompensationsrefertotheirownprocesses, sotheeventiseffectivewithinthe pool. This shows how this event type differs from a throwing message event.
■      Other attached events can take effect only while the activities to which they are attached remainactive. Incontrast,anattachedcompensationtakeseffectonlyiftheprocesstrig-gersacompensationand theactivitytowhichthecompensationisattachedsuccessfully completes.
■      Attached compensation events connect to compensation tasks through associations, and not through sequence ﬂows, which would otherwise be common usage. BPMN thus emphasizesthatcompensationsarebeyondtheregularprocesssequence;executingone is an exception.
■      The obligatory compensation task is a special task type that we explain with other task types in section 2.7 on page 61.
Our modeling etiquette
This example may be too simple to illustrate how much work this construct can save you. If you think of the complex business processes that frequently require compensa-tions, however, you’ll see how much leaner your models can be.  You’ll also be quick
2.6 Events	57
to spot the circumstances that demand compensations.  We use compensation events only occasionally to describe complex processes.
2.6.10	Multiple events
Start

Intermediate   Intermediate (catching)       (throwing)

End
Attached
(interrupting)	...

BPMN 2.0: Attached (non-interrupting)

...
FIGURE 2.60  Application of the multiple event.
We can use the multiple event (ﬁgure 2.60) to summarize several events with a single sym-bol. The semantics are simple:
■      If we model the multiple event as a catching event, only one of the summarized events has to occur to start or continue the process or to cancel the task.
■      If we model a multiple event as a throwing event, it means that all of the summarized events are triggered.
Figure 2.61 applies the multiple event to our pizza scenario. In the example, we try a new pizzaafterhavingseenitonTVorafterafriendrecommendedit. Aftereatingit,wewillrate the pizza on Pizzatest.de and in turn inform our friend if we also recommend this pizza.
Buy pizza
Seen pizza TV ad or a friend has
recommended a new pizza

In the mood for pizza

Eat pizza
Rated pizza on Pizzatest.de
and sent rating to friends
FIGURE 2.61  The multiple event summarizes events.
The model in ﬁgure 2.62 describes the same process, but the events are fully modeled.
Pizza TV ad seen

Buy pizza	Eat pizza
In the mood for pizza

Rated pizza on Pizzatest.de
Friend has recommended a new pizza
FIGURE 2.62  An alternative for ﬁgure 2.61

Sent rating to friends
58	2  The notation in detail
Our modeling etiquette
You have to decide if multiple events serve your purposes. We concede their beneﬁt in rough functional process descriptions, but they cease to be as useful in the more ad-vanced technical-implementation phase. You can’t aﬀord to leave relevant details hiding in the descriptive text.  We don’t ﬁnd the multiple event to be intuitive, nor is it helpful on a functional level.  It may make your diagrams larger to model all events separately, but the resulting diagrams will be both more comprehensive and more comprehensible. The bottom line is that we have never used this symbol in practice, nor have we seen anybody else doing so.
2.6.11	Parallel events
The parallel event (see ﬁgure 2.63 on the next page) supplements the multiple event. While a catching multiple event has XOR semantics —it occurs as soon as one of its contained events occurs —the parallel event uses AND semantics. It doesn’t occur until all of its con-tained events occur. Because the throwing multiple event already implies AND semantics, the speciﬁcation deﬁnes parallel events as catching events only.
Start
Attached (interrupting)

Intermediate (catching)
...

Attached (non-interrupting)

...
...
FIGURE 2.63  Application of the parallel event.
2.6.12	Escalation events
The escalation event (see ﬁgure 2.64) shows communication between parent and subpro-cesses. We discuss it in section 2.8 on page 66 with the help of an example.
...
Attached
(interrupting)	...

Intermediate (throwing)
Attached (non-interrupting)

End
...
FIGURE 2.64  Applying an escalation event.
2.6 Events	59
2.6.13	Cancel events
You can use the cancel event only in the context of the transactions we discuss in sec-tion 2.8.5 on page 74. That section also has examples of applying this event type.
2.6.14	Event-based gateway
We learned about the exclusive data-based (XOR) gateway option in section 2.3.1 on page 28 as a way to use different paths without regard to the data being processed.  In ﬁgure 2.65 on the facing page, we had to choose a recipe (pasta, steak, or salad) ﬁrst, and depending on result of the choose recipe task, the XOR gateway routed us to the cook pasta, or cook steak, or prepare salad task accordingly.
Desired dish?
Hunger noticed

Choose recipe
Data-based exclusive gateway (splitting)

Pasta	Cook pasta
Pasta done
Steak	Cook steak
Steak done
Salad	Prepare salad
Salad done
FIGURE 2.65  An XOR gateway decides routing based on available data.
Users of other process notations recognize this type of branching, but BPMN gives us an-other way to design process paths:  the event-based gateway —event gateway, for short. This gateway does not route based on data, but rather by which event takes place next. To understand the beneﬁt, consider the process shown in ﬁgure 2.66 on the next page: We or-derpizzaandwaitforittobedelivered. Wecaneatonlyafterwereceivethepizza, butwhat if the pizza doesn’t arrive after 60 minutes? We’ll make an anxious phone call, that’s what! We can model this with the event gateway (ﬁgure 2.67). Now, in contrast to the data-based XOR split, the token waits at the event gateway for one of the subsequent events to occur. Once any one event occurs, the token takes the respective path. If other events then take place, they are ignored. This is XOR semantics.
Choose pizza
Hunger noticed

Order pizza
Pizza received

Eat pizza
Hunger satisfied
FIGURE 2.66  According to this model, we may wait forever for pizza to be delivered.
60	2  The notation in detail
Choose pizza	Order pizza
Hunger noticed

Pizza received
60 minutes

Inquire at pizza delivery service

Pizza received

Eat pizza
Hunger satisfied
FIGURE 2.67  After the gateway, the path that receives the event ﬁrst is used.
As you can see in ﬁgure 2.68 on the next page, not all intermediate events combine with the event gateway. You can, however, combine it with the receive task, which we discuss in section 2.7 on page 61.
...	...
Message
...
Timer
...
Condition
...
Signal
...
Multiple
Receive task	...
FIGURE 2.68  Applying an event-based exclusive (XOR) gateway.
As an instantiating gateway, the event gateway can be used to start a process.  You can combine them with other events to trigger a process and, as shown in ﬁgure 2.69 on the next page, they can be merged through XOR merges.
Our modeling etiquette
We ﬁnd it cumbersome and non-intuitive to modeling start events with event gateways. Instead, we use XOR merges without event gateways.
2.6 Events	61
?
Event 1	Task 1	...
Event-based exclusive gateway to start process

?
Event 2	= ?
Event 1
Task 1

...
?
Event 2
FIGURE 2.69  The event gateway can be a starting point, but it must be of the instantiating type.
2.6.15	Event-based parallel gateway
There is a variation on the event gateway: the event-based parallel gateway.  Use of this symbol expresses that all subsequent events have to occur before a process can be started completely. It therefore provides correlation not provided by the simple AND merge.
?
Event 1	Task 1	...
BPMN 2.0: Event-based parallel gateway to start process

?
Event 2	= ?
Event 1	Task 1	...
?
Event 2
FIGURE 2.70  The lower model works, the upper one (strictly speaking) does not.
The lower model shown in ﬁgure 2.70 causes the following behavior:
■      If event 1 occurs, the process instance is started and a token is born.
■      The new token waits at the AND merge.
■      If event 2 occurs, the related process instance already started is identiﬁed. (This is cor-relation.) At event 2, another token is born.
■      The second token also moves to the AND merge, where it merges with the ﬁrst token. Only a single token leaves by the outgoing path.
62	2  The notation in detail
The upper model shows that the allocation to the running process instance would not be carriedout. Instead,twoisolatedinstancesstartinwhichatokenwaitsforeverateachAND merge. This strict correlation semantics of BPMN doesn’t always further the goal of making process models easy to understand!
2.7	Special tasks
2.7.1	Typiﬁcation
So far, we have used only tasks of undeﬁned types, though BPMN provides the opportunity to work with task types just as it does for event types.  Primarily, task types are intended to model processes that are technically executable. Task types are applied infrequently in practice.  We know from experience, however, that task types can be particularly useful when modeling engineering requirements.
Undefined
Manual
User

Receive
Receive (instantiating)
Send

Script
Service
Business rule
FIGURE 2.71  Task type symbols in BPMN.
2.7 Special tasks	63
Types of tasks include: ■      Manual
■      User
■      Service
■      Receive and send ■      Business rule
■      Custom
Manual tasks: Tasks executed by a human being that do not affect the completion of a task assigned by the workﬂow engine. All the tasks from our various pizza processes are manual types.
Other examples:
■      File a document in a folder
■      Clarify an incorrect invoice by phone ■      Talk with customers at the counter
User tasks:  User tasks are executed by people too, but they are assigned by a workﬂow engine, which may, for example, place these tasks in each user’s task list. After the human ﬁnishes a task, the engine expects conﬁrmation, usually including data input or a button click. User tasks are part of the Human Workﬂow Management.
Typical task examples from the world of Human Workﬂow Management are: ■      Check an invoice
■      Approve an application for vacation ■      Process a support request
Service tasks: Service tasks are those done by software. These are program functions ap-plied automatically as a process executes.  BPMN normally assumes that this function is provided as web service, though it can be another implementation.  The service task is a component of process-oriented implementation integration, which explains why it is so similar in concept to Service-Oriented Architecture (SOA).
Typical examples from the world of implementation integration are:
■      The credit rating provided by a rating agency, obtained as XML through HTTP during a credit check
■      Booking an invoice received as EDIFACT through X.400 in SAP R/3
■      The offer of substandard goods by an online auction house, as a web service
Receive and send tasks: Receiving a message can be modeled as a separate task. This task type is an alternative to the catching message event, which is why the symbol for the event deﬁned in BPMN is an empty envelope.  If a receive task is to instantiate a process, that is, the receive task replaces the message start event, this is shown by a small event symbol in the top left corner.  The same principle applies to send tasks.  These tasks are techni-cal, and the workﬂow engine executes them.  Therefore, they mainly are used for calling web services asynchronously through message queues and accepting service requests for asynchronous processing.
Script tasks: Scripts execute directly in the workﬂow engine, so they must be written in a language that the workﬂow engine can interpret.
64	2  The notation in detail
Business rule tasks: This task type is used solely to apply business rules. We discuss this further in section 4.5.6 on page 144 and section 6.2.5 on page 174.
Custom task types: You can deﬁne your own task types with individual symbols to cus-tomize your diagrams and to make them express conditions in your organization better. Your BPMN tool must provide this option, of course. We have yet to encounter anyone who has done this —most people don’t even know it’s possible.  Even so, we can imagine task types for:
■      Phone calls ■      Signatures
■      Approvals or rejections ■      Archiving
2.7.2	Markers
In addition to those various types of tasks, we can mark tasks as loops, multiple instances, or compensations. Markers can be combined with the assigned types.
Loops
A loop task repeats until a deﬁned condition either applies or ceases to apply. Perhaps we suggest various dishes to our dinner guests until everyone agrees.  Then, we can prepare the meal (ﬁgure 2.72).
Until everyone agrees
Suggest dish
Time for dinner

Prepare meal
Meal prepared
FIGURE 2.72  We keep suggesting dishes until everyone agrees with a suggestion.
Do we absolutely need the loop symbol for this process model? No, we could just model a return with gateways, without gateways, or both.  We discussed these methods in sec-tion 2.3 on page 28 and section 2.4 on page 38. It becomes a question of which alternative in ﬁgure 2.73 you prefer, because they all are equally correct syntactically, and they are semantically identical to the process shown in ﬁgure 2.72 on the previous page. Depend-ing on what you choose (the loop symbol, gateways, or conditional ﬂows), apply it in your models in a standardized way.
In the example, we executed the task ﬁrst and checked afterwords to see if we needed it to execute again.  Programmers know the principle as do-while loop.  However, we can also check for a condition before the task instead of afterward. This occurs rarely, but it makes sense if the task may not execute at all.
You can attach the condition on which a loop task executes for the ﬁrst time or, as shown in the example, apply the condition on repeated executions as an annotation to the task. You can store this condition as an attribute in a formal language of your BPMN tool as well. That makes sense if the process is to be executed by a workﬂow engine.
2.7 Special tasks	65
Time for dinner
Alternative 1
Time for dinner
Alternative 2
Time for dinner
Alternative 3
Time for dinner
Alternative 4

Suggest dish
No
Suggest dish
No
Suggest dish
Suggest dish

Does everyone agree?
Yes
Does everyone agree?
Yes
Everyone agrees
Everyone agrees

Prepare meal
Prepare meal
Prepare meal
Prepare meal

Meal prepared
Meal prepared
Meal prepared
Meal prepared
FIGURE 2.73  All four variations represent the same process as in ﬁgure 2.72 on the preceding page.
Multiple task
The individual cycles of a loop task must follow each other. If for example we live in a ﬂat-sharing community and the roommates feel like eating pizza, the choose pizza task must be repeated for each roommate before we can order. You’d sit together and pass a menu around until ﬁnally everyone has made a decision.  There are student apartments where they do handle it like that —more evidence that students have too much time on their hands! It is much more efﬁcient for all roommates to look at the menu at once, and they choose a pizza together. You can model this process using the multiple task (ﬁgure 2.74). A multiple task instantiates repeatedly and can be executed in sequence or in parallel, with the latter being the more interesting case.
Each roommate
Choose pizza
Roommates want to eat pizza

Order pizzas
Pizzas ordered
FIGURE 2.74  Using the multiple task to make tasks dynamically parallel.
66	2  The notation in detail
Do you think the example is absurd?  How does your company check invoices for group orders, such as for ofﬁce supplies? Do you forward the invoice from one employee to the next, so that each person can sign off on the items he or she ordered, before you pay the invoice? If so, you live in a ﬂat-sharing community, and you urgently should consider opti-mizing your process. Automating invoices is still one of the top BPM projects, and the top goal of such projects often is one of parallelization.
Compensation
We explained the beneﬁt of the compensation event in section 2.6.9 on page 54 by means of an example. The compensation task type is applied exclusively in the context of a com-pensation event. Accordingly, it is integrated in the process diagram only by associations, never by sequence ﬂows.
Invite all friends
...	Book trip	...	...	by circular e-	... mail
Manual loop compensation

Manual multiple compensation
Cancel trip
Call until the travel agency is exasperated and gives in

Call everyone to cancel invitation
FIGURE 2.75  The compensation and loop/multiple markers can be combined both with each other and with task types.
The possible combination of the compensation with a loop or multiple instance as shown in ﬁgure 2.75 is worth mentioning.  In this case, both markers are placed in parallel.  As with the other markers, the compensation can be combined with the task types already introduced.  A manual compensation task that repeats until it succeeds or that executes repeatedly and in parallel as far as possible (ﬁgure 2.75), is therefore eminently practical.
2.7.3	Global tasks and call activity
Global tasks differ from the regular tasks in that you can reference them by means of a call activity.  Call activities have a thicker frame than other activities, as the diagram in ﬁgure 2.76 shows.
2.8	Subprocesses
2.8.1	Encapsulate complexity
The examples in this book either deal with simple processes, or they diagram complex pro-cesses superﬁcially so that the models ﬁt on one page. When modeling your process land-scape, you don’t have this luxury. You have to rough out your processes so that you can get
2.8 Subprocesses	67
Falko
Desired components?

Global task
Desired dish?
Choose recipe
Hunger noticed
Christian
Flat-sharing community

Something real

Pasta	Cook pasta	Eat meal
Hunger satisfied
Call activity
Steak	Cook steak
Salad	Prepare salad
Robert

Eat meal
Eat meal

Hunger satisfied
Call activity
Hunger satisfied
FIGURE 2.76  The process from ﬁgure 2.27 on page 43 as it had to be represented in BPMN correctly.
the general ideas in place and recognize correlations. Then you have to develop a detailed description, sothatyoucananalyzeexactlywheretheweakpointsareorhowyou’llhaveto execute the process in practice. The possible top-down reﬁnements or bottom-up aggre-gations mark the difference between true process models and banal ﬂow charts, between sophisticated BPM software products and mere drawing programs.
BPMN provides us with the subprocess to help with the expanding/collapsing view. A sub-process describes a detailed sequence, but it takes no more space in the diagram of the parent process than does a task. Both tasks and subprocesses are part of the activities class and are therefore represented as rectangles with rounded corners. The only difference is the plus sign, indicating a stored detailed sequence for the subprocess. (See ﬁgure 2.77 on the next page.)
Task	Subprocess
Parent process
Start	End
FIGURE 2.77  A task and a subprocess.
Whatgoodisthattous? ThatdependsmostonhowyourBPMNtoolsupportsthefollowing options for connecting subprocesses with their parent processes:
■      Representation in a separate process diagram: The subprocess symbol links to a sep-arate diagram. If your BPMN tool displays the process model in a web browser, for in-stance, clickingonthesymbolwouldopenanewpagetodisplaythedetaildiagram. (See ﬁgure 2.78 on the facing page.)
■      Expandingintheprocessdiagramoftheparentprocess: The activity with the plus sign is called a collapsed subprocess.  The plus sign suggests that you could click on it and make the subprocess expand. The BPMN speciﬁcation provides for this option, though not all tool suppliers implement it.  Figure 2.79 on the next page shows how the sub-process was directly expanded in the diagram of the parent process. A tool supporting
68	2  The notation in detail
KWWSZZZP\SURFHVVPRGHOFRPSDUHQWSURFHVVKWPO
Task	Subprocess
Parent process
Start	End
CLICK!
KWWSZZZP\SURFHVVPRGHOFRPVXESURFHVVKWPO
Task	Task
Start	End
FIGURE 2.78  The details of the subprocess are shown in a separate diagram.
this function enables you to expand and collapse the subprocess directly in the diagram, respectively, to show or hide details.
KWWSZZZP\SURFHVVPRGHOFRPSDUHQWSURFHVVKWPO
Subprocess
Parent process
Task
Task	Task
Start	End
Start	End
The minus sign is not part of the standard but included in many tools.
FIGURE 2.79  The subprocess expands directly in the diagram of the parent process.
Direct expansion may seem appealing, but often it is not useful in practice. Expanding the subprocess requires that all the adjacent symbols in the diagram shift to make room. This can result in sluggish performance with a complex diagram, and it can be visually ...nasty. The most important thing is that your tool provides for linking and that you can usefully
2.8 Subprocesses	69
navigate through the diagrams.  In other words, it supports the ﬁrst option above.  Yes, it can be helpful to have your subprocess modeled and expandable directly from the parent process.  That means process segments remain localized, and you can attach events too (see section 2.8.3 on page 71). This is, however, the less important option.
The sequence ﬂow of the parent process ends in both cases at the left edge of the subpro-cess. The next sequence ﬂow starts at the right edge. This means that sequence ﬂows are not allowed to exceed the boundaries of the subprocess, which not every beginner knows, and which becomes a problem when a subprocess expands.
Visualize a token that behaves as follows:
■      The parent process starts, and a token is born.
■      The token runs through the task and arrives at the subprocess, which causes the parent process to create an instance of the subprocess.
■      Withinthesubprocess, aseparatetokenisbornwhichrunsthroughthesubprocessfrom the start to the end event, but the token of the parent process waits until the subprocess completes.
■      When the subprocess token arrives at the end event, it is consumed, which completes the subprocess. Now the token of the parent process moves to its own end event.
The encapsulation in subprocesses that we’re describing isn’t restricted to two levels. You could just as easily have a parent process as a subprocess, or you could model further sub-processes on the level of a deﬁned subprocess. How many levels you use and the level of detail you apply to model them is up to you. BPMN doesn’t specify this, and there can be no cross-company or cross-scenario cookbook to deﬁne levels. Participants in our BPMN workshops don’t like this, but there’s no point in hiding the fact nor attempting to explain it away. In the following chapters, we work often with subprocesses in explaining our best practices, but the truth is the number of reﬁnement levels and their respective levels of detail is always situational. It depends on the organization, the roles of the project partici-pants, and the goals for the process you’re modeling.
You may remember that we explained in section 2.2 on page 27 that you can work without start and end events.  Without them, you can make the parallelization shown in the top part of ﬁgure 2.80 on the facing page somewhat more compact. In this example, start and end events were used in the parent process, but not in the expanded subprocess.  That’s completely legitimate, but we don’t do this ourselves for two reasons:
1.  It increases the risk of confusing inexperienced consumers of the model.
2.  Itiseasytoconfusetherepresentationwiththeadhocsubprocesstobeintroducedlater in the book. We use that a lot.
The example shows that subprocesses in BPMN practice are used not only to reﬁne pro-cesses in terms of content; they are also a "technical stylistic device" for creating diagrams. The following sections illustrate this.
2.8.2	Modularization and reuse
In version 1.2, BPMN differentiated between embedded and reusable subprocesses by as-signing an attribute to a subprocess. In version 2.0, BPMN maintains this differentiation in
70	2  The notation in detail
Task 2
Task 1	Task 4
Start	End
Task 3
=
Task 2
Task 1	Task 4
Start	Task 3	End
FIGURE 2.80  A subprocess can be used to replace the AND gateways.
principle, but it is deﬁned differently. A subprocess now is embedded intrinsically, and it can be reused only by deﬁning it as a global subprocess, and then referencing it by means of a call activity. We therefore refer to embedded subprocesses and global subprocesses in the following.
An embedded subprocess can occur only within a parent process to which it belongs. An embeddedsubprocesscannotcontainpoolsandlanes, butitcanbeplacedwithinthepool or the lane of the parent process. Furthermore, an embedded subprocess may have only a none start event; start events such as messages or timers are not permitted. An embedded subprocess has essentially nothing more than a kind of delimited scope within the parent process, which may serve two goals:
1.  To encapsulate complexity (as already described)
2.  Toformulatea"collectivestatement"onapartoftheparentprocessbyattachingevents or placing markers. We deal with this option later.
On the other hand, global subprocesses may occur in completely different parent pro-cesses.  There are a great many subprocesses that, in practice, are used over and over.  A good example is the procurement of an item because a customer ordered it or you need to re-stock supply. Another example is invoicing because you’ve delivered or repaired an item as shown in ﬁgure 2.81. In the example, notice that call activities differ from regular activities by their considerably thicker borders.
The connection a global subprocesses has to its parent is considerably less close, and they can have their own pools and lanes.  You can think of the participant responsible for a subprocess as a service provider for various parent processes. It is a like a shared service center.
The loose connection also affects data transfer between the parent and the subprocess. BPMN assumes that embedded subprocesses can read all the data of the parent process directly, but an explicit assignment is required for global subprocesses to be able to read it. Thatmayseemlikemerelyatechnicalaspectatﬁrst, onethatmodelersandtheconsumers oftheirmodelscaretoknowaboutbutwon’twishtobotherwith. Aftersomeconsideration,
2.8 Subprocesses	71
Financial processing
Repair
Order
Order processing
received

Check availability

Item available?
Yes	Dispatch item

Financial processing
End
No

Item procurement

This arrow is not a BPMN symbol, it only illustrates the
example.
Below minimum stock level of
Stock maintenance
item

Item procurement

Item
procured

Carry out repair
Repair order
received

Financial processing
End
Place order	...
Item procurement
Start

Issue invoice
Start

...
Payment received
...
Date of payment
exceeded
FIGURE 2.81  Examples of reusing subprocesses.
however, you may see the impact this difference makes on the organization. Consider this: When your accounting department wants to issue an invoice for a repair, it always needs:
■      A billing address
■      The date of performance delivery
■      A description of performance
■      An amount to invoice
■      An expected date of payment
The owners of order processing, not just the repair department, must provide this data. Accounting will want the data in a standard format, won’t it? This corresponds well to what BPMN calls required data mapping between parent processes and global subprocesses. (Do you notice how often these weird techie issues correspond to the organizational needs and expectations of a process?)  BPMN simply forces us to formalize many matters that seem self-evident, or that remained unconscious or forgotten in the process design. For-malizationisourbestchanceofkeepingupinafast-changingenvironmentwithevermore complex processes.
2.8.3	Attached events
We already learned about intermediate events that can be attached to tasks.  The same events can be attached to subprocesses as well, which opens up a wide range of opportu-nity in process modeling.  As shown in ﬁgure 2.82, we can represent how a spontaneous dinner invitation leads to canceling our cooking process. In the process shown, however, we could ignore the invitation if our meal had already been prepared and we already ate it.
72	2  The notation in detail
Choose recipe	Prepare meal	Eat meal
Hunger noticed

Hunger
satisfied
Received invitation to
dinner

Go out for dinner
FIGURE 2.82  The catching event cancels the entire subprocess.
Where message, timer, and conditional events are involved, the parent process always aborts the subprocess when reacting to external circumstances. With error, cancellation, and escalation events, however, the subprocess reports these events to the parent process. This isn’t as abstract as it may sound.
In the bottom right of ﬁgure 2.83 on the next page, the item procurement task can fail be-cause the item is no longer available. Because item procurement is a global subprocess, it triggers an error event to tell the parent process that something went wrong. In business terms, this may mean that the customer who wanted to buy the item tells a salesperson that his or her order failed because the item is out of stock. A clerk then orders more of the item to replenish inventory.
Order
Order processing
received

Check availability

Item available?
Yes	Dispatch item

Financial processing
End
No

Item procurement
Not
available
Inform customer

Delete item from catalog
End
Available?
Item procurement
Below minimum stock level of
Stock maintenance
item

Item procurement
Not
available

Item
procured

Place order
Start

Yes     Expect delivery	...
No
Not
available
Delete item from catalog
Item deleted
FIGURE 2.83  The subprocess reports an error to its parent.
It is interesting that parent processes can handle the error message differently. While the disappointed customer must be informed within the scope of the order process, it is sufﬁ-cient for the stock maintenance process to delete the item from the catalog. The respective parent processes decide what circumstances require canceling the subprocess and what
2.8 Subprocesses	73
Order processing
happens next.  That’s a principle that you can use to build ﬂexible and modular process landscapes.
The signal event serves two functions. A parent process can react to a signal received from the outside while it executes a subprocess —this is much like a message event.  But we also use the signal event to let the subprocess communicate things other than errors to the parent process. Primarily, this is because we can’t model this type of communication with message events. BPMN assumes that we always send messages to other participants who are outside of our pool boundaries; the communication between parent and subprocess doesn’t ﬁt that mold. We don’t use signal events for directed communication, but rather to broadcast information akin to advertisements on the radio.
A better alternative is the escalation event (see ﬁgure 2.84).
Order received

Check availability

Item available?
Yes	Dispatch item

Financial processing
End
No

Item procurement
Not available

Late delivery

Inform customer
End
Inform customer

Delete item from catalog
End
Place order
Item procurement
Start

Available?
in 2 days
in >2 days
No
Late delivery

Expect delivery	...
Not available
FIGURE 2.84  The escalation event informs the parent process that something needs to be done.
The subprocess can use an escalation event to report directly to the parent process, and the message won’t be regarded as an error message. Also, the parent process can receive and process messages from escalation events without canceling the subprocess because non-interrupting intermediate events can be attached .
2.8.4	Markers
You can apply the loop, multiple instance, and compensation task markers that we de-scribed in section 2.7.2 on page 63 in a fashion similar to the way you apply subprocesses. You can use them to model even complex loops as shown in ﬁgure 2.85. The top and bot-tom parts of this diagram are equivalent.
74	2  The notation in detail
Task 1	Yes
Start
Task 2
Start
No

Task 3	Task 5
End 1	End Condition 1
met?
Task 4
End 2
Until  condition 2 is met
=
Task 1	Task 2
Start

Yes	Task 3
Condition 1 met?
No	Task 4

Condition 2 met?
Yes	Task 5
End
No
FIGURE 2.85  Subprocesses can be deﬁned as loops.
One marker available only for subprocesses is called ad hoc. Recognize it by the tilde char-acter as shown in (ﬁgure 2.86 on the next page).  Use the ad hoc subprocess to mark a segment in which the contained activities (tasks or subprocesses) can be:
■      Executed in any order,
■      Executed several times, or
■      Skipped.
Travel preparation
2 days before traveling date

Turn off heaters
Leave keys with the neighbors

Write out-of-office email
...
Pack suitcases
~
FIGURE 2.86  Travel preparation may include, but does not have to include, these tasks.
Any party who executes this subprocess decides what to do and when to do it. You could say that the barely structured nature of what happens inside this subprocess reduces the whole idea of process modeling to an absurdity because what happens and when are the things we most want to control. On the other hand, this is the reality of many processes, and you can’t model them without representing their free-form character. Frequent exam-ples are when a process relies largely on implicit knowledge or creativity, or when different
2.8 Subprocesses	75
employees carry out a process differently. You can use the ad hoc subprocess to ﬂag what may be an undesirable actual state. Doing so could be a step on the path to a more stan-dardized procedure.
BPMN speciﬁes which symbols must, which may, and which are forbidden to occur within an ad hoc subprocess. They are:
■      Must: Activities
■      May: Data objects, sequence ﬂows, associations, groups, message ﬂows, gateways, and intermediate events
■      Forbidden: Start and end events, symbols for conversations and choreographies (dis-cussed later)
By means of the speciﬁcation, mixed forms —so-called weakly structured processes —can be modeled as shown in ﬁgure 2.87.
Contribute Specifications

Every author
Results of research
Research topics

Write text
Find authors
Reference book to be written

Think about content

Ideas
Diagrams

Text [draft]

Text [finished]

Create manuscript

Manuscript finished
Create diagrams

Include
diagrams in the	Polish article text
~
FIGURE 2.87  The processes of the individual authors are not subject to a predeﬁned structure.
2.8.5	Transactions
Many processes work in an all-or-nothing fashion: either all steps must be carried out suc-cessfully or nothing must be done at all.  The compensation event, which we discussed in section 2.6.9 on page 54, can undo tasks already completed without having to model the undoing in detail. The transaction is a special subprocess, which also helps us in such cases. We explain this in ﬁgure 2.88 using the following example:
Suppose you want to visit relatives overseas.  After deciding to make the trip, you start preparing for it.  First, you make a ﬁrm plan with your relatives regarding the date and length of your visit.  Second, you book a discount ﬂight, and you reserve a hotel room (to avoid being an excessive burden on your hosts, despite their protests to the contrary). Third, you schedule vacation time with your boss. If all goes well, you can start the trip.
What happens, however, if the hotel you wanted is booked and you can’t ﬁnd another? What if the boss denies your vacation request? You have to cancel the travel preparation transaction. The cancel event exists for this purpose. You can only use it within transac-tions.  If you cancel a transaction, it triggers a compensation of all tasks to which corre-sponding compensation tasks were assigned.  You therefore sadly inform your hosts that
76	2  The notation in detail
Prepare trip
Plan trip
Start

Agree date for visit
Start

Book cheap flight

Book hotel	Apply for leave
End

Start trip
End
Hotel
fully booked
Cancel visit
Book alternative hotel

Application rejected
Cancelation
All hotels fully booked
Cancel hotel
Cancelation
Canceled
FIGURE 2.88  The double border marks a transaction, in this case the expanded subprocess travel preparation.
you won’t be able to come at the agreed date, and you cancel the hotel reservation, if any. Becauseyoubookedadiscountﬂight, theairlinewillnotrefundtheticketprice. (Youcurse them silently.) After compensating for all the tasks already executed, you leave the transac-tion through the attached cancel event, and you start over with preparations for a different travel plan.
This process is ﬂawed.  Because of the cursed airline’s poor refund policy, it would make more sense to book the ﬂight only after the other details are conﬁrmed. Book it at the end of, oroutsideof, thetransactiontominimizerisk. That’sthepoint: transactionsareforcrit-ical processes in which even the smallest risk has to be taken into account. If you arrange your vacation time with the boss in advance, the risk of having your request rejected seems small, but it hasn’t been reduced to zero, has it? An important bit of work may come in, and your non-binding agreement with the boss may evaporate. Transactions provide security for scenarios like this.
2.8.6	Event subprocesses
We locate an event subprocess within another process or subprocess. Recognize them by their dotted-line frames.
A single start event triggers an event subprocess, and this can only happen while the en-closing process or subprocess remains active.  For event subprocesses, there can be in-terrupting (continuous line) and non-interrupting (dashed line) events.  This is the same differentiation made as for attached intermediate events. Depending on the type of start event, theeventsubprocesswill cancel theenclosingsubprocess, oritwillexecutesimulta-neously. You can trigger non-interrupting event subprocesses as often as you wish, as long as the enclosing subprocess remains active.
Okay, that’s pretty abstract, but we can demonstrate how an event subprocess works with an example. (See ﬁgure 2.89.)
We invited a couple of friends for dinner. This starts the dinner preparation subprocess of choosing a recipe and then preparing the meal.  While we are doing that, the telephone rings. Another guest invites himself to dinner. Spontaneous as we are, we just increase the
2.8 Subprocesses	77
Dinner preparation
Invite friends for dinner
Start

Choose recipe
Start

Prepare meal
End

Eat meal
End
Provide for another guest
Another guest has invited himself

Take another guest into account
End
Interrupting event subprocess

Procure food
Preparation failed

Order food
End

Non-interrupting event subprocess
FIGURE 2.89  Event subprocess examples.
amountoffood or setanotherplace at the table without interruptingthe meal preparation. If an accident happens during preparation, however, the error immediately triggers the interrupting event subprocess for remedial action. We order food for delivery. When this event subprocess completes, we exit the enclosing subprocess through the regular exit and attend to eating the meal.
You can see in ﬁgure 2.90 on the facing page how event subprocesses are represented in collapsed state: The frame is a dotted line, and we have again used the plus sign to repre-sent collapsed subprocesses. In the top left corner, we also have the start event triggering the subprocess.
Dinner preparation
Invite friends for dinner
Start

Choose recipe
Start
Provide for guest

Prepare meal
End
Procure food

Eat meal
End
FIGURE 2.90  Collapsed event subprocesses.
78	2  The notation in detail
The event types that can trigger non-interrupting event subprocesses are:
■      Message
■      Timer
■      Escalation
■      Conditional
■      Signal
■      Multiple
■      Multiple parallel
There are two more types for the interrupting event subprocesses:
■      Error
■      Compensation
Areyouwonderingifyoucouldmodeltheexamplewithouteventsubprocessesandinstead just attach events? Yes, you could. We did it that way in ﬁgure 2.91. In terms of sequence, the process works identically to the one shown in ﬁgure 2.89 on the preceding page. There is, however, a small but important difference: In the second model, adding an additional guest and ordering the alternative meal do not take place within the dinner preparation subprocess, but within the parent process instead.  This has the following consequences (which apply particularly to global subprocesses):
■      If responsibility for the subprocess lies with another parent process, two different roles take care of executing the subprocess and handling the related events.  If the handling takes place within the subprocess, the same role has to take care of it.
■      If the subprocess is global and thus reusable, each parent process must specify how it reacts to both events. On the other hand, if handling takes places within the subprocess, it is reused as well —for good or ill.
■      Global subprocesses cannot access directly the data of the top-level process (or their parent processes); some data mapping is required. Data mapping is not required with an event subprocess.
Dinner preparation
Invite friends for dinner
Start

Choose recipe
Start

Prepare meal
End

Eat meal
End
Another guest has invited himself

Preparation failed
Order food
Provide for another guest
End
FIGURE 2.91  Compare this process to the one shown in ﬁgure 2.89 on the preceding page.
2.9 Pools and message ﬂows	79
2.9	Pools and message ﬂows
2.9.1	The conductor and the orchestra
In section 2.5 on page 40, we described using lanes to assign responsibility for tasks or subprocesses to different task workers. Lanes always exist in a pool, and the pool bound-aries represent process boundaries from start to end.  To BPMN, the pool represents a higher-ranking instance compared to its lanes.  The pool assumes process control —in other words, it assigns the tasks. It behaves like the conductor of an orchestra, and so this type of process is called orchestration.
In ﬁgure 2.92, the conductor arranges for Falko to process task 2 as soon as Robert com-pletes task 1. The conductor has the highest-level control of the process, and each instru-ment in the orchestra plays the tune the conductor decides upon.
Task 1
Robert
Start
Task 2
Falko
Process conductor
Task 3
Christian
Task 4
Stefan
End
FIGURE 2.92  Tasks and task workers.
Do you think this is unrealistic? Many experienced process modelers have problems with this way of thinking.  They would prefer to model a process sequence like that shown in ﬁgure 2.93 on the facing page on the assumption that no almighty conductor exists in their company, and that individual task workers have to coordinate and cooperate on their own.
To coordinate cooperation with BPMN requires explicit modeling.  You assign each task worker a separate pool, and the process passes from one to the next as a message ﬂow (as shown in ﬁgure 2.94). In principle, this creates four independent conductors. These have control over their respective mini-processes, but they can’t do anything other than to send messages that trigger their successor processes.
That seems complicated —and you don’t have to choose the coordinated cooperation method for practical modeling. It reveals a basic principle, however, that you must under-stand. Even though BPMN lanes look very much like those of other process notations, they represent an entirely different way of thinking, which we attribute to BPMN’s origin in the world of process automation. In that world, the workﬂow engine controls all tasks in the process, even though different task workers may execute them.  So the workﬂow engine equates to the mysterious, almighty process conductor.
Have you heard of service orchestration in connection with Service Oriented Architecture (SOA)? That’s almost exactly the task of a workﬂow engine, except that these services are not only fully automated web services; they also can be tasks executed by human process
80	2  The notation in detail
Robert
Task 1
Task 2
Falko
Task 3
Christian

Forward to Falko
Forward to Christian
Forward to Stefan
Task 4
Stefan
FIGURE 2.93  The task workers provide for the respective successor to start the processing.
Task 1
Robert

Separate pool
Foward to Falko
Message flow
Falko
Task 2
Task 3
Christian

Forward to Christian
Forward to Stefan
Task 4
Stefan
FIGURE 2.94  Each task worker operates in a separate pool.
participantsasdirectedbytheworkﬂowengine. Whatdoesthatsignify, however, forpurely functional process modeling, in which you also describe processes not controlled by such a workﬂow engine? There’s no general answer to that question.
You can eliminate pools and work just with lanes, modeling the message exchange as nor-mal tasks as shown in ﬁgure 2.93 on the preceding page. That’s traditional, and it’s a prag-matic solution during, say, a transitional period that allows your co-workers to adapt. In the medium and long terms, however, avoiding pools denies you a powerful device for in-creasing the signiﬁcance of process models.
2.9 Pools and message ﬂows	81
Robert
The next chapter explains the most important rules to be observed when working with pools and message ﬂows. Meanwhile, we show the usefulness of this new thinking by ex-ample. One thing to remember is that if you strive to harmonize your functional and ex-ecutable process models to achieve a better alignment of business and IT, you inevitably face this type of process modeling whether you use BPMN or not.
2.9.2	Rules for application
When working with pools and message ﬂows, you may model the following things (see ﬁgure 2.95):
■      Catching message events, which message ﬂows enter ■      Throwing message ﬂows, which message ﬂows exit
■      Tasks, which message ﬂows enter or exit
■      (Expanded) subprocesses, which message ﬂows enter or exit
...	...	...	...	...	...	...	...	...
FIGURE 2.95  Acceptable constructs for working with pools and message ﬂows.
ThefollowingconstructsviolatetheBPMNspeciﬁcationandthereforemustnot beapplied (see ﬁgure 2.96 on the facing page):
■      Sequence ﬂows exceeding pool boundaries
■      Message ﬂows not exceeding pool boundaries
■      Events with message ﬂows that are not of the message type ■      Events, which message ﬂows enter and exit
■      Message ﬂows with arrows at the beginnings and the ends ■      Gateways with message ﬂows
2.9.3	The art of collaboration
We examined the process represented in ﬁgure 2.97 in connection with the event-based gateway.
Now consider the broader picture, and think about how this process happens from the point of view of the pizza delivery service. Presumably, it looks like ﬁgure 2.98: As soon as we receive an order, we bake the pizza. Our delivery person takes it to the customer and collects the money, whereby the process completes successfully.
82	2  The notation in detail
Robert
Delivery service
...	...	...	...	...	...
FIGURE 2.96  Forbidden constructs for working with pools and message ﬂows.
Choose pizza	Order pizza
Hunger noticed

Pizza received
60 minutes

Inquire at pizza delivery service

Pizza received

Eat pizza
Hunger satisfied
FIGURE 2.97  After the event-based gateway, the path at which the event arrives ﬁrst is used.
Bake pizza
Pizza baker
Pizza Delivery service
Order received
Deliver pizza	Collect money
Delivery person
Order delivered
FIGURE 2.98  The sales process of the pizza delivery service.
Choose pizza	Order pizza
Hunger
Customer
noticed
Pizza process

Pizza received
60 minutes

Inquire at pizza delivery service

Pizza
received

Eat pizza
Hunger
satisfied
Bake pizza
Pizza baker
Deliver pizza	Collect money
Delivery boy
FIGURE 2.99  An overview of the pizza process with one pool and several lanes —a poor solution.
We want to link the two processes, that is, to examine the interaction of customer and delivery service from a neutral perspective. We can try to model this interaction by means
2.9 Pools and message ﬂows	83
of a pool and lanes as in ﬁgure 2.99, but it doesn’t work well: There are tasks and events that reference interaction within the pool —waiting for the delivery, for instance, or collecting the money. Other tasks are carried out by roles oblivious to their partners, such as baking the pizza and eating the pizza.  It is impossible to differentiate the two visually.  Strictly speaking, the diagram is not semantically correct because message events always refer to messages received by the process from outside, and that’s not the case here.
If we go with pools, the whole process looks like ﬁgure 2.100. Both processes in the com-bined representation would look just as they did before, but now they connect through message ﬂows. BPMN calls this form of visualization a collaboration diagram. It shows two independent processes collaborating.
Choose pizza	Order pizza
Pizza Customer
Hunger
noticed

Pizza received
60 minutes

Ask for pizza at delivery service

Pizza
received

Eat pizza
Hunger
satisfied
Bake pizza
Pizza Delivery service
Pizza baker
Order received
Deliver pizza	Collect money	End
Delivery person
FIGURE 2.100  An overview of the pizza process using two pools.
In two cases, the message ﬂows do not end in an activity or event, but at the participants’ respective pool boundaries. The ﬁrst one comes from the inquire at delivery service task; thesecondoneconnectstothe collectmoney task. Therationalebehindtheﬁrstoneisthat our inquiry does not inﬂuence the sequence ﬂow of the deliverer. The pizza service may provide informationor speed up its order processing in anticipation of a new order, but the baking, delivering, and collecting of money doesn’t change just because an inquiry came in. As for the collect money messages, there’s a ﬂaw in the model of the customer process: we have to pay for the pizza before we eat it, and that task is still missing. We added it to ﬁgure 2.101, and now we can connect the message ﬂows directly to the pay for pizza task.
2.9.4	Collapse pools
It often happens that we don’t know the processes of all parties in detail. We may know the processesofourowncompany, forexample, butnotthoseofapartnercompany. Aslongas our partner and we adhere to agreed-upon interfaces, such as receiving or sending certain messages, things can still operate smoothly. As customers of the pizza delivery service, we expect the deliverer to:
■      Accept pizza orders,
84	2  The notation in detail
Choose pizza	Order pizza
Pizza Customer
Hunger noticed

Pizza received
60 minutes

Inquire at pizza delivery service

Pay for pizza
Pizza received

Eat pizza
Hunger satisfied
Bake pizza
Pizza Delivery service
Pizza baker
Order received
Deliver pizza	Collect money	End
Delivery person
FIGURE 2.101  In the customer’s process, the pay for pizza task has been added.
■      Deliver ordered pizzas and collect the money, and
■      Be available for inquiries.
As customers, we have little interest in the deliverer’s internal process.  Maybe he bakes and then delivers the pizza; maybe when he’s out of supplies, he gets another pizza ser-vice to bake the pizza and deliver it. That’s his problem —we simply expect to receive our pizza.  In modeling such cases, we can hide the deliverer’s process and collapse the pool (see ﬁgure 2.102 on the following page).
Choose pizza	Order pizza
Pizza Customer
Hunger noticed

Pizza received
60 minutes

Inquire at pizza delivery service

Pay for pizza
Pizza received

Eat pizza
Hunger satisfied
Expanded pool	Collapsed pool
Delivery service
FIGURE 2.102  The deliverer’s pool is collapsed, which hides the process details.
Wecouldgoastepfurtherandcollapsethecustomer’spooltoo(seeﬁgure2.103onthenext page). Now we see only the messages to be exchanged, assuming that we label the arrows to give us the general idea.  The downside is that we can’t recognize interdependencies any more.  We can’t see if the inquiry always goes out, or only takes place under certain conditions —the actual case. BPMN ﬁxed this problem in version 2.0 by introducing a new type of diagram, the so-called choreography diagram that we describe in section 2.13 on page 94.
2.9 Pools and message ﬂows	85
Pizza order - Customer
Order	Inquiry	Delivery   Collecting  Payment
Pizza delivery ± Delivery service
FIGURE 2.103  Both pools are collapsed, and only the message ﬂows are marked.
2.9.5	Multiple instance pools
We showed in section 2.7.2 on page 63 and section 2.8.4 on page 73 that tasks or subpro-cesses can be marked as multiple, which means that these elements instantiate several times during execution. BPMN applies this principle to pools too.
Because a pool always represents a participant, we name the construct multiple partici-pants. Figure 2.104 on the next page shows how to apply it. We deﬁned three participants: customer, agent, and supplier.  If the agent’s process is instantiated, it does so because a customer places an order.  This causes the agent to execute the invite offer task repeat-edly. The supplier pool now has the same marker as the task that executed repeatedly. At a glance, this shows that it is not always the same supplier, but that several suppliers are involved. After obtaining all the offers, one is selected and forwarded to the customer.
The multiple instance participant always helps us when we want to show the interaction of processes in collaboration diagrams.  Some processes may instantiate only once while others instantiate several times within the scope of cooperation.
Customer
Agent
Invite offer
Order received

Select offer	Forward offer
Offer sent
Supplier
FIGURE 2.104  BPMN allows multiple participants.

Multiple participants
86	2  The notation in detail
Pool 2
2.10	Data
In the description of a process, BPMN focuses on the sequence ﬂow: the sequence of tasks, gateways, and events.  All other potentially relevant aspects to the process execution are treated as less important. The same applies to information or documents used in, or gen-erated by, the process.  You can account for these aspects in your diagrams by modeling so-called data objects, which represent all kinds of information regardless of their phys-ical nature.  They can include paper documents, abstract information, or electronic data records.
Data objects are coupled to ﬂow objects and sequence ﬂows by means of (data) associ-ations.  In addition to their designation, they can be assigned a speciﬁc status, which is marked by square brackets in BPMN. Typical statuses for data objects are:
■      Generated
■      To be checked ■      Checked
■      To be revised ■      Revised
■      Rejected ■      Approved
Data 2.1 Data object	[status B]

Data 2.1 [status C]
Data 2.1 received
Pool 1
...	Task 1.1	Task 1.2	Task 1.3	...
Data 2.1 Association	[status A]
Data 2.2

Data 2.1 [status B]
...	Task 2.1	Task 2.2	Task 2.3	...
FIGURE 2.105  Examples of working with data objects.
The abstract example in ﬁgure 2.105 on the following page shows the following interaction of pools 1 and 2:  In task 2.1, pool 2 generates the data object 2.1 with the initial status A, which we visualize by means of the directed association from task toward data object. Task 2.3 needs this data object as input, which is why we have drawn another directed association there. Furthermore, task 2.3 consumes the output of task 2.2.
Because these tasks directly follow one another, we can omit the directed associations, and we can connect data object 2.2 directly to the sequence ﬂow. This is just a visual shortcut
2.10 Data	87
of the input/output relationship. Task 2.3, in turn, transforms data object 2.1 from status A to status B, and it sends it through a message ﬂow directly to pool 1. Pool 1 waits for this message and then forwards the received data 2.1 to task 1.3, where it is transformed from status B to status C.
You have to pay attention when using message ﬂows and directed associations in the same diagram, because they look similar. The most important distinctive features are:
■      Message ﬂows are dashed, the beginning of the line is a small circle, and the arrow is a closed triangle.
■      Directed associations are dotted, the beginning of the line is unmarked, and the arrow has an open base.
BPMN deﬁnes data as an additional category aside from ﬂow objects and artifacts.  This relevance is based primarily on the desire to execute BPMN process models directly, and this requires explicit observance of data. For collaboration diagrams, there are a couple of other interesting symbols besides the message object. We have applied them to the deliv-erer’s pizza process in ﬁgure 2.106 on the next page.
Collection input data object
Order position (collection)
Pizza baker
Order received
Pizza Delivery service

Bake ordered pizzas

Output data object
Deliver pizzas	Collect money	Sales
Accountant
Delivery person
Data store
Journal

Book sales
Order delivered
FIGURE 2.106  Examples how to work with data symbols.
Any new pizza order that the deliverer receives serves as input for the process. Recognize this as the arrow in the top left of the diagram. The order may include one or more pizzas (as expressed by the usual symbol for multiple instances), and the bake pizza task must execute a corresponding number of times. The number of instances also corresponds to the number of items in the collection input data object. The collect money task requires the object for the delivery person to ask for the correct amount. The accountant enters the sale in a journal.  This sale is the output of the process, recognizable by the black arrow.  The journal is a data store that exists, unlike the data objects, regardless of the speciﬁc process instance. The journal remains available long after the process instance has ended. If the pizza company was more up to date, its accountant could use software or a database.
88	2  The notation in detail
Falko
2.11	Artifacts
2.11.1	Annotations and groups
Annotation	*UDQQ\¶VFRRNERRNRU Chefkoch.de	Desired
components?
Christian

In the kitchen	Group	In the dining room
Desired dish?
Choose recipe
Hunger noticed
Flat-sharing community

Something real

Pasta	Cook pasta	Eat meal
Hunger satisfied
Steak
Salad
Robert
FIGURE 2.107  Annotations and groups.

Cook steak
Prepare salad

Eat meal
Eat meal

Hunger satisfied
Hunger satisfied
We use annotations to supplement our diagrams.  Annotations can contain almost any-thing you ﬁnd useful, and you can connect them to other elements with associations. Usu-ally, we use annotations to provide insight on the execution of tasks (see ﬁgure 2.107). (In ﬁgure 2.7 on page 31, we used annotations to record the average processing times; in ﬁg-ure 2.72 on page 63, we used them to explain what condition cancels a looping task.)
In ﬁgure 2.107, we noted that the food is to be prepared in the kitchen but eaten in the din-ing room. Because this information refers to several elements in the diagram at the same time, we can group them. Like all artifacts, groups do not inﬂuence execution semantics, so don’t confuse them with things like subprocesses.  You can apply groups any way you like —even across pool boundaries. Groups can be extremely useful for marking off parts of your models to which only certain conventions apply. We will return to this possibility in subsequent chapters.
2.11.2	Custom artifacts
BPMN allows you to introduce symbols that suit your own modeling conventions and par-ticular information needs.  In ﬁgure 2.108, we expanded the process of delivering pizzas with a bicycle and a computer.  These appliances help us execute tasks.  Apply the same rules to custom symbols as to all artifacts: connect them with associations to any ﬂow ob-ject; place them in any position in the diagram.
Tooling
You can use custom artifacts only if your BPMN tool supports them.   Relatively few products do, unfortunately.
2.12 Comparison with other notations	89
Bake pizza
Pizza baker
Order received
Pizza Delivery service
Deliver pizzas	Collect money
Accountant
Delivery person
Custom artifact
Custom artifact
FIGURE 2.108  Applying custom artifacts.

Book sale
Order delivered
2.12	Comparison with other notations
Many people interested in BPMN already know other process modeling notations.  They wonder if switching is worthwhile and what they have to watch out for. In this section, we compare four other notation systems —the ones we encounter most often in our practice —with BPMN. The primary weakness in all of them, which leads us to prefer BPMN, is that they lack the ability to model the interactions of participants acting autonomously. As we saw earlier, simple swimlane representations are insufﬁcient for modeling collaboration. A secondary reason to prefer BPMN is the greater precision it provides, compared to the other notation systems, for handling events.
2.12.1	Extended event-driven process chain (eEPC)
The event-driven process chain (EPC) is a component of the ARIS methodology devel-oped at Saarland University in cooperation with SAP AG. The resulting BPM software, ARIS Toolset, integrated tightly with the ERP (enterprise resource planning) solutions by SAP. Processes implemented in SAP products consequently were documented as EPCs, and that’s a major reason they’ve been implemented so widely. It also made EPC dominant as a notation until 2008. Now, however, it has become apparent that EPC will be superseded by BPMN. Many EPC process modelers are preparing to switch, although that’s not always easybecauseofdifferencesintheapproach. Meanwhile,ARISoffersprocessmodelingwith BPMN as well.
The EPC consists of the three basic symbols: function, event, and connector.  Similar to gatewaysinBPMN,connectorscanfunctionasexclusivebranches(XOR),and/orbranches (OR), or in parallel (AND). The difference between data- and event-based branches does not exist in EPC. The extended version added symbols to describe organizational units, data, and application systems. You can reference subprocesses through so-called process paths or process signposts.
Converting EPC process models into BPMN is comparatively simple, as shown in ﬁg-ure 2.109 on the next page, though you need to be careful when converting events.  EPC
90	2  The notation in detail
Clerk
We model assigned organizational units as lanes in BPMN.
Expert

Application received

We can model start events as start events in BPMN.
We transfer	Application information/documents as
data objects.

Check application
XOR

Data are checked in this XOR connector. That is why we have to use the XOR gateway in BPMN and write both events as possible variants on the edges.
Accounting clerk
Application management

Data complete
Record application
Application recorded

Expert

Data incomplete
Reject application
Application rejected

In the EPC, each function must be followed by an event, which is often unnecessary (so-called trivial events). We can simply leave them out in BPMN. If, on the other hand, they mark a status we want to record, we can transfer them as none intermediate events.
There is no separate symbol for application systems in BPMN. Solution: We can include the information in the task text, attach an annotation to the task, or introduce an artifact.

XOR
Application processed

A connector is mandatory for mergers in EPC, in BPMN it is not, if the arrows run into a task or an end event. We can therefore ignore it upon transfer in this case.
The last event of an EPC marks the final status of the process, we therefore transfer an end event into BPMN.
Application
Data complete?
Expert
Application processing
Application received

Check application

no
yes

Reject application

Application rejected

Application processed
Application management

Record application

Application recorded
FIGURE 2.109  Converting EPC into BPMN.
2.12 Comparison with other notations	91
interprets possible data states the same way as it interprets events —incoming messages that trigger a process, for example.   You mustn’t model data-based decisions as event-based gateways, but rather as data-based gateways.  Given EPC’s name, it is ironic that BPMN is superior for modeling events.  EPC neither differentiates between start, end, or intermediate events nor does it recognize different types such as message or timer.  EPC doesn’t let you attach events, so it is difﬁcult or impossible to model monitoring functions, troubleshooting, or escalations.  Another advantage of BPMN is in how it lets you treat an application as a data object: we could have attached our application as an input to the checkapplicationtask(asinEPC),butinstead, weattachedittothesequenceﬂowbetween the starteventandthe task. You canthus see at aglance that the document was not already available in the company, but that it was sent there.
EPC still has lots of users. They have a history with EPC, they are used to working with it, andtheymayﬁndithardtointernalizethenewparadigmthatBPMNrepresents. Giventhe shortcomings of EPC for modeling process automation, however, you should not consider it for modern BPM projects.
2.12.2	UML activity diagram
The activity diagram is one of 13 diagram types deﬁned in UML (Uniﬁed Modeling Lan-guage) version 2. Like BPMN, UML is managed by the OMG (Object Management Group), though only since 1997.  No one should mistake BPMN as a successor to UML, because UML is a general language for modeling software systems.  Though it was not developed for modeling business processes, UML activity diagrams have been used often for process modeling —especially for IT projects.  One frequent use has been to diagram target state processes as part of developing engineering requirements for new software.
UML’s notation for activity diagrams is more comprehensive than EPC’s. It contains a cou-ple of symbols speciﬁc to software that have no direct equivalent in BPMN, including pro-cessing objects and object parameters in individual actions. Most of the current UML sym-bols for modeling business processes can be converted with no problem. What does be-come difﬁcult is if you work with interruptible activity regions that cross several lanes. It would be a tidy solution to transfer these into BPMN as embedded subprocesses, but we can’t do that because subprocesses in BPMN must not cross lane boundaries. The only so-lution is to deﬁne the subprocesses as global (and thus reusable), and to model the pool and lanes. That may be ugly, but it is the only way to make it work. (See ﬁgure 2.110 on the following page.)
Activity diagrams remain important for specifying software-related detailed sequences. Their integration in the UML framework supports this, as does the standardization by the OMG. But we think BPMN is still better for requirements engineering of process-driven applications, particularly if you also need to document process functions.  Deﬁning pro-cesses that the workﬂow engine executes directly is BPMN’s specialty.  No other notation can match it.
92	2  The notation in detail
Clerk
The activity itself decribes the process, as understood by the BPMN, which is why we can transfer it as a pool and write the designation in the pool header.
Application processing
Clerk

We can usually transfer so-called partitions as lanes.
Expert
Initiating receive signals correspond to a start event in BPMN, for example, of the message type.

An interruptible activity region corresponds to an embedded sub-process expanded in the parent process in BPMN. But that does not fit if the region is to cross several lanes. Then we have to work with reusable subprocesses in BPMN.
An object node in this case	Application received
corresponds most likely to a	Actions are
data object.	tasks in BPMN.
Application	Check application
The UML has the  XOR split shown here and the AND parallelization or synchronization as control elements for
sequence control. On the other hand, it	Application withdrawn
does not know an and/or split (OR).
[Data complete]
[Data incomplete]

Interrupting receive signals from activity diagrams can be differently interpreted in BPMN²  in this case as a message attached to the subprocess (region).
Confirm withdrawal
Application management       Record application
Application systems are represented as object nodes too in UML 2. BPMN provides the options already presented in the EPC comparison.

Reject application
Like the EPC, the UML requires the respective node for the merger, which we do not always need in BPMN.
The final node in UML corresponds to the termination in BPMN. Interestingly, it is used often in UML diagrams,
Application processed	even though the UML also knows simple final nodes for paths. But we recommend always to work with simple end events if a termination is not required.
Application
Expert
Application processing ± Interruptible activity
region
Check
application

Data complete?
No

Reject application
Application received
Application processing - Expert

Yes
Application management

Record application

Application processed
Application withdrawn
Confirm withdrawal

Application withdrawn
FIGURE 2.110  Converting a UML activity diagram into BPMN.
2.12.3	ibo sequence plan
The ibo sequence plan is implemented in Prometheus, which is BPM software from ibo Software. Like EPC, Prometheus is a proprietary notation system. We include it here be-
2.12 Comparison with other notations	93
cause it is based on the conventional and widespread ﬂow diagram. (ibo is a management consulting agency with more than 25 years of experience. Most of its customers are from the German-speaking ﬁnancial world.) Though the ibo sequence plan is well established among process managers, ibo has discovered the advantages of BPMN. It has integrated BPMN into Prometheus.
Most of the symbols of the sequence plan transfer easily into BPMN, as we illustrate in ﬁgure2.111onpage93. Theonlyproblemiswhenyouhaveatemporalinterruptioninyour sequence plan. This can only be modeled as a timer event if it is caused by a process owner who deliberately does nothing for a certain period, and who then continues the process. We already examined sequences in which an interruption served as an indicator. We could continue the process after a countdown expired and because something else needed to happen. That does not work in BPMN. The only solution is to model the event that we’re waiting on as a type (a message or a condition, perhaps), and to append an annotation to show how long it usually takes for the event to occur.  That gives us a clean control ﬂow without losing the indicator for the average wait time.
2.12.4	Key ﬁgures and probabilities
Can BPMN analyze and simulate processes? People who have worked with other notation systems ask this regularly, but the answer may not be a matter of methods but one of tools. What BPM software do you use? Does it let you store key ﬁgures and probabilities as well as the corresponding analysis?
To be honest, the BPMN speciﬁcation —even at version 2.0 —does not provide attributes to integrate key ﬁgures in process analysis.  You could regard that as a regrettable deﬁcit in the standard. On the other hand, simulation is particularly complex, and few people or organizations are willing to spend the time and money to implement it consistently. If the BPMN speciﬁcation represented all aspects of process simulation, the document would probably be 50 to 100 pages longer than it is.  The shift in focus might even undermine BPMN in terms of the things it does well.
Figure 2.112 on the following page shows how the key ﬁgures lead time (LT), idle time (IT), and cycle time (CT) can be visualized in a process diagram along with probable outcomes. After an application arrives, it sits for about two hours before it is checked. The check takes 15minutes, thentheexpertdecideswhethertorejectorrecordit. Ninetimesoutoften, the application is recorded. We have modeled possible intermediate states, and we can offer the ﬁrst analysis: The processing time from receipt to recording is 160 minutes.  Rejects take only 140 minutes because the process bypasses the holding time on the clerk’s desk. Taking all probabilities into consideration, we know that the average running time for the process is 158 minutes. Appropriately, we note this at the end event.
This is merely one example. Different BPMN tools offer different ways to deﬁne key ﬁgures, and they provide a variety of ways to depict and to use them. The extent to which process simulation is carried out makes further demands on the process model.  Further depen-dencies may include the occurrence probability of multiple, the capacity of resources, and so on.
94	2  The notation in detail
In the sequence plan, assigned roles stand directly in the task. In BPMN, they become lanes.
The sequence plan differentiates between conventional files (physical documents) and electronic files. In this case, we
modeled the application as a	Application
conventional file. Because we know only the data object in BPMN, we have to incorporate the type in the designation or to introduce another artifact to maintain this differentiation.
Connectors are used in the sequence plan to replace the ³chain-links,´WKDW is, the control flow, with jump labels. That makes particular sense if the diagram extends over several pages. In BPMN, we use the link events for that. In this diagram, the use is
unnecessary.

A source in the sequence plan is the symbol for the process start. This corresponds to the start event in BPMN.
Application	The Or split of the sequence plan applies
received	exclusively and thus corresponds to the data-based
XOR gateway in BPMN. In the sequence plan, we
EXPERT	see who decides on continuing. In BPMN, this is
represented by dragging the XOR gateway into the Check application	corresponding lane. The sequence plan does not
know an And-Or (similar to the OR gateway), but it knows an ³AND spliW´ (similar to the AND gateway).
EXPERT
Data complete?	no	The temporal interruption is
a special feature of the ibo
yes	2 hours	sequence plan. We can
K1	transfer it as an intermediate 1	timer event, but only if this
interruption is caused by the EXPERT	process owner.
K1	Reject application
1
The application systems are given in the task itself, as are the roles. In BPMN, we can copy this style (which we did in the example) or introduce a separate artifact.
The sink marks the end of the sequence plan, we use the end
event in BPMN instead.

EXPERT
Record application
Application management

The OR merge of the sequence plan is recognized by the arrowhead. In BPMN, as always we would either use an XOR merge or let the arrows run directly into
the task or the end event.
Application (physical document)
Check application
Expert
Application processing

Data complete?
no

Reject application

Application
processed
Application
received

yes	2 hours
Record application [Application
Clerk
K1/1	K1/1	management]
FIGURE 2.111  Converting an ibo sequence plan into BPMN.
2.13	Choreographies and conversations
We showed in section 2.9 on page 78 that BPMN attaches particular importance to the in-teractionofdifferentparticipants. BPMNevendescribestwoadditionalmodelingmethods for this. We have so far seen little value in these methods for real-life projects, but we’ll ex-plain their potential.  At the bottom right of ﬁgure 2.113 on the facing page is our pizza collaboration from section 2.9 on page 78. It was merely decorated with the message ob-jects (the envelopes), and we have positioned them on the message ﬂows.
In the middle of the picture, notice the corresponding choreography diagram.  This dia-gram reduces our view of the process to the exchange of messages between participants. In section 2.9.4 on page 83, the pools of both participants were collapsed. Choreography diagrams are considerably more accurate because we can still recognize the fundamental
2.13 Choreographies and conversations	95
Clerk
Expert
Application          IT: 120 min LT:  15 min

Date complete?

IT:    0 min
LT:    5 min	CT: 140 min	Ø CT: 158 min
Application received
Application processing

Check application

No (10%)
Yes (90%)

Reject application

Application rejected

Application processed
IT:   20 min
LT:    5 min	CT: 160 min
Record application
Application recorded
FIGURE 2.112  Possible representation of key ﬁgures in BPMN highlighting how the key ﬁgures, lead time (LT), idle time (IT), and cycle time (CT), can be visualized.
sequence. In the earlier diagram, it appeared that the customer only asked for delivery if 60 minutes elapsed since his or her order. That would be strange. In contrast, a choreography diagram models only the tasks that are relevant to the message exchange, and they do it only once for both participants. This makes the diagram much clearer. The sending partic-ipant has a white background; the receiving or reacting participant has a gray background. It does not matter if you place the participants above or below the task.  Choreography diagrams can also deﬁne subprocesses to be modeled as choreographies.
The top part of the ﬁgure models the content of a matching conversation. This is the most compact way to represent the participants and their collaboration. A conversation in this regard stands for messages that are exchanged and logically connected to each other.  In other words, they correlate.  In most cases, a conversation should stand for one collabo-rative process only. To be precise, we note that conversations in BPMN are not a separate type of diagram, but a variant of a collaboration diagram.
When do such diagrams make sense? Some BPMN experts regard them as superﬂuous, but we disagree. A one-person business may have little need for process modeling, but the sys-tematic examination of processes —from an organizational or a technological perspective —only becomes more important as an organization grows larger and more heterogeneous.
As the number of people collaborating in a process increases, the less you can depend on implicit understandings and coordination among them, and the more important process modeling becomes.  The same applies even more clearly to process implementation be-yond the limits of IT systems.  Both choreography diagrams and conversations can rep-resent useful maps for situations where you have to recognize quickly the critical points in a collaboration.  If required, you can then model them in more detailed collaboration diagrams.
96	2  The notation in detail
Participant (collapsed pool)
Customer
Conversation
Trigger and process pizza delivery
Deliverer

Conversation
Sending participant

Inquiry message
Order

Customer
Deliver pizza
Deliverer

Answer message

Reacting Money       participant
Customer	Pizza
Order pizza
Choreography

Customer
Collect money
Deliverer
Receiving participant

Customer
Inquire
60 minutes	Deliverer

Customer
Deliver pizza
Deliverer
Pizza

Deliverer
Receipt
Choose pizza	Order pizza
Process (private)
Pizza Customer
Hunger noticed

Pizza received

Inquire at pizza delivery service

Pay for pizza
Pizza received

Eat pizza
Hunger satisfied
Order	60 minutes	Money
Receipt
Collaboration
Bake pizza	Pizza
Process (private)
Pizza Delivery Service
Pizza baker
Order received
Deliver pizza	Collect money
Delivery boy
Order delivered
FIGURE 2.113  The pizza story as conversation, choreography, and collaboration.
3
3.1

Strategic process models
About this chapter
Strategic process model

Content:  Process overview Goal:  Fast comprehension
Semantics:  Logically abstract
Operational process model
Human process flow

Technical process flow

Content:  Operational processes Goal:  Coordinate details between
human process flow and technical process flow (automation)
Semantics:  Physically specific
FIGURE 3.1  Strategic process models in the Camunda house
3.1.1	Purpose and beneﬁt
You must be able to depict a process from start to end at the strategic level. Such strategic process models are necessarily rough. They are necessarily compact. The audience to bear in mind is likely to be the executive in charge of a company division. He or she may be a process manager or a process owner. The strategic process model also serves process par-ticipants, analysts, engineers, and external partners. Yes, these other audiences will need —and they are likely to insist upon —more detail, but they also need to have the strategic view if they are to work together toward a goal that makes sense for the organization.
Tobereadily comprehensible, yourstrategicdiagramsmay needtoinclude informationon computer systems or human tasks, but the diagrams must remain compact. The point at this stage is to create something that everyone can grasp, and, at a glance, know what the process does, for whom it is done, and the basic sequence of how it gets done.
Consider a strategic model when needs like these exist:
98	3  Strategic process models
■      To clarify what is and is not part of a process.
■      To identify resources for a process and assign responsibilities.
■      To identify key performance indicators and specify their characteristics. An example KPI may be that a process has a maximum run time of 24 hours.
■      To review a process initially in the course of an improvement action.
3.1.2	Model requirements
The chief requirement of a strategic process model is that it is easy to understand —even for people with no experience in BPMN. The model must be comprehensible so that it will be accepted as a means for helping the situation.  The title of Steve Krug’s book on web usability is wonderfully suggestive when it comes to strategic process models:
Don’t Make Me Think!
It also must be abundantly clear who the customer of the process is.  Process manage-ment philosophy is that a process exists only for carrying out a deﬁned task for a deﬁned customer. Ensuring customer satisfaction is the purpose that deﬁnes many performance characteristics, and these characteristics are often the focus for improvement projects.
No one can grasp a process at a glance if the model extends across several pages.  Our standard for a strategic model is to ﬁt it onto a single sheet of standard-sized ofﬁce pa-per. Orient the paper horizontally, and you automatically have something compatible with PowerPoint.  It doesn’t help to squeeze in as many lines and boxes as possible.  For our strategic models, we limit ourselves to 10 or fewer ﬂow objects and not more than eight artifacts.
In the purposefully plain model we’re describing, you can’t use the whole array of BPMN symbols.  (This isn’t the time for compensation events or multiple-instance tasks in any case.) Does the model lose some of its expressiveness? Sure. Does it become less precise? Not necessarily, though it does make for a less granular representation than you might oth-erwise prefer. Limiting yourself to ten ﬂow objects and eight artifacts is very restrictive too, although you can choose which symbols to use and which to set aside for the sake of sim-plicity. You can even use custom symbols as artifacts. We’ll discuss custom symbols later in this chapter; meanwhile, section 3.3 on page 102 presents a set of symbols that we ﬁnd useful for strategic diagrams.
The second compromise is a semantic one. In section 3.2 on page 101, we give an example that shows how the semantics of strategic process models cannot be fully consistent. We struggled with this at ﬁrst, but what we ﬁnally came to accept was that insisting on con-sistent semantics in strategic process models just made the models too complicated. The complexity interfered with the understanding and acceptance we needed from our target audiences, and so the models failed. Now, we knowingly accept inconsistencies, but only at the strategic level, mind you!
We remain strict with syntax, however, and we make certain our strategic models are syn-tactically correct. (The available BPMN tools check syntax and so help to enforce correct syntaxanyway.) Asarareexception, weadmittedlydivergefromtheBPMNsyntax, butonly if the divergence is minor in nature, permitted by the tool, and offers a clear advantage in creating understanding.
3.1 About this chapter	99
Our modeling etiquette
The principle for strategic process models is:  Make the syntax as correct as possible, but allow inconsistent semantics if necessary.
3.1.3	Procedure
When do we model strategic processes? We do it either after the initial process discovery, when we have a general idea of an existing process, or at the beginning of process design, when we are conﬁguring the new or improved process (see ﬁgure 3.2).
Workshops Interviews Monitoring

Current state process model
Weak points?

New process Diagnose problems
Search for causes
Estimate potential
Process survey
Existing process

Process documentation
Modeling Process maps Flow diagrams

Yes
No
Process controlling

Process analysis
Current state process model

Process design

Modeling
Target state concept Process simulation Assessment of alternatives ROI estimate
Process implementation

Target state process model
Continuous until process improvement is required

Change Management Conventional IT projects Process automation
BPM governance
FIGURE 3.2  Strategic process models can be generated in two stages of the BPM life cycle.
It is signiﬁcantly harder to do an initial discovery of a process than most people think. Sometimes you have documents such as standard operating procedures available, but most of the time you have to interview the process participants or the process managers. Thesemaybeone-on-oneinterviewsorgroupinterviewscarriedoutaspartofaworkshop.
The advantages of a workshop are that you can gain several perspectives at once, and that the participants start feeling invested in the BPM project early on.  That can increase ac-ceptance. Workshops can be exhausting, however, because everyone perceives the process differently, because they all want to have their pet variations and contingencies consid-ered, and because they already know what goes wrong.  When different departments or teams participate —usually the case because of the comprehensive nature of the processes —discussion can quickly devolve into political squabbling. By then, you stand little chance ofcreatingadifferentiatedprocessmodel. Imagineyou’vedrawnonlytworectangleswhen you hear the ﬁrst interjections:
100	3  Strategic process models
■      "Before we can conﬁrm the delivery date, we have to check the order details for com-pleteness."
■      "But we don’t always do that after the order was received! Sometimes we have to check the customer’s credit ﬁrst."
■      "But only if the contract volume exceeds 300,000!"
■      "And if it is not a class A customer!"
■      "Yes, right, that would have to be checked too then. Who takes care of that?"
■      "The account executive."
■      "In our department, his assistant does. At least, if the account executive is busy."
■      "Seriously? Do they even permit that? In our department, he always gives the account executive the order so she can check it!"
And so on. Every BPM expert knows that his or her attempt to get a bird’s eye view of the process gets lost in the croaking of the frogs who, naturally, have only a frog perspective. Unless you chair the workshop with an iron ﬁst, the disaster takes its course: Everybody either gives up in exasperation or, even worse, agrees on a process model that looks com-plete but isn’t, one that may even be wrong. You may as well give up too, since your process model will only gather dust in some little-used cabinet!
When you chair an initial survey workshop, use the following as a mantra:
All process models are incomplete —but some of them are useful!
We credit statistician George E. P. Box for inspiring this thought. What it means is that you should never attempt to model a process in a greenﬁeld approach, to try to account for every contingency and any possible variation.  It simply will not work out.  Instead, you should communicate at the beginning of the workshop that you want to start with just a general idea of the process. Set the following goals for this ﬁrst iteration:
■      We want to record the process from start to end.
■      We want to record the process in a maximum of eight steps.
■      We want to record the standard procedure only.
■      We want to record the regular responsibilities.
■      We want to record neither the weak points nor to devise improvements.
If you set these goals at the beginning of the workshop, you and your frogs can achieve the ﬁrst-iteration bird’s eye view you need, and you can do it in a span of 30 to 45 minutes! You must be careful to stay on target, however. Whenever a frog tries to escape back to the swamp, you have to stop him!
This ﬁrst iteration is important psychologically. When it’s done, the group will feel a ﬂush of success, and they will see that the process can be managed after all. From this basis, you can launch into the gritty details of the process in subsequent iterations.
Can we start using BPMN in the ﬁrst iteration? It isn’t necessary, but yes, we can, and doing so has a beneﬁt: It gives the group a good initial feel for the symbols and practices.  You can also use index cards.  For some time now, we have been experimenting with BPMN symbols attached to a white board with magnets. You can move them around easily during the discussion.
3.2 Case example: Recruiting process	101
3.2	Case example: Recruiting process
Robert, a Human Resources manager, wants to improve the recruiting process. He believes that his staff members do too many tasks by hand that could be handled more efﬁciently by software. Moreover, he’s tired of hearing complaints from other departments about how long it takes to ﬁll vacancies.
Robert is convinced that most of the delays are because the managers of those other de-partments spend too much time vetting candidates. Also, they don’t provide enough infor-mation with their requisitions, and they are slow to respond to questions. He can’t prove his suspicions though.
Talking with us, Robert describes the recruiting process:
"When a department wants to ﬁll a vacancy, the manager notiﬁes me by e-mail. They ﬁll out a form —it’s just an Excel spreadsheet —where they enter the job title, and a job de-scription, and their requirements, and..."
We interrupt Robert. The point, we explain, is not to discuss the cells in his Excel spread-sheet. We are interested in the basic sequence. The other stuff comes later.
"Oh, okay. So they notify me of the vacancy by e-mail. I have to check to whom I forward the e-mail, and that depends on who’s available at that moment. Usually I just ask around, since we are all in one ofﬁce anyway."
Again, we have to dampen Robert’s talkativeness.  Patiently, we explain that the point is merely to record the most important process steps and to set aside any operational details. He seems taken aback, but he continues:
"Well, then it’s simple: We post the job and wait for appropriate applications.  We check the applications, select a candidate, and ﬁll the position. Essentially, our job is done if the selected candidate signs an employment contract, even though we have to yet record his or her information in the personnel ﬁles. Is this still too much detail?"
It is. For us, however, we can now extract the following key data about Robert’s process:
■      The process is triggered by a department’s requirement to ﬁll a vacancy.
■      A job is posted, applicants apply, applications are checked, and the vacancy is ﬁlled.
■      The process has reached its target when the vacancy is ﬁlled, in other words, when an employment contract is signed.
Basedonthekeydata,webuildtheprocessmodelinﬁgure3.3onthefollowingpage,which Robert understands right away, although we did have to explain a little about the condi-tionaleventthattriggerstheprocess. Wedeliberatelyputtheendeventinthedepartment’s lane to follow the BPM principle of starting and ending processes with the customer.
As a BPMN adept, did the semantic inconsistency of the model catch your eye? If we imag-ine a token running through the process, we have a huge problem with the submit appli-cation task and also the check applications task.  If a single application was submitted, it is impossible to check several applications. That is a contradiction in content, a semantic inconsistency.
The problem doesn’t get better by changing the task description to the plural form submit applications.  That makes it look as though one applicant applied for the job repeatedly, and that’s probably nonsense too. The truth is that there is no formal, clear, syntactically
102	3  Strategic process models
Our company
Human Resources
Recruiting process
Report job vacancy
Hiring dept.
Vacancy arises

Contract signed
Vacancy filled
Advertise job

Check applications

Fill vacancy
Submit application
Applicant
FIGURE 3.3  Strategic process model for the recruiting process.
correct solution for this, assuming that we want the model to remain as easy to understand as it is now.
What does Robert say about our problem?  Probably nothing.  For him, the connection between these tasks is obvious, and he grasps the basic sequence of the process at a glance. We have achieved what we needed from the strategic process model, so we smile and nod and keep quiet about the semantic inconsistency.
The representation has another shortcoming: You can’t tell from the diagram that examin-ing the job applications involves the requesting department as well as Human Resources. We accept this inaccuracy at the strategic level as well, since we haven’t started the detailed analysis phase yet.  If we model a task or a subprocess involving more than one process participant, we assign the activity to the lane of the party responsible for successful com-pletion.
3.3	Restricting the symbol set
As we showed in Chapter 2, BPMN has more than 50 symbols.  That’s far too many for strategic process models, and it is why we use only a subset of symbols. Use any subset you choose for strategic process models, but our suggestions follow.
3.3.1	Pools and lanes
After reading section 2.9 on page 78, you should assess ﬁgure 3.3 critically. After all, BPMN requires a conductor for each process, one who orchestrates (assigns tasks to) all the peo-ple and systems in the process. But this process isn’t controlled by a workﬂow engine, so there is no conductor here. When the requesting department sends its request to Human
3.3 Restricting the symbol set	103
Resources, there is no forwarding of the instance, so you should model it as a message ﬂow. Also, you should assign the requesting department to another pool.
In ﬁgure 3.4, we did assign the requesting department to another pool. It now reports its vacancy explicitly in the form of a message to HR and, if the vacancy can be ﬁlled, the requesting department is informed likewise.
Report vacancy
Hiring department
Vacancy arises

Contract signed
Vacancy filled
Advertise job
Vacancy reported
Recruiting process
Human Resources
Department

Check application

Fill vacancy
Vacancy filled
Submit application
Applicant
FIGURE 3.4  Reassigning the requesting department to a separate pool.
While this representation has its charm, a problem still exists: The applicants are not or-chestrated by a conductor either. (A conductor for this pool would have equal control over both applicants and HR.) Figure 3.5 on the following page shows the collaboration when each party has its own pool.
The more we detail our model of the collaboration, the more questions arise, and the more we can detect inaccuracies and inconsistencies.  How does an applicant learn about the vacancy? If he or she responds to a published notice, we should model this with a signal event, not a message. And the diagram still shows that we are waiting for one application instead of several, nor is it clear that we check applications immediately upon receipt or collect them all before checking. Finally, it appears that the applicant only has to submit an application to achieve employment. No interview required!
We could clarify all these issues with Robert and revise the model accordingly, but that’s not the purpose of the strategic process model. Robert grasped the meaning of ﬁgure 3.4 with little explanation.  It is doubtful that he would react well to our later diagrams if he encountered them when we weren’t there to explain the symbols for the signal event or the different cardinalities of instances (one job posting, many applications). Robert wouldn’t understand the model at ﬁrst glance, and he wouldn’t accept it any more. Consequently, we put ﬁgure 3.5 on the following page aside for further development at the operational level.
104	3  Strategic process models
Report vacancy
Hiring department
Vacancy arises

Contract signed
Vacancy filled
Advertise job
Human Resources
Vacancy reported

Application received

Check application

Fill vacancy
Vacancy filled
Advertisement seen
Applicant

Submit application

Application submitted
FIGURE 3.5  Each party is assigned its own pool.
For strategic process models, we usually abstain from using multiple pools unless the cus-tomer is external to the organization.   In such cases, a separate pool lets us model an overview of order processing, for instance, or complaint handling in the second pool.  In ﬁgure 3.6, we show the customer as a collapsed pool so that we can focus on the process sequence at the time an order is received.  Wouldn’t it be nice if we could model all pro-cesses this way?
Customer
Sales Department
Check order
Order received

Retrieve item from warehouse

Dispatch item
Order processed
FIGURE 3.6  The customer as a collapsed pool.
We can’t.  The recruiting process example shows why we can’t.  In reality, we often have external partners that cannot be assigned to their own pools without making our strategic diagram so complex that it no longer serves our needs. On the other hand, we often deal withprocessesinvolvinginternalcustomerssuchasthehiringdepartmentintherecruiting process.
3.3 Restricting the symbol set	105
Our company
Human Resources
Dept.
Recruiting process
3.3.2	Tasks and subprocesses
Tasks often appear in our strategic models, but subprocesses appear only rarely. Task typ-ing (see section 2.7.1 on page 61) is something we don’t do for strategic process models though, and we also abstain from applying markers (see section 2.7.2 on page 63) with one exception:  the loop marker.  That is intuitive for most people, so we use it for strategic process models.
Our modeling etiquette
When we explained tasks in section 2.2 on page 27, we said our convention is to use the verb + object pattern —report vacancy, for example.  When designating subprocesses at the strategic level, we do things a little diﬀerently. We nominalize them —turning post job into job posting and check application into application checking.   In some cases, nominalization produces something that sounds a little unfortunate, but there are two advantages:  First, this practice diﬀerentiates tasks from subprocesses.  Second, com-pared to tasks, subprocesses are discussed more often and in more depth. The nominal-ized forms help participants express themselves more constructively:  "The application checking is still too complex.  We have to...." Does this seem like splitting hairs?  Is it pedantic?  Our experience has shown that the devil is always in the details of project communication and software development.  Careless language quickly leads to costly misconceptions; it is worth paying attention to such details.
Subprocessesshouldreﬁneprocessesandprocessmodels. Intherecruitingprocessmodel, we could deﬁne the steps advertise job, submit application, check application, and ﬁll va-cancy as subprocesses.  It’s likely that they stand for complex operations and not simple tasks. From what Robert told us, the report vacancy task, however, seems to be limited to completing and sending an Excel spreadsheet. That doesn’t sound like a complex opera-tion, so we leave it as a task. To represent this thinking, we come up with ﬁgure 3.7.
Report vacancy
Hiring dept.
Vacancy arises

Contract signed
Vacancy filled
Job advertisement

Application checking

Vacancy filling
Application submission
Applicant
FIGURE 3.7  Diﬀerentiating tasks and subprocesses in the recruiting process.
106	3  Strategic process models
The question now is if we want to model collapsed subprocesses fully on the strategic level. Usually, we don’t do that because the point of the strategic level is not to show detailed operational sequences. We can’t make it correspond smoothly to the subprocesses level of detail anyway because of the semantic inconsistencies already described.
3.3.3	Gateways
The recruiting process shown in ﬁgure 3.7 on the preceding page is based on the assump-tion that we can ﬁll vacancies when and as we like. That’s not the reality, because some-times we can’t ﬁnd a qualiﬁed candidate. We could model this and other special cases with gateways, but not at the strategic level.
Atthestrategiclevel, weonlydealwiththeso-calledhappypath, meaningthatweshowthe process path and results that we’d like to see. Most of the time, the happy path is sufﬁcient. But if a process has different triggers, as in a customer-driven process, for example, we do sometimes have to model multiple paths at the strategic level.  This is the time for a gateway.
We recommend using gateways as follows (refer to ﬁgure 3.8 on the next page):
■      Use XOR gateways for splits, that is, when no conditional ﬂows exit directly from tasks. XOR gateways are easier to intuit than conditional ﬂows. Target audiences understand a split when they see it.
■      Merge tasks without XOR merge. In other words, let arrows ﬂow directly into tasks. Such gateways (especially loops) only confuse inexperienced users; besides, omitting them results in more compact diagrams.  Although we must use the gateways for merges in front of intermediate events and AND gateways, those should not appear at the strategic level.
■      Use the AND gateway with no direct exit from the tasks to synchronize and make paral-lel. Parallel parts of a process need to be synchronized again later, so the AND gateway shouldbeusedinbothcasestomaketherepresentationuniformandtoavoidconfusion.
■      Do not use the OR gateway.  It quickly results in meaningless constructs if you’re not careful. Theoretically, you can represent any OR gateway by combining XOR and AND gateways. Again, however, this kind of complexity should not be part of a strategic dia-gram.
■      Do not use the complex gateway. This representation of complex splitting and merging logics does not belong at the strategic level.
3.3.4	Events and event-based gateway
We recommend using start and end events at the strategic level to mark the start and the end of the process. You could do without these symbols, and the recruiting process would look like ﬁgure 3.9 on page 108. The diagram is more compact, but you can’t see the pro-cess trigger or its desired end condition.  That’s a particular problem for the start-to-end presentation we’re trying to create at the strategic level.
3.3 Restricting the symbol set	107
Parallelization
Merging
Recommended
Answer 1
Question
Splitting

Not recommended
Answer 1
Answer 2
Answer 2
Not possible without AND merge
Synchronization
Condition 1?
Condition 1 yes
no
Condition 2
And/Or
Condition 2?
yes
no
Model differently or better GRQ¶WPRGHODWDOOat strategic level.
Complex
FIGURE 3.8  Recommended uses for gateways at the strategic level.
Compared to start and end events, intermediate events often require a little explanation. It is difﬁcult for many people to understand at the outset that a catching event means that the process waits for that event to occur. We have to label them descriptively to make the
108	3  Strategic process models
Our company
Human Resources
Dept.
Recruiting process
Report vacancy
Recruiting process
Our company
HR Dept.
Hiring dept.
Job advertisement

Application checking

Vacancy filling
Application submission
Applicant
FIGURE 3.9  The recruiting process without start and end events.
meaning clear.  With the exception of none events, catching intermediate events are too complicated for the strategic level.
We only permit some of the possible event types at the strategic level:
None events may be used as start, intermediate, and end events.  The intermediate event can indicate process status during the execution. Process owners readily accept this kind of status as milestones they can use to monitor progress. In ﬁgure 3.10, we show two mile-stones deﬁned for the recruiting process. At the strategic level, process models are some-times so clearly laid out that you could deﬁne a milestone for every step.  In such lovely cases, it is probably better to leave explicit milestone indicators out of the diagram just for simplicity’s sake.
Report Vacancy
Hiring dept.
Vacancy arises

Contract signed
Vacancy filled
Job advertisement

Application checking

Vacancy filling
Job advertised

Applicant selected
Application submission
Applicant
FIGURE 3.10  Deﬁning milestones for the recruiting process.
Wepermitmessage andtimer eventsasstarteventsandintermediateeventsatthestrategic level. The symbols are virtually self-explanatory.
Theconditionalevent isproblematicbecausepeopledon’trecognizeitrightaway. Itcanbe useful at the strategic level, however, because process owners want to see at a glance which conditions trigger a process or when a process has to execute. A common example is the tendering process, which, for compliance reasons, has to start as soon as an order exceeds acertainamount. Thisiswhyweincludetheconditionaleventinourstrategicleveltoolkit. We use it often.
3.3 Restricting the symbol set	109
We try to apply a type to every process start event. In other words, we model it as a message or a timer or a conditional event. We succeed almost every time. If none of these events apply, we consider ﬁrst if we have chosen the correct process start —if our pattern matches theprocess,oriftheprocessactuallystartsearlierorlaterthanwethought. Onceinawhile, we model a none type start event at the strategic level. If we fully model a subprocess, that none start event is important for correct syntax because a subprocess can only be started by its parent process.
Intermediate events can be also attached to tasks and subprocesses, but we avoid using them in this context at the strategic level because they indicate an exception. We want to record only the standard sequence for now. We also exclude the event-based gateway from strategic diagrams; reacting to events is an inappropriate level of detail for the strategic level.
3.3.5	Data and artifacts
Text annotations are permitted at the strategic level. We use them often. In the recruiting processexample, annotationshelpedustoaddinformationtothevacancyﬁlled endevent, namely that the employment contract was signed at that point.
People easily understand the group frame, so it is permissible at the strategic level, but we ﬁnd that it gets used infrequently because strategic models are clear enough without it.  Inexperienced modelers often mistake the group frame for an expanded subprocess, so you may want to hide the group frame at ﬁrst.  You can reveal it after the modelers’ understanding has grown.
Data objects quickly result in visual overload. On the other hand, they can make two things readily apparent:
1.  The essential input and output parameters of a process or a subprocess.
2.  The type of communications between process participants.
The second item technically is a message-ﬂow domain. Because we deliberately avoid us-ing multiple pools —and hence their message ﬂows —at the strategic level, we resort to data objects.
When we ask the Human Resources manager, Robert, how information is transmitted in his recruiting process, he says, "We receive requirement notiﬁcations by email.  We then post the job notices to our website and also on the major Internet job sites.  We receive applications by postal mail and email, though the email responses have been growing as a proportion of the total."
We can model Robert’s communication by using data objects attached to the sequence ﬂows by means of associations (see ﬁgure 3.11 on the following page). We usually attach the essential input and output data to the sequence ﬂow between the start event and the ﬁrst task or between the last task and the end event. That may not be correct in a formal sense because the output is not passed to the end event, but it is intuitive and therefore workable at the strategic level.
110	3  Strategic process models
Recruiting process
Our company
Human Resources
Dept.
Report vacancy
Hiring dept.
Vacancy arises

Vacancy notification (email)

Contract signed
Vacancy filled
Job advertisement
Job advertisement (website, job sites)
Applicant

Application submission

Application checking
Application (postal mail, email)

Vacancy filling
FIGURE 3.11  Data objects indicate forwarded information.
3.3.6	Custom artifacts
As described in Chapter 2, you can add your own symbols to BPMN as long as you only use them as artifacts. You can connect artifacts only by associations to ﬂow objects (tasks, gateways, or events) to prevent them from inﬂuencing the sequence ﬂow. They represent references to things beyond the main sequence.
In our experience, artifacts are well suited to the strategic level for meeting the particular requirements of your process owners. One classic is to represent the software systems used for individual tasks of subprocesses. We usually use a cuboid for this. The cuboid is used for the same purpose in Uniﬁed Modeling Language (UML) use case diagrams, which is why it makes sense to us.
When we ask what IT systems the recruiting process uses, Robert says, "So far almost none. The job description is created in Excel; all the other things are done without any special software." Find the corresponding representation in ﬁgure 3.12.
MS Excel	Contract signed
Hiring dept.
Report vacancy
Vacancy arises	Vacancy filled
Recruiting process
Our company
Human Resources
Dept.
Job advertisement

Application checking

Vacancy filling
zApplication submission
Applicant
FIGURE 3.12  Software use is restricted to Microsoft Excel.
3.3 Restricting the symbol set	111
Applicant
Depending on the industry and the particular needs, you can introduce custom artifacts for completely different purposes. Suppose the insurance sector faces regulatory pressure regardingminimumrequirementsforriskmanagement. Thismakesidentifyingrisksinthe processdocumentationnecessary; youcanuseacustomartifacttoﬂagtherisksassociated with execution of tasks and subprocesses.
3.3.7	Hide and reveal symbols
You can see the extensions added to the recruiting example for milestones, data forward-ing, and IT systems in ﬁgure 3.13. This information is particularly helpful for discussing a process, but because they tend to overload a diagram and add to the potential confusion, not all users of the diagram will want to see them. It is useful to be able to hide and reveal the extra symbols as needed. This is a question we often get in our BPMN workshops; here are our notes:
■      Hiding and revealing is not a feature of the notation. This feature must be provided by the BPMN tool you work with.
■      Several of the BPMN tools make it easy to hide and reveal artifacts such as data, annota-tions, or custom symbols.
■      Hiding and revealing is more complicated for none intermediate events because they at-tach to the sequence ﬂow. When you hide them, you get unexplained and unsightly gaps unless your tool is intelligent enough to rearrange the diagram accordingly. (Suppose an XOR merge was applied before an event that suddenly became redundant because the arrows could enter the task after the event directly.)  So in general, hiding and reveal-ing ﬂow objects like activities, events, and gateways is problematic, which is why most BPMN tools do not provide a hide-reveal feature, or they limit its function.
MS Excel	Contract signed
Hiring dept.
Report vacancy
Vacancy arises	Vacancy notification	Vacancy filled
(email)
Our company
Human Resources
Dept.
Recruiting process
Job advertisement
Job advertised

Application checking

Applicant selected

Vacency filling
Job advertisement (website, job sites)

Application submission

Application (mail, email)
FIGURE 3.13  The recruiting process, including milestones, data, and IT systems.
112	3  Strategic process models
3.4	Process analysis on the strategic level
After making our ﬁrst, rough survey of the recruiting process and documenting it, we can do two things:
1.  We can start a detailed survey to model the actual state of the process at the operational level.
2.  We can content ourselves with the documentation at the strategic level.
The choice depends on the purpose of the model. If we aim for ISO certiﬁcation, or if we want to provide the model to process participants as a guide for their daily work, it needs to be more detailed.
Recall that our Human Resources manager is unhappy with his process, and he wants to embark on a project to improve it.  He has described the symptomatic weaknesses.  Re-membering the BPM life cycle, we can now start with analysis to get to the bottom of the weaknesses and devise ideas for improvement (ﬁgure 3.14).  A detailed survey and docu-mentation of the current state can be helpful for this analysis, but to be honest, the cost-beneﬁt ratio is high enough to discourage it in practice. More often than not, we use the strategic process model to guide our search for causes during analysis.
Workshops Interviews Monitoring

Current state process model
Weak points?

Diagnose problems	New process Search for causes
Estimate potential
Process survey
Existing process

Process documentation
Modeling Process maps Flow diagrams

Yes
No
Process controlling

Process analysis
Current state process model

Process design

Modeling
Target state concept Process simulation Assessment of alternatives ROI estimate
Process implementation

Target state process model
Continous until process improvement is required

Change management Conventional IT projects Process automation
BPM governance
FIGURE 3.14  Process analysis in the Camunda BPM life cycle.
How does searching for causes work? The main thing is that we listen. We listen not only to the process manager, but also to the customer of the process and, of course, to the process participants.  How we proceed and what tools we use always depends on the complexity of the process, but a workshop or two involving these three parties is usually enough to identify the weak points of the process and their causes. We don’t want to discuss the in-terpersonal and political aspects —these quickly become a problem in such workshops. Perhaps they are a topic for a different kind of book.
Here we draw a brief picture of a workshop called Analysis of potentials in the recruiting process. The participants are:
3.4 Process analysis on the strategic level	113
■      Process manager: Robert.
■      Customer: Falko, Sales Manager and representative of the hiring departments.
■      Process participants: Marina, Christine, and Stefan, clerks in the Human Resources De-partment.
■      Process analyst: you!
After the usual introductions and explanations of purpose, you display the process model from ﬁgure 3.13 on page 111. You let it sink in. You apply your well-honed skills as a mod-erator to engage the participants in analyzing weak points. You list an obvious symptom, for instance, and ask the participants to conﬁrm, correct, or amend your observation. You write the results on red index cards and attach them to a white board. They are:
■      The process takes too long. ■      The process is too intricate.
■      The process is not transparent enough.
The complaint about the long processing time comes from Falko. Robert complains about the intricacy of the processing.  Both of them agree that more transparency is needed to support comprehension of the process in whole and in its parts.
Working with the participants, you then extract the causes that account for the symptoms. Step by step, you identify and list on your red cards the causes of the causes. Some of the symptoms or causes may be attributable to a certain subprocess or task, and this will be well marked by the card afﬁxed next to it.  Other symptoms and causes will apply to the process as a whole.
All the workshop participants quickly agree that too many activities in the process are exe-cuted manually. "There must be a technical solution," is a unanimous verdict.
Robert’s criticism that the vacancy notiﬁcations from the hiring departments are often in-complete,unclear,orincorrect,isofcoursenotreceivedenthusiasticallybyFalko,butFalko cannot deny that mere notiﬁcation is usually insufﬁcient. More clarifying details have to change hands between the hiring departments and HR.
For his part, Falko faults the Excel template provided by HR for the notiﬁcations. "These things are a catastrophe! Confusing and without any assistance or explanation. You can’t even see which details are mandatory and which are optional!"
One ticklish issue involves holding times: the periods between task assignments and when they actually occur. Robert and Falko blame each other. They accuse and defend their re-spective staffs without useful facts to back up their statements.  At this juncture, you, as diplomatic moderator, get the squabblers to agree that excess holding times harm the pro-cess, but that the causes cannot yet be clearly established nor responsibility apportioned.
The result of the workshop is the causal chain as shown in ﬁgure 3.15 on the next page. You deduce four solutions to be pursued within the scope of an improvement project:
■      Reduce manual activities.
■      Minimize correction loops.
■      Make the current status of each operation visible at all times. ■      Record and assign responsibility for idle times.
You may suppose that the solutions will be IT-enabled, though that’s not always the case in practice. We do not mean to suggest that software is the solution to every problem. BPMN
114	3  Strategic process models
Excel form is unmanageable     Report
vacancy

Job advertisement
Vacancy notification                               Unclear: Hiring often incomplete /                                 department not
incorrect / unclear	available for inquiries?
Job
advertisement	Application
checking
Unclear: Late
feedback of hiring
Inquiries on vacancy	department on
notification required	candidates?
Job advertisement

Job advertisement
Unclear: Late processing of vacancy notifications by HR Department?
Too many correction loops

Unclear: Tasks are held too long?

Current state of individual instances hard to establish

Distributed processing by process participants
Process participants not always available
Process is too intricate

Process takes too long

Process is not transparent enough
Application checking

Too many manual operations

Forward paper applications
by internal mail     Application checking
Initial screening of applications by clerk required

Job
advertisement
Manual job advertisement required
Check for completeness

Check for ³hard criteria´

Manual entry on company website

Manual entry on job sites
FIGURE 3.15  Causal chain, showing weaknesses and their causes.
development started with the need to improve processes by means of IT, however, and that is why our example reﬂects that kind of scenario.
In the BPM life cycle, you now enter the process design phase to devise an improved target-state process. This is the time for the operational level.
3.5	Conversations and choreographies
The  possibilities  provided  by  BPMN  for  modeling  conversations  and  choreographies haven’t yet established themselves in real-world situations.   We don’t ﬁnd them in our customers’ projects, and we only use them on rare occasions. If you’re interested, the next section provides some thoughts about using them in the described use case.
Looking at the recruiting process as a conversation (ﬁgure 3.16 on the facing page), two possibilities present themselves: In the simplest case, just represent that there are three participants in the process and that they are conversing with each other.  The other pos-sibility is to add a multiple symbol to the applicant to show that, while only one hiring department and the Human Resources Department participate in the conversation, more than one applicant may participate.  Certainly it helps to indicate the different cardinal-
3.5 Conversations and choreographies	115
ities, but the success of doing so depends on users who understand the symbols.  Apart from that, the conversation diagram is good for representing all the parties in a single view.
Hiring department
Recruiting	Applicant

Hiring department
Report vacancy

Check Application
Submit Application
Applicant
Human Resources Department

Human Resources Department
Advertise Job
Fill Vacancy
Sub-conversation Top-level conversation	³Recruting´
FIGURE 3.16  The recruiting process conversation at two levels of granularity.
We can reﬁne this conversation and fully model its sub-conversations. The plus sign in the hexagon of the top-level representation indicates a reﬁnement similar to the symbol for a subprocess in our process diagrams.  We can see in the reﬁned representation that not all the participants participate in all sub-conversations.  The applicants, for example, do not participate in the vacancy notiﬁcations; the hiring department doesn’t participate in posting the job.
There’s a semantic problem with this representation: The job posting is not a message re-ceived directly by the applicant; it is modeled by means of the conversational relationship. We tend to allow the semantic ﬂaw in the interests of clearness and comprehensibility, just as in our process diagrams. One advantage a conversation diagram has over the sequen-tial representation in a process diagram is that we can take the different communications relationships between participants into account without having to accept a complicated representation with multiple pools and their related message ﬂows.
The representation as a choreography in ﬁgure 3.17 on the next page is even more precise because it also considers the order of communication. We can see the different messages. It is a mixture of conversation and process diagrams because we still see the various par-ticipants in the choreography of tasks and subprocesses. One advantage in this is the more differentiated examination of cardinalities: The job advertisement takes place once, and it is a message from the Human Resources Department to a number of applicants. (No, the semantics are not really correct, but we accept this for simplicity’s sake.)
In the next, application submission step, multiple applicants send their applications to the Human Resources Department. It is correct to represent application submission without a multiple instance, because this subprocess is executed only once by each applicant. The application check, conversely, is executed as often as applications are received, in other words, multiple times. It is completed separately for each applicant, however, which has its effect on the applicant communication partner.  Each applicant gets a separate invi-tation and a separate interview, so the applicant gets no multiple instance symbol in this
116	3  Strategic process models
Vacancy notification
(email)

Job advertisement
(website, job sites)
Vacancy
arises

Hiring Dept.
Report vacancy
HR Dept.

HR Dept.
Job advertisement
Applicant	Job advertised

HR Dept.
Application submission
Applicant

HR Dept.
Application checking
Hiring Dept.
Applicant

Applicant
selected

HR Dept.
Vacancy filling
Applicant

Contract signed
Vacancy
filled
Application (postal mail, email)
FIGURE 3.17  The recruiting process as a choreography.
subprocess.  The last subprocess, vacancy ﬁlling, takes place only once, and the chosen applicant signs a contract.
The advantage of the choreography diagram is that it compactly represents the commu-nications relationship between process participants. It is ideal for providing overviews of communication-intensive processes. The question is if choreography diagrams can be un-derstood and accepted by target groups at the strategic level. In our experience, it is hard enough to introduce the regular symbols of BPMN to such groups.
4
4.1

Operational process models
About this chapter
Strategic process model
Operational process model

Content:  Process overview Goal:  Fast comprehension
Semantics:  Logically abstract
Human process flow

Technical process flow

Content:  Operational processes Goal:  Coordinate details between
human process flow and technical process flow (automation)
Semantics:  Physically specific
FIGURE 4.1  Operational process models in the Camunda house.
4.1.1	Purpose and beneﬁt
It is at the operational level that process models begin to reveal operational details in the form of human and technical ﬂows.  Process participants reference operational process models (the human ﬂows, that is) every day.  Process analysts examine them to identify improvements. Also, operational process diagrams can be the starting point for technical process implementation in the form of technical ﬂows —ideally by a workﬂow engine. The operational process model obviously describes more detail than does the strategic model, but this leads to a problem:
A whole process is a complex interaction between people and IT systems as they carry out tasks.  The process analyst is concerned with getting to the heart of these interactions so that he or she can devise organizational or technical improvements. The analyst’s question is:
How is the work done, and how can we do it better?
118	4  Operational process models
The process participant only cares about the aspects of the process that concern him di-rectly. He wants to know:
How should I do my work?
Whenaprocessrequirestechnologytobeimplemented,theprocessengineer getsinvolved. He or she has to understand what the technical implementation is meant to achieve from a functional point of view. The process engineer asks him- or herself:
What does the engine have to achieve?
It isn’t easy to reconcile the three roles, and answering their questions is the challenge of the operational level. If you meet the challenge successfully, the beneﬁts are:
■      The logic of the operational process model is consistent between operations and the technical implementation. In other words, the process actually works as documented.
■      The understanding gap between business and IT shrinks.  The parties can discuss the same process model, and they can recognize both the technical effects of business re-quirements and the impact technical implementations may have on operations.
■      If the process is implemented by a workﬂow engine, monitoring and reporting on the process can become much more substantial and immediate.
In short, if you master the operational level, you will have found the common language of business and IT —at least as far as process modeling is concerned.
4.1.2	Model requirements
Just as with the strategic level, operational process diagrams must be syntactically correct. Although some semantic irregularities can be tolerated at the strategic level, we can’t allow them in operational models. The operational level describes how work is actually done, so there can be neither contradictions in content nor formal mistakes.
As you develop the operational model for any project that includes technical implementa-tion by means of a workﬂow engine, another requirement arises: All the questions that the process engineer must ask to understand the desired outcomes need to be answered. After all, the technical model itself becomes executable.
Precision serves the process participants too, because they should be able to refer to the model for how to accomplish the work. At the same time, it is best not to burden partici-pants with complexity that doesn’t serve them. After all, the participants’ core competence is the work itself, not BPM. For participants, the process model is just a means to an end, something they may reference only once in a while.
4.1.3	Procedure
An operational process model has to be sufﬁciently precise but not overly complicated. To achieve that apparently contradictory goal, we provide a view of the process model speciﬁc toeachrole. Figure4.2onthefacingpagedepictswhatwemean. Iftheprocessparticipants see a view that represents only their perspective, they are satisﬁed. The participants know what to do and when to wait for others to complete their portions of the process without being distracted by the details of what the others do.
4.1 About this chapter	119
Viewer
Central problem
View

Process participant
How should I do my work?
Own orchestration

Process analyst
How is the work done?
Entire collaboration

Process engineer
What does the engine do?
Orchestration of the workflow engine
Level 2: Operational process model
FIGURE 4.2  The roles and their views at the operational level.
The core idea of the operational level is to differentiate consistently between orchestration and collaboration. As explained in section 2.9 on page 78, each participant gets his or her ownpool. Thispresentstheparticipant’sexperienceasitsown, closedprocess. Reservethe diagram that shows the collaboration among these processes for the process analyst, who presumably can handle the complexity.
Treat the workﬂow engine as a participant with its own pool, and the process engineer can focus on it. Note that in this approach we are following the BPMN idea of a conductor for each pool who controls its processes.  BPMN presumes a workﬂow engine even when a human serves in place of an actual workﬂow engine.
Aside from the improved views, this differentiation is important because in practice, the entire process is almost never controlled completely by a workﬂow engine.  There are al-ways decisions to be made and tasks to be carried out by humans. To represent the process completely in a model, we have to account for the human activities. We accomplish this when we assign a separate pool to each participant, whether human or not.
The process analyst plays a major role in achieving a differentiated model. He or she must comprehend BPMN fully and be able to model the process from different participants’ points of view.  If the target state process is to be implemented in a workﬂow engine, he or she must develop and maintain the model in all its representations, from the strategic to the technical.
This is an example of the process analyst’s steps:
1.  Review the target state process at the strategic level. (See chapter 3.)
2.  Resolve the lanes into separate pools. (See section 4.2 on the following page.)
3.  Model the human ﬂows, that is, the target-state process from each participant’s point of view.(The participants and the process manager must settle upon these details. See section 4.3 on page 122.)
120	4  Operational process models
4.  Model what the participants do that will be supported by the workﬂow engine and how it will do so.  This also must be settled between the manager and participants.  (See section 4.4 on page 125.)
5.  Model the technical ﬂows, at least to the extent that these can be derived from the par-ticipants’ processes. The process analyst or the process engineer can do this. The op-erational model won’t be directly executable, but the process engineer can enhance the model for that purpose. (See section 4.4.2 on page 127.)
6.  Finalize and document other requirements such as templates, data, and business rules. Group these around the process model by referencing them from their relevant symbols in the diagram (See section 4.4.3 on page 129.)
This is only one approach. If it makes sense to you, you can start from the technical ﬂow and work bottom up, or you can work outward from an operational process model.  Fre-quently, it is the operational process model that comes into existence ﬁrst because the business and IT got together during a workshop, and they developed the human and tech-nical ﬂows concurrently.
After developing the model, show the views to the people affected. This takes a tool with good presentation functions. The ability to expand and collapse pools is especially valu-able, since the expand/collapse function means you can avoid having a lot of different di-agrams with redundantly modeled pools. For more on tool support for BPMN in general and our framework in particular, see section 7.4.2 on page 204.
4.2	 From the strategic level to the operational level
We often create a strategic model of the process before we model it at the operational level. For our recruiting process example, we created the strategic process model in section 3.2 onpage101. Wedepicteditinﬁgure4.3onthenextpage,andinsection3.4onpage112,we discussed the process’ weak points. We learned that the process sequence itself is not that bad; most of the friction comes from insufﬁcient technological support. Now the process modeling needs to extend to the operational level. First, we’ll examine the sequence solely from an organizational standpoint.  Second, we’ll think through what a workﬂow engine can contribute to improving the process.
Chapter 3 described how strategic process models often contain semantic contradictions. These make it impossible to reﬁne the model directly, but strategic views often differ sig-niﬁcantly from operational views.  You can assume that a strategic process model rarely changes. At the operational level, you can expect changes more often. That’s another rea-son for the principal structure of models at this level to be technically compatible with the even more detailed implementation models to follow.
As a consequence, while we will reference the strategic process model often, we have to develop the operational model afresh.  That may sound like a problem, but in practice it usually is not: The strategic model doesn’t take that much time to create, and it achieves clarity about strategic purposes and outcomes that you shouldn’t need to revisit while de-
4.2 From the strategic level to the operational level	121
Our company
Human Resources
Dept.
Recruiting process
Report vacancy
Hiring dept.
Vacancy arises

Contract signed
Vacancy filled
Job advertisement

Application checking

Vacancy filling
Application submission
Applicant
FIGURE 4.3  The recruiting process at the strategic level.
velopingattheoperationalmodel. Also,becausethestrategiclevelchangessoinfrequently, you need not worry about duplicating effort to maintain it through updates.
The recruiting process example has a semantic difﬁculty at the strategic level: the differ-ent cardinality of instances. It looks as though every applicant for a job gets that job, even thougheveryoneunderstandsthat’snotthereal-worldexpectation. Everyoneassumesthat the normal course of events is that several applicants submit applications, that Human Re-sources checks a corresponding number of applications, and that a single applicant ulti-mately ﬁlls the vacancy. Another difﬁculty is that we don’t know our applicants nor their number. These are two reasons that, when it comes to creating an operational model, we cannot represent the applicant as a lane in the same pool as the other participants.
A valid operational model also has to specify the interaction between the hiring depart-ment and Human Resources more realistically. It’s not as if HR carries out the job adver-tisement and application checking tasks without consulting the hiring department.  The process analysis (section 3.4 on page 112) showed that the two departments communicate actively; it is the ineffectiveness of their communication that causes most of the friction and ambiguity.  What makes the most sense therefore is to model the processes of these participants in separate pools.  That allows an explicit examination of the organizational interfaces.  It also allows us to provide each participant with information relevant to his or her role, and we can exclude irrelevant information.  Irrelevant information is a huge over-complication!
Figure 4.4 on the following page shows the recruiting process after moving the lanes into separate pools and accounting for the activities that require exchanges between partici-pants. The applicant still reacts to the signal of a job being advertised, but the three short lines at the bottom center of the applicant pool indicate that there potentially are multiple applicants. (Refer to section 2.9.5 on page 84.) The possibility of multiple applicants is why we modeled an AND split after the message application received event; it shows that HR is not waiting for a single application but will instead process any applications received. The terminate event at the end of the HR pool means that this activity will continue only until an applicant is selected and successfully employed.
122	4  Operational process models
Hiring department
Report vacancy	To clarify
Vacancy emerged

Contract signed
To clarify
Vacancy filled
Notification on vacancy received
Human Resources

Job advertisement

Application received

Application checking

VAcancy filling
Vacancy filled
Read advertisement
Applicant

Application submission

To clarify	To clarify
FIGURE 4.4  Start of transfer to the operational level.
Open issues remain to be settled and modeled.  Not only do we have to deﬁne the to be clariﬁed activities, but we have possible special cases to account for. What if:
■      an applicant is rejected as unqualiﬁed?
■      not even one applicant is qualiﬁed?
■      not even one application is received?
Examining this entire process at the operational level easily could exceed this book’s goal of illustrating principles and methods.  In the following sections, therefore, we elaborate only on the part starting with identifying the personnel requirement through advertising the job. (To explore the complete example, visit BPM-Guide.de/BPMN.)
4.3	Processes of the participants
As already described, the process analyst models processes at the operational level. Where does he or she get the operational details needed? Usually from the process participants themselves, that is, the people working in the process.  For the post a job process, we’ll interview Falko ﬁrst, because he’s the manager of the hiring department. Falko describes his contribution this way:
"When I see that we need a new staff member, I report the vacancy to Human Resources. I then wait for them to send me the job description so that I can check it before they publish the advertisement. I may have to request a correction to the job description, but otherwise I release it. And sometimes HR has additional questions about tasks or qualiﬁcations, so I make myself available for clariﬁcations."
4.3 Processes of the participants	123
WhenwemodelFalko’sprocess,wemayincludetheHumanResourcesclerkinthediagram to complete the picture. When we collapse the clerk’s pool, however, ﬁgure 4.5 results.
Report vacancy
Hiring department manager
Personnel
requirement

More information
required

Communicate tasks and requirements

Description
received

Review job description

OK?
No
Yes

Request correction

Release job description

Description
released
Human Resources clerk
FIGURE 4.5  The post a job process from the hiring department manager’s point of view.
Note: BPMN 2.0 does not allow sequence ﬂows to ﬂow directly into an intermediate event following an event gateway.  This prohibition seems unnecessary to us, and we advocate that it be removed in future versions of the speciﬁcation. For the time being, try represent-ing this type of scenario as shown in ﬁgure 4.6.
More information required

Communicate tasks and requirements

Description received

Description received
Report vacancy
Hiring department manager
Personnel requirement

Description received

Review job description

OK?
No
Yes

Request correction

Release job description

Description released
Human Resources clerk
FIGURE 4.6  The current version of BPMN 2.0 requires this representation, which seems ineﬃcient and unnecessary.
Christine, the Human Resources clerk, has a different point of view about the post a job process:  "When a job vacancy is reported to me, I write a job description based on the detailsI’mgiven,"shesays. "Ifthereareambiguitiesinthosedetails, Ihavetoaskthehiring department about them. After I ﬁnish the description, I submit it to the hiring department for it to be checked, then I wait for it to be released.  Sometimes they do that right away, but sometimes they reject it and ask for corrections. In that case, I correct the description and submit it again to be checked.  Once the description is ﬁnally released, I publish the advertisement for the job."
When we collapse Falko’s pool and show Christine’s, the result looks like ﬁgure 4.7.
Hiring department manager
Review notification
Human Resources clerk

Everything clear?
Yes

Write job description

Correct job
description	Advertise job
Vacancy reported

No
Ask for tasks and requirements

Correction requested

Description released

Job advertised
FIGURE 4.7  The post a job process from the Human Resources clerk’s point of view.
124	4  Operational process models
What have we achieved so far?  We have explicitly modeled the operational details of the post a job process.  At the same time, we created two process models that are not overly complicated on their own.
The consumers of our models must have some basic knowledge of BPMN. They must:
■      understand events —intermediate events in particular.
■      understand the difference between a data-based and an event-based gateway.
■      understand the difference between the sequence and the message ﬂow.
The burden on the users of our models is greater at the operational level than it is at the strategic level. The ﬁrst target audience for the operational level is the process analyst, who can use the model as the basis for a detailed analysis as well as for an IT implementation. We show this later. In all likelihood, the process analyst developed the model in BPMN, so his or her understanding of the model can be presumed.
The second target audience is the participants whose work the model represents —Falko and Christine. They should be partners with the process analyst in a dialog about improve-ments,andtheyshouldatleastunderstandthemodels. Youmayﬁndthembothlaterusing the diagrams as a guideline for their work, helping to answer the questions "How should I do my work?" and "What do I have to do next?"
So, will participants like Christine and Falko accept the models? Our experience shows that they will, provided that:
■      Each participant sees only his or her own pool and not the full complexity of the process. This requires that the process model be developed accordingly and an adequate tool used to present it.
■      The participants were provided with a basic brieﬁng on BPMN, and a simple key or leg-end to explain the symbols.  As the process analyst, you probably will have to do the instruction yourself. Tools often provide a key or legend.
Of course we can view post a job as a whole by expanding both pools, and we can show it to Christine and Falko as a detailed collaboration diagram (ﬁgure 4.8 on the next page). But isn’t it obvious how much more complicated this diagram is, compared to separate views of the pools?  Would the process participants be more likely or less likely to accept and use the more complex diagram? In any event, the entire collaboration only matters to the process analyst. In the following two sections, we will deal with collaboration diagrams as we consider process automation.
BPMN provides the option to hide the complexities of the collaboration in a choreography diagram (ﬁgure 4.9 on the facing page).  The advantage is that this represents the inter-action between participants more compactly.  It is therefore good for orienting the pro-cess analyst. On the other hand, a choreography diagram omits internal steps that do not help communication between participants. You can’t see, for example, that the Human Re-sources clerk executes the advertise job task. We regard choreography diagrams as some-times useful additions to operational level collaboration diagrams, but usually they can’t take the place of collaborations.
4.4 Preparing for process automation	125
Report vacancy
Hiring department manager
Personnel
requirement

More information
required

Communicate tasks and requirements

Description
received

Review job description

OK?
No
Yes

Request correction

Release job description

Description
released
Review notification
Human Relations clerk

Everything clear?
Yes

Write job description

Correct job
description	Advertise job
Vacancy
reported

No
Ask for tasks and requirements

Correction
requested

Description
released	Job advertised
FIGURE 4.8  Post a job as a collaboration diagram.
Everything
Manager	clear?	Manager

No Manager

Manager
Request correction
HR clerk

Manager
Correct job description
HR clerk
Personnel requirement

Report vacancy	No
HR clerk
Yes

Ask for more details
HR clerk

Write job description
HR clerk

OK?
Yes
Manager
Release job description
HR clerk	Job advertised
FIGURE 4.9  Post a job as a choreography diagram.
4.4	Preparing for process automation
Describingaprocessfromanorganizationalperspectiveisonlyonetaskofmodelingapro-cess at the operational level. It’s not even the most interesting task! The holy grail actually is the smooth transfer from human to technical ﬂows, in other words, from the functional to the executable process model.
Insection1.1.4onpage5,weshowhowanexecutableprocessmodelcanbeinterpreteddi-rectly by a workﬂow engine to combine human workﬂow with service orchestration. Since this is also central to the IT perspective on BPM, we focus on this approach in the following sections and in Chapter 5 (see ﬁgure 4.10 on the following page). An alternative would be to implement the process logic without a workﬂow engine, but in a general programming language such as Java or C#. That’s a scenario we’ll address in section 4.4.5 on page 132.
4.4.1	Designing for support by a workﬂow engine
The desired technical implementation for a process can be discussed and documented with the models we did for the individual participants. Let’s now consider the participants
126	4  Operational process models
Strategic process model

Content:  Process overview Goal:  Fast comprehension
Semantics:  Logically abstract
Operational process model
Human process flow

Technical process flow

Content:  Operational processes Goal:  Coordinate details between
human process flow and technical process flow (automation)
Semantics:  Physically specific
FIGURE 4.10  We focus on the transfer from human to technical ﬂows.
as users of software, and let’s see what performance they expect from an automated pro-cess.  In this thought experiment, the workﬂow engine itself becomes a participant with which the user exchanges messages.
Falko, as hiring department manager, describes the desired support in the post a job pro-cess:
"I record a vacancy in a form on our portal and then send it. If the job description is ready to be checked, I want to see it in my to-do list on the portal. I process the task by reading the description, and I either request corrections or I release it. After the job advertisement runs, I want a short email notice that everything worked out."
If you remember Falko’s process model from ﬁgure 4.5 on page 123, you will recognize his description, but there are two major differences:
■      The Human Resources Department’s reaction to requests is not to be shown as a task on the portal. It is still processed by email or phone.
■      The conﬁrmation message about successful postings is new.
Now we expand on the process model:
■      We subdivide it into lanes called HR portal and Other.
■      We assign all the tasks to be executed on the portal to its lane. For our purposes, a mes-sage event represents a human task that displays in the task list. A task with an outgoing message ﬂow means that the user has completed a human task. The XOR gateway shows that the task may have different results, such as request correction or release job descrip-tion.
■      The ﬁrst task in the HR portal lane is "report vacancy. This is not a task that was assigned totheuserbytheworkﬂowenginebecauseitdoesnotfollowthecorrespondingmessage event.  It is possible, however, for the user to trigger the process, that is, to effect an instantiation. If so, the workﬂow engine must provide the corresponding option, usually by means of a form available on the portal, which can be ﬁlled in at any time.
■      The request made by the Human Resources Department, as well as the reaction to it, are assigned to the Other lane because neither are realized on the portal, but rather through
4.4 Preparing for process automation	127
Other
Other
the usual channels:  phone or email.  The message conveying that the advertisement was published also belongs in the Other lane. Although the workﬂow engine sends that message, it reaches the user by email, and not as a notiﬁcation in the portal.
The result is in ﬁgure 4.11, which shows the workﬂow engine as another participant, but still with the pool collapsed.
More information required

Communicate tasks and requirements

Advertisement successful
Job advertised
Report vacancy
Hiring department manager
HR portal
Personnel requirement

Description received

Review job description

OK?
No
Yes

Request correction

Release job description
Workflow engine
FIGURE 4.11  IT support of the hiring department’s manager regarding the job posting.
Now we learn something new from Christine, the Human Resources clerk: "A vacancy re-port appears as a new entry in the task list of the HR portal. This is where I write the job description and then forward it to the hiring department for veriﬁcation.  Forwarding it completes the task. If I have to correct the description, that comes up on my task list too. If the hiring department releases the job description, however, I essentially receive notice by the appearance of an initiate advertisement task.  In that case, I specify the advertis-ing channels on the portal and then initiate the advertisement. If the advertisement runs successfully, I want a short notice that everything worked out."
Applying the principles discussed in this chapter results in ﬁgure 4.12, but with one dif-ference:  The user doesn’t trigger the process any more.  Falko already took care of this. Christine only has to react to the new entry in her task list on the portal. You will recognize this by the start event of the message type.
Workflow engine
Vacancy reported
Human Resources clerk
HR portal

Everything clear?
Yes
No

Write job description

Correction requested

Correct job description

Description released

Specify channels for advertisement

Trigger advertisement
Ask for tasks and requirements
FIGURE 4.12  IT support of the Human Resources clerk.

Advertisement
Job advertised
succesful
4.4.2	Required processes of the workﬂow engine
We will now deﬁne the ﬁrst version of the technical ﬂow. As process analysts, we don’t need as much input from the process participants now.  We can turn our attention to the pro-cess engineer. We consult with the process engineer to determine how to implement the
128	4  Operational process models
process with the workﬂow engine. We show the pools of the human participants in a col-laborationdiagram, andweexpandthepooloftheworkﬂowengineasanotherparticipant, dividing the workﬂow engine pool into three lanes:
■      The hiring department manager gets a lane, as does the Human Resources clerk. All the tasks placed in these lanes are user tasks, which is to say, tasks for humans to complete.
■      The third lane is for fully automated tasks. These are things like interface calls (service tasks) or internal program fragments (script tasks).  You can also store whole subpro-cesses in this lane.
The process steps to be implemented in the engine result directly from the behavior of users Falko and Christine. The process starts because Falko reports a vacancy by ﬁlling in a form on the portal. He sends it, which is represented by the start event of the message type. The workﬂow engine then assigns the write job description task to Christine. Once Chris-tine completes her task, the engine assigns the check job description task to Falko.  Falko can either release the description or ask for a correction. Depending on Falko’s choice, the engine will assign either trigger advertisement or correct job description to Christine. If she has to correct it, the job description returns to Falko as another check job description task. This loop repeats until Falko releases the job description.
The engine assigns trigger advertisement to Christine after Falko releases the description. First, she has to specify the channels through which the job is to be advertised, and then she has to initiate the action. This tells the engine that Christine has completed trigger ad-vertisement. The engine then executes the publish advertisement subprocess, which con-sists mainly of interface calls.  (It is encapsulated as a subprocess at this point in order to avoid overloading the diagram.)  At the end, the workﬂow engine sends conﬁrmation emails to both Falko and Christine to inform them that the advertisement was successfully published.
The collaboration diagram in ﬁgure 4.13 on the next page shows the technical process ﬂow, which is executable in the workﬂow engine. There is some redundancy within the diagram because the users are represented in their own pools, but they also have lanes in the pool for the workﬂow engine. This is important for separating responsibilities: The participants always decide on the routing within a pool, that is, they determine which path exits an XOR gateway.
Christine, for example, decides if she can write the job description without further input or if she has to get Falko to clear up discrepancies.  The workﬂow engine can’t do that; it doesn’t even notice this decision. On the other hand, the workﬂow engine does decide if Christine needs to execute correct job description or trigger advertisement next because the corresponding XOR gateway is in its pool. The workﬂow engine makes this decision based on Falko’s decision following his review.
Our collaboration diagram solves a problem that arises frequently when attempting to evolve a functional (operational) process model into an executable one:  mixing control instances in a single pool. As we keep saying, people and workﬂow engines almost always have their respective decisions to make within a process.  Until you segregate control in-stances into appropriate pools, it will be difﬁcult to achieve a model that you can execute in a workﬂow engine.
Another advantage to this approach is that we still can present views optimized for our targeted groups of users:
4.4 Preparing for process automation	129
Workflow engine
Other
HR clerk
More information required
Hiring department manager
Other
Report vacancy
HR portal

Communicate tasks and requirements

Description received

Review job description

OK?
No

Request correction

Release job description

Advertisement successful
Job advertised
Personnel
requirement	Yes
Automatic
Advertisement publishing

Send confirmation of success
Job advertised
Write job description

Check job description

Correct job description
No
Yes

Trigger advertisement
OK?
Hiring
department
manager
Vacancy reported
Human Resources clerk
HR portal

Everything clear?
Yes
No

Write job description

Correction requested

Correct job description

Description released

Specify channels for advertisement

Trigger advertisement
Request tasks and requirements

Advertisement
Job advertised
successful
FIGURE 4.13  Representing the job advertisement in a workﬂow engine.
■      The process analyst can see the entire collaboration diagram. ■      The process engineer can see only the workﬂow engine’s pool.
■      The processparticipants cansee their ownpoolsonly. Notonly are thesepoolsless com-plex than the whole collaboration diagram, but they also contain additional information not part of the workﬂow engine’s pool: that inquiries are made in case of discrepancies, for instance.
Our judgment is that this approach is the only practical way to align business and IT in a BPMN process model.
4.4.3	Further requirements
Could our process engineer implement the process from the diagram as shown? Probably, but there are issues still to be settled, such as the templates to be displayed and the exact tasks in a vacancy notiﬁcation or a job description.  These are typical kinds of require-ments for any software project, however, and they do not affect the process logic. We don’t recommend documenting these requirements directly in BPMN; instead, we suggest link-ing them to the process at appropriate points. That way, the process represents a central starting point for requirements documentation. Of course, your BPMN tool must support linking.
130	4  Operational process models
We have categorized typical requirements as they occur in projects for the development of process applications in ﬁgure 4.14. Besides BPMN, we use graphic screen designs, class diagrams, decision tables, and text to document requirements.  In integration-intensive projects, we use, among other tools, diagrams to describe system landscapes.
Type	Explanation	Examples Functional   Functions to be	- Process logic
provided by the	- Features solution	- Use cases
- Interfaces
- Business logic Non-	Properties to be	- Service level functional    met by the                 Agreements (SLA)
software	- Response time - Capacity
- Maintainability
- Platform compatibility User	Channels through   - Masks
interface	which the user	- Dialog work flows interacts with the     - Mobile devices software	- E-mail roles
Data	Data to be	- Contents processed by the    - Restrictions software	- Formats
- Channels - Mappings
Rules	Specifications	- Validations according to which  - Checks
the software is to     - Calculations decide	- Control points

Notations - BPMN
- UML (use cases) - User stories
- Acceptance tests - General text
- Text
- BPMN
- Mask sketches - User stories
- Acceptance tests - ER diagrams
- UML (class diagrams)
- Spreadsheets
- Spreadsheets - Trees
- Text

BPD link - Task
- Pool
- Task
- Pool
- Data objects
- Task
FIGURE 4.14  Typical requirements for implementing an executable process.
You can see drafts of screens and conﬁrmation emails for the job advertisement process and how they link to the process model in ﬁgure 4.15 on the next page.  Sometimes you can derive the control elements to be provided on the screens from participants’ pools. We know, for example, that Falko can release a job description or request a correction.  That may imply the need for option buttons (also known as radio buttons) on the form Falko sees. Options representing advertising channels may be needed for Christine.
4.4.4	Technical implementation beyond the workﬂow engine
InyourBPMprojects, you oftenwill ﬁndthatyou have to implementcertainsoftware com-ponents beyond the workﬂow engine. For us, this happens most often with:
■      Business logic and rules
■      Screens and screen ﬂows
■      Data transformations
Business logic and rules
Business logic is, for example, a calculation to be programmed. It is appropriate to pack-age the calculations as services so that the workﬂow engine can call them through service tasks. This builds direct reference to the paradigm of service-oriented architecture (SOA).
4.4 Preparing for process automation	131
Report vacancy	Check job description
Internal designation	Key data	Your tasks	Your profile	Dear [Mr./Mrs.] [name],
Mode of	Regular emplyoment:
Tasks (headwords)
Requirements (headwords)

Reference: [ID]
Job designation: [Designation]
Mode of employment: [regular/student/internship]
Contact: [HR personnel]

The reported vacancy [reference, designation] was successfully advertised through the following channels:
- Intranet
- company website - BPM-Netzwerk.de
We wish you all the best in chosing a candidate.
Best regards,
OK	Not OK:     <Your comment>	The workflow engine
Start process	Complete
Automatic
Process
started
Workflow engine
Hiring dept.     HR personnel
manager

Write job description

Check job description

Correct job desciption
No
Yes

Trigger advertisement

Advertisement publishing

Send confirmation of success
Job advertised
OK?
Write job description	Correct job advertisement	Trigger advertisement
Key data	Your tasks	Your profile	Key data	Your tasks	Your profile	Key data	Your tasks	Your profile
Reference: [generated ID]
Job designation:     [Suggestion by specialist dpt.]
Mode of employment: [regular/student/internship]
Contact: [current user]
Complete

Reference: [ID]
Job designation:    [designation]
Mode of employment: [regular/student/internship]
Contact: [HR personnel]
Comment by specialist department

Reference: [ID]
Job designation: [designation]
Mode of employment: [regular/student/internship]
Contact: [HR personnel]
Select channels
<Comment>
Complete

Intranet
Schrittstein.de
Complete

Company website
BPM-Netzwerk.de
FIGURE 4.15  Drafts of screens and email for job advertisement.
Businessdecisionscanberepresentedinadecisionengine,andtheycanbecalledfromthe workﬂowenginethroughcustom-developed, business-ruletasks. Wedealwiththissubject in section 4.5.6 on page 144 and section 6.2.5 on page 174.
In either case, it usually makes sense not to model the respective requirements fully in BPMN. A better solution is simply to reference business logic or rules in the process dia-gram through service or business rule tasks.
Screen ﬂows
Screen ﬂows are a borderline case because, from the process automation perspective, they serve only to execute a single task. It also is difﬁcult to do if the sequence of screens varies with the entries a user makes or with the data established between screens. Screen ﬂows, however, are also processes. UML activity diagrams have been used often to model them, which suggests that BPMN can as well.
Clean BPM architecture strictly separates screen ﬂows from the process model.  In other words, a workﬂow engine is only loosely coupled to a screen ﬂow application by means of clearly deﬁned interfaces.  To be consistent about this, you have to deﬁne a separate pool for the screen ﬂow application and link it to the workﬂow engine and to the user with message ﬂows. From the application’s perspective, each screen ﬂow is an isolated process.
132	4  Operational process models
If your process contains several screen ﬂows, you must create a separate pool for each one, even though the same screen ﬂow application controls them all.
If that seems too complicated, or if your workﬂow engine combines the screen ﬂow control with the executable process model, you can set it aside and model the screen ﬂow as a collaboration between user and workﬂow engine. We can’t recommend doing so, however, because it leads to process models that are less serviceable and more error-prone. It may be a good compromise to package screen ﬂows in an embedded subprocess.
Data transformations
Data transformations are required primarily in integration-intensive processes.  A clean BPM architecture requires that the process model be decoupled from the details of the interface calls.  At this point, the Enterprise Service Bus (ESB) comes in, and you should represent it as a separate pool and handle it as you would a screen-ﬂow application. You can likewise integrate these steps directly in the process model of the workﬂow engine by working with script tasks.
Script tasks represent internal steps of the workﬂow engine. Data transformations are an example. You could wrap the data transformation in a service and call it through a service task. The difference is that the transformation engine (an XSLT processor that transforms XML data, for instance) would be a component internal to the workﬂow engine if it were a script task. It would be provided by an external component —that is, from the perspective of the workﬂow engine —if it were a service task.
4.4.5	Technical implementation without workﬂow engine
Perhaps you don’t use a workﬂow engine to execute the technical process ﬂows. Perhaps you program it in Java, C#, or another classic programming language. This doesn’t matter for the transition from the strategic level to the operational; your compiler or interpreter equates to the workﬂow engine. Doing without a workﬂow engine may mean that you can-not execute the process logic directly from an operational process model.  Another spec-iﬁcation —called requirements speciﬁcation, or detailed technical speciﬁcation —will be required instead before the implementation. The process diagrams developed at the op-erational level can be integrated in this IT speciﬁcation to form the basis of the technical design.
In conventional software development, requirements are often established without an end-to-end perspective of a process. Instead, they provide a compilation of functions that a user executes in a speciﬁed order, depending on the process to be carried out.  These functions can be deﬁned as applications or use cases in the design phase, which brings us to the classic domain of the Uniﬁed Modeling Language (UML).
You can apply BPM and our framework to such projects, but remember that each use case represents an independent process. You have to deﬁne a separate pool for each use case. Compared to implementing in a workﬂow engine, the user has responsibility for linking the use cases into a process that could be represented in a single pool.
Occasionally, the same use case can apply to different scenarios. We recommend modeling the respective roles as simple processes that package the use cases as subprocesses. Fig-
4.4 Preparing for process automation	133
ure4.16 showstwo examplesofthatprocedure. Betweenthepools, you seeaUML usecase diagram that joins the use cases. This is an example that shows UML and BPMN working well together. Figure 4.17 on the next page shows the fully modeled login use case.
Recommendable?
Reader
Read professional article
Login
Interested in article

Search for article

Read article	Yes
No

Recommend article
Knowledge portal
Login
Search for article
Reader	Recommend article

Publish article
Editor
Discuss subject	Write article	Login	Publish article
Editor
Produce professional article
Every 2 weeks
FIGURE 4.16  Deriving use cases from process models.
We can state as a principle that BPMN can beneﬁt conventional IT projects compared to other process notations.  As we pointed out earlier, however, BPMN was not developed for that purpose but rather to support projects with a workﬂow engine in mind. Perhaps the more important point is that it makes little sense to do process-intensive IT projects without a workﬂow engine.
134	4  Operational process models
User
Login
User
Error message
Enter user name and password

Login failed
Personal welcome page
Logged in
Show personal welcome page

Show error message
Select from database
Knowledge portal
Login
System

Yes
No
User found?
FIGURE 4.17  The login use case as a fully modeled collaboration of user and software.
4.5	Hands-on tips for the operational level
4.5.1	From the happy path to the bitter truth
The First Pass Yield and BPMN
The ﬁeld of organizational process management deﬁnes First Pass Yield (FPY) as the "per-centage of units that meet speciﬁcations in the ﬁrst process run without need of rework or repair."
You can well imagine that a major goal of process optimization involves maximizing FPY. Traditional organizational process consultants have applied various analytical methods successfully for years, but these methods are based on key ﬁgures such as error rates or processing times.  Such measures have to be either estimated or manually established in organizational process management, methods that are laborious and error-prone.
Wouldn’t it be exciting to integrate the FPY concept into the world of modern BPM (and BPMN)? After all, key ﬁgures can be measured with comparative ease, precisely, and in real time by a workﬂow engine.
To accomplish this integration, ﬁrst understand how the FPY approach works in traditional sequence notations. Look at the sequence plan process model in ﬁgure 4.18 on the facing page, which is suitable for FPY analysis, and which we compare to BPMN in section 2.12.3 on page 91).
Notice that there is a main path running from the top left straight down to the result. Any-thing that needs a change follows the correction path. We can assume that the main path is thepaththattheprocessmanagerdesires; itisalsoreferredtoasthehappypath. Theprob-ability that a result is not okay and needs correction is 30% in this model. Conversely, 70% of the results do not need correction —that’s the FPY. We can analyze key ﬁgures recorded
4.5 Hands-on tips for the operational level	135
Produce result
Check result
Result okay?

45 min
15 min
No (30%)
Yes (70%)
Deliver result	20 min	Correct result	30 min
FIGURE 4.18  A process as a sequence plan with a correction branch.
with the tasks, such as processing time, by various analytical methods to assess Key Per-formance Indicators (KPI). In this simple example, we could state three things about the running time of the process:
Variant
First Pass Yield Worst Case
Average

Time 80 minutes
110 minutes
89 minutes
The average here results from the calculation: (FPY * 0.7) + (worst case * 0.3) = 56 + 33 = 89 minutes. This is also called variational calculation, for which a non-iterative procedure is applied for simplicity. The assumption is that the result must be corrected only once, if at all, per instance.
Could we apply the FPY approach in BPMN? Generally, yes. We showed in section 2.12.4 on page 91 how to store calculated key ﬁgures and average running times in process diagrams. Our job advertisement case has two possible correction loops:
1.  When the vacancy report is not sufﬁcient for Christine’s purposes, she has to ask Falko for clariﬁcation. We assume in the process model that this is required only once.
2.  When Falko does not like the job description, he asks Christine to correct it. According to the process model, this loop could repeat inﬁnitely. We would apply a non-iterative method to assess the key ﬁgures.
We modeled the job-advertising process at the operational level from three perspectives, so we should apply the FPY methodology to three different pools for Falko, Christine, and the workﬂow engine. If we show the process from end to end in the workﬂow engine, it will be enough to examine its pool to apply the FPY approach.
The collaboration diagram (ﬁgure 4.13 on page 129) shows clearly which parts of the pro-cess are directly captured by the workﬂow engine’s measurements and which are not. We derive this knowledge from the process modeled in its pool:
1.  The workﬂow engine can measure the running time of these tasks: write job descrip-tion, check job description, correct job description, and trigger advertisement; and of the advertisement publishing subprocess.
2.  It can also measure the number of times the job description needs to be corrected.
136	4  Operational process models
Youcananalyzethesekeyﬁgureswithanappropriatereportingengine. (Or,whenindoubt, just use Microsoft Excel for a deﬁned number of process instances, average them, and cre-ate colorful diagrams to make your top managers happy.) But we also see which steps the workﬂow engine cannot measure. It doesn’t see the times that Christine has to repeat her request for clariﬁcation to Falko. It therefore can’t record the rate of occurrence for these necessary correction loops nor can it store that information for analysis. It also does not know how long a clariﬁcation takes. From the engine’s point of view, all this is part of the write job description task, which it assigned to Christine. This may lead to distorted mea-surements.  You need to be aware of distorted measurements, and of the three ways to handle them:
1.  Accept the distortion.  After all, you know it is limited to the write job description task only.
2.  Estimate the rate of necessary clariﬁcations and their average time.  Enter these esti-mates by hand into the database. (Of course, now you have adopted the same practice and the same disadvantage as conventional organizational process management.)
3.  Represent Christine’s inquiries as a human workﬂow in the workﬂow engine. Then you can measure and analyze the respective rates and times in a differentiated manner. The risk is that neither Christine nor Falko will be thrilled by this idea, and they may simply bypass the workﬂow engine and settle their questions with a more efﬁcient phone call.
As you can see, process automation is a powerful instrument for process control, but you should be wary of overusing it. We hope you’ll also see that BPMN helps us to recognize these limits in time and to prepare for them.
On the other hand, we have to understand that BPMN in its raw form does not provide sufﬁcient support for process analysis based on key ﬁgures.  You can only do this with a powerful BPMN tool that takes in the key ﬁgures —ideally from the workﬂow engine —and aggregates them for functional analysis. It can do this usefully because you are a master at producing consistent process models.
Explicit modeling of errors
Unlike other notations, BPMN explicitly models errors with event types (section 2.6.4 on page 51). It is only a question of when to use them. In the last section, we discussed cor-rection loops that apply only in case of errors. You would not want to use error events in those cases, because you want to reserve error events for representing activities that can-not complete successfully. If an activity can complete, but the result differs from what was expected, that’s different. It isn’t always clear what every situation calls for, and there can be gray areas. Let’s look at a simple example.
Order processing
Order received

Check completeness

Check creditworthiness

Check delivery date

Fax order confirmation

Order confirmed
FIGURE 4.19  Happy path order processing.
4.5 Hands-on tips for the operational level	137
Figure 4.19 on the preceding page shows the happy path for order processing.  There are four steps: For a new order, the order processor checks the order form for completeness, then he or she checks the customer’s credit. The date of delivery is checked, and ﬁnally, the processor faxes a conﬁrmation.
Now we imagine what can go wrong, what the response is going to be in each case, and how to represent these possibilities in the process model. To think it through, we start at the end and work backwards. The happy path result was that the order was conﬁrmed, so what could lead to the order not being conﬁrmed? Yes, theoretically, anything can happen —even an earthquake —but practicality suggests that we deal in events with higher levels of probability. We decide on the following:
1.  The order details are incomplete.
2.  The order details are illegible.
3.  The customer ID is wrong.
4.  The customer has insufﬁcient credit.
5.  The ordered item is not available.
6.  When faxing the order conﬁrmation, someone answers the phone and asks our fax ma-chine if the call is supposed to be a bad joke.
Result?
Task	OK
Error	Not OK
FIGURE 4.20  Representing possible (and probable) problems in the process.
How would we model these contingencies in the process?  As shown in abstract in ﬁg-ure 4.20, a task either provides us with a result, that is, information that we can assess as OK or not OK, or there is no result, and the task can’t complete at all. If we have the infor-mation to assess, we can model an XOR split after the task. If the task can’t complete, this is the time for an error event. For each of the possible problems we’ve deﬁned, we can now construct error-handling solutions. See the fully modeled process in ﬁgure 4.21 on the next page.
■      The order details are incomplete.
This is simple: The check for completeness succeeded, but the result is that the order is incomplete, so processing follows the XOR split after the task to reject order.
■      The order details are illegible.
How can you check for completeness when the order is illegible? This isn’t as obvious as when the order details are plainly incomplete, but the result is the same.  If we cannot read the details, they don’t exist for us.  The order is still incomplete.  (Though may be helpful to explain to the customer why his or her order was rejected.)
■      The customer ID is wrong.
138	4  Operational process models
Complete?	Creditworthy?
Order received
Order processing

Check for completeness

Yes    creditCwhoertchkiness
No	Customer ID	No wrong

Check delivery
Yes	date
Not available

Fax order confirmation
Fax number wrong

Order confirmed
Find out correct fax number
Reject order
Order rejected
FIGURE 4.21  Representing possible alternatives to the happy path.
Unless we can validate that the customer has the correct customer ID, we can’t make much more progress on the order. This is a clear case for an attached error event.
■      The customer has insufﬁcient credit.
If our process successfully checks credit, butthe resultisunfavorable, the resultprevents the order conﬁrmation. The XOR split after the task sends the order to reject order.
■      The ordered item is not available.
This is not so easy, which is why you need to be pedantic. If the item is not available, no delivery date can be established, so no check of the delivery date can succeed if the item is not available. We have to attach an error event.
■      When faxing the order conﬁrmation, someone answers the phone and asks our fax machine if the call is supposed to be a bad joke.
You can probably guess how to represent this.
You may be asking yourself why it’s necessary to differentiate between error events and XOR gateways at all. Why not just show all error cases by means of XOR gateways as other process notations do?  BPMN cannot keep you from doing that, but we recommend the differentiation because:
■      Most people who design processes in the target state consider only some of the possible problems. They model these in check tasks and downstream XOR gateways. But when it comes time to implement the process, the IT people come back with questions no one has taken into account, very often concerning situations that keep the check tasks from completing successfully. As part of the required ping-pong between business and IT, we document these questions with attached error events, and then we answer them speciﬁcally. Frequently, when obtaining the answer to such a question, new check tasks developupstream,alongwithadditionalXORgateways. Ifyouplacedacheckavailability task before the check delivery date task, for example, you could make the error event at check delivery date obsolete.
■      Can you ensure processes with error events in case anything goes wrong? Yes. You can deﬁne this kind of extra safety net with an attached error event for a section within a process, or for an entire process.
4.5 Hands-on tips for the operational level	139
■      In general, XOR gateways differentiate between cases.  They can differentiate between error conditions, and they can differentiate also between or among positive outcomes. An example would be the different steps to determine correct size depending on if the customer has ordered trousers versus a hat. So a happy path may not exist without XOR gateways, but positive XOR gateways cannot be differentiated visually or syntactically from the error XOR gateways.  Error events are visually less ambiguous.  Provided you have the appropriate tooling, you can even use them to switch between a simpliﬁed, happy path view and the complete view of the process.
The bottom line: Error events can be a good aid when modeling processes, and you should make use of them.
4.5.2	The true beneﬁt of subprocesses
Bynow,youknowtheseverallevelsofourBPMNframework,andhowthelevelsusemodels with different amounts of detail. At the operational level, we also work with different views of the same process to show only the aspect of the model that is most useful to the people affected.
Have you wondered what role the BPMN symbol for subprocess plays in this framework? We show in section 2.8 on page 66 that subprocesses have three main purposes in BPMN:
■      To hide the complexity of detailed sequences.  Collapsed subprocesses make diagrams more clear.
■      To make sequences modular, and thus reusable.
■      To deﬁne a scope within a process and then deﬁne how the process reacts to catching events for the scope by attaching the events.
You can beneﬁt from all these advantages for both strategic and operational process mod-els. For instance, in the process model for Job advertisement, we deﬁned the publish ad-vertisement subprocess in the technical ﬂow, that is, in the workﬂow engine’s pool.  This avoided overloading the diagram with interface calls (ﬁgure 4.13 on page 129).  Another option would be to deﬁne error processing for the entire subprocess by attaching an error event. Because we likely won’t need this subprocess later, we should not deﬁne it as global in our BPMN tool.  Because the subprocess is embedded, and no longer an independent module, it can be collapsed for clarity.
In BPMN, subprocesses are seldom used to indicate organizational reﬁnements of a pro-cess. This is why we often mix tasks and subprocesses in the same diagram. Some process modelers who’ve trained in other methods may see this mix as an improper or unattractive mixing of granular levels. They may prefer to reserve subprocesses for reﬁning content, or they want to organize their process models by making all subprocesses equally complex. As far as BPMN is concerned, we say forget that! These other views of subprocesses make sense, if at all, only at the level of process landscapes, and that is removed from the exam-ination of individual processes.  In your process maps, you can make wonderful process groups or clusters.  You can even organize them hierarchically —but don’t do that when dealing with an individual end-to-end process.
To be effective with BPMN, it is important to understand that subprocesses are a purely technical construct.  They cannot be assigned any content-related degree of complexity.
140	4  Operational process models
Job Advertisement
Workflow engine
Hiring
department
manager
HR clerk
You can deﬁne a sales subprocess as easily as one called tie shoelaces. Collapse both sub-process within the same diagram —it’s all good.
While it is highly probable that more subprocesses are deﬁned at the strategic level than at the operational level in our framework, this isn’t obligatory.  You can apply both these levels of our framework to ﬁnely granular processes of any type.  The framework merely facilitates transition from a general, result-oriented process representation (organizational implementation) to the actual technical implementation. Just like tasks, subprocesses can help at every level.
4.5.3	Slice processes according to your domain boundaries
In section 1.6 on page 19 we have already introduced the trend towards microservices and "bounded contexts". The resulting system boundaries must be taken into account in oper-ational models.
In our example, the job advertisement could be a microservice.  The publication of the job advertisement on different online platforms could be part of its responsibility, but per-haps this is better done in a microservice on its own. After all, it can be highly complex to communicate with different online marketplaces. This design is even advantageous if you decide to replace this service with an existing cloud service in the future.
We can model the collaboration at a glance in BPMN, as shown in ﬁgure 4.22. The publi-cation is now a separate technical ﬂow, which is not only located in another microservice, but could also be implemented by other means.
Automatic
Advertisement publishing

Send confirmation of success
Job advertised
Write job description

Check job description

Correct job description
No
Yes
OK?

Trigger advertisement
Publish job ad on
MajorJobs.com	MajorJobs.com
Publishing
Workflow Engine
Publishing requested

Publish web site      comjobpaandyowneb
site	Published
Blog
Publish job ad on blog

Publishing successful
FIGURE 4.22  This collaboration model respects given system boundaries, like in microservice architectures.
Sometimessuchacollaborationmodelishelpfultounderstandthepingpongbetweenmi-croservices. We have also seen that the exact boundaries are only really discussed and de-ﬁnedwhendealingwithsuchamodel. Nevertheless,youdon’thavetocreatesuchamodel. And if you do, you might want to throw it away after these workshops. The maintenance is
4.5 Hands-on tips for the operational level	141
too expensive and the responsibility for this work is not deﬁned. The real implementation projects relate to the individual microservices, meaning only one of the technical ﬂows. If you take care of the job advertisement, you will see the publication of the advertisement as one of many services that you call via some API. It is a black box to you, and that’s exactly how it should be.
In this way, an end-to-end business process is divided into smaller pieces that ﬁt exactly into the context of microservices. In this way a BPMN monolith can be avoided, which we already warned against in section 1.6 on page 19.
Let’s be clear: Of course a monolithic process can also make sense, namely exactly when you are designing a monolithic system.  Although "monolith" is mostly seen negatively today, it is often still valid and even the easiest way to build an application, especially if exactly one development team can take care of the whole application.
4.5.4	The limits of formalization
BPMN is based on the assumption that we can deﬁne the course of a process as an unam-biguous control ﬂow. The more precisely we model the desired process in BPMN, the more narrowly we deﬁne the range of people’s action within the process. A total application of this paradigm would be, to put it bluntly, to turn any process into the equivalent of an in-dustrial assembly line in which the work of people is planned down to the most minute detail and which leaves no room for them to maneuver. This approach is not always pop-ular. Various Internet forums discuss this topic in ideological terms, with people opposing the paradigm on humanist grounds, standing up against the increased technocratization of society.
Wewillnotengagewiththatdiscussioninthisbook, butwewillmakeonepragmaticpoint: In many of the BPM projects in which we have been involved, we have had to leave white spots in the process models. White spots are what we call sections in a process or subpro-cesses that cannot be clariﬁed unambiguously. There is a negative and a positive aspect to this:
■      On the negative side, there is often uncertainty about exactly how the subprocess is or should be carried out. The knowledge is just not (yet) available for various reasons. This is something we are seeking to change.
■      On the positive side, the subprocess may be carried out perfectly well, but the knowl-edge related to it resides in the heads of the people carrying out the subprocess —and is therefore of an implicit nature —which we can accept.
In the ﬁrst, negative, case of a white spot, we are left with the need to document an un-desired intermediate state when modeling the process. In the second, positive, instance, it is our place to document the desired ﬁnal state. In either case, you have already seen a BPMN design in section 2.8.4 on page 73 that can help us; the ad hoc subprocess as shown in ﬁgure 4.23 on the following page.
Ad hoc subprocesses are a sort of carte blanche for the process analyst. They capture the tasksthatcanbecarriedoutinanon-bindingfashionwhiletheyarebeingworkedthrough. How often this occurs, in what order, and whether they are executed at all is completely up to the participant. An ad hoc subprocess also lets you draw a boundary around an area that
142	4  Operational process models
Travel preparation
2 days before traveling date

Turn off heaters
Leave keys with the neighbors

Write out-of-office email
...
Pack suitcases
~
FIGURE 4.23  Preparing a trip can consist of these task, although it does not have to.
remainsunclear while you continuetospecify theremainingprocessaroundit. Theadhoc subprocess is a tool we have often been grateful to have during our BPM projects.
Ad hoc subprocesses, however, can only rarely be executed in an engine. So check this with the vendor of choice or consider alternative approaches to implement these unstructured phases.
4.5.5	Flexibility in BPMN models
BPMN allows you to model a certain degree of ﬂexibility for individual process instances. In our practical projects, some samples have proven themselves, which we would like to present here. Basically, this always revolves around the meaningful use of events.
Imagine a simple order fulﬁllment process for an industrial company that processes large orders and does a lot of manual checks. For example, a customer check, including a sanc-tionscomparison, cantakeseveraldays. Duringthistime, theordermaybechangedagain, so it must be checked again. This can easily be modeled as shown in ﬁgure 4.24 with a non-interrupting condition event.
&KHFNFKDQJHV
2UGHU FKDQJHG
&KHFN RUGHU
2UGHU UHFHLYHG

6FKHGXOH &KHFNFXVWRPHU	SURGXFWLRQDQG
VHWGHOLYHU\GDWH

*RRGV VHQW
2UGHU GHOLYHUHG
FIGURE 4.24  This BPMN model uses a non-interrupting condition event to trigger a reorder check only if necessary.
Nowyourcustomermightwanttocancelhisorder,whichyou,asacustomer-friendlycom-pany, naturally want to allow. However, customer friendliness has its limits, because if pro-duction has already started, you would rather ﬁrst ask what costs a cancellation will incur. Figure 4.25 on the facing page shows a possible implementation in BPMN: If a cancellation
4.5 Hands-on tips for the operational level	143
request is received, an event sub-process is started. As you may remember from chapter 2.6.1,thedashedeventisnon-interrupting. Thismeanswelettheorderrunnormallywhile we clarify the cancellation in parallel. For example, we learn that what’s been produced so far are things we can safely put in stock.  Therefore, we conﬁrm the cancellation and the process runs into the error end event. This error starts an interrupting event subprocess, meaning we cancel the order handling process.
&KHFNFKDQJHV
2UGHU FKDQJHG
&KHFN RUGHU
2UGHU UHFHLYHG

&KHFN FXVWRPHU

6FKHGXOH SURGXFWLRQDQG VHWGHOLYHU\GDWH

*RRGV VHQW
2UGHU GHOLYHUHG
&DQFHOODWLRQ UHTXHVWUHFHLYHG

$SSURYH FDQFHOODWLRQ

&DQFHOODWLRQ FRQILUPHG"
\HV
QR

$GMXVW SURGXFWLRQ VFKHGXOH

&DQFHOODWLRQ UHTXHVWHG

&DQFHOODWLRQ UHTXHVWHG

2UGHU FDQFHOOHG
&DQFHOODWLRQ UHMHFWHG
FIGURE 4.25  This BPMN model can process a cancellation request at any time, but only cancels the order process if the cancellation is conﬁrmed.
By the way, a classic for ﬂexibility is the status inquiry about orders.  You can also model this in the ordering process as shown in ﬁgure 4.26. Similarly, it is also possible to model additional actions of the employee at any time, for example because he wants to initiate a feasibility check or start customs clearance for complex deliveries. You may already know this pattern from timer-controlled event sub-processes to start an escalation path.
&KHFN RUGHU
2UGHU UHFHLYHG

&KHFN FXVWRPHU

6FKHGXOH SURGXFWLRQDQG VHWGHOLYHU\GDWH

*RRGV VHQW
2UGHU GHOLYHUHG
,QTXLU\ UHFHLYHG

5HVSRQGWR LQTXLU\

6HQGVWDWXV UHSRUWWR FXVWRPHU
(YHU\GD\V
FIGURE 4.26  Parallel paths like inquiries are easy to model.
As you can see, the BPMN provides you with tools to allow ﬂexibility in process instances. In our projects, these simple patterns have proven very successful and can already cover a large part of the requirements. Of course this has limits and you should accept if a process
144	4  Operational process models
is too unstructured to be captured with BPMN at all. In this case, as already mentioned in section 4.5.4, you can use the ad hoc subprocess.
4.5.6	Taking business decisions out of processes
In section 4.5.1 on page 136, we looked at the receiving order process, and discussed what mistakescouldoccurwhileworkingthroughit. Weaskafurtherquestionnow: Underwhat circumstances should a customer’s creditworthiness be examined? If we assume that this question depends on certain facts about the customer and on the total order value, then we deﬁne the ﬁrst step in the process as being check order data. After that, we can decide if a credit check is necessary. (See ﬁgure 4.27.)
Order processing
Check order details

Credit to be checked?
yes        Check credit

Check delivery date

Fax order confirmation
Order
received

no	    Order confirmed
FIGURE 4.27  Receiving an order and examining the customer’s credit under certain circumstances.
Now we have to deal with the speciﬁc conditions in which we carry out a customer credit check. Let us assume the following:
■      Credit has to be checked if the order value exceeds 300,000 EUR.
■      If the customer is new to our company, credit must be checked if the order value exceeds 50,000 EUR.
■      If the customer is categorized as a Class A customer, there is no need for a credit check.
Customer?
Check order details
Order processing

Order value?
New customer

 50,000 ¼	Check credit

Check delivery date

Fax order confirmation
Order received

Other regular customer
Class A
customer

otherwise
Order value?
> 300,000 ¼
otherwise
FIGURE 4.28  Conditions which lead to checking a customer’s credit.
Of course we can model these conditions completely in the process diagram.  We have done so in ﬁgure 4.28. What do you think of this diagram? Can you imagine adding further conditions that only apply to certain customers? Sure, but perhaps you’re also thinking of the problems those extra conditions imply:
■      Every additional condition further inﬂates the diagram with more gateways and addi-tional sequence ﬂows.
■      This inﬂation problem becomes even more pronounced if the additional conditions are interlinked (for example, both more customer types and more levels of order value).
4.5 Hands-on tips for the operational level	145
■      The process diagram quickly becomes excessively confusing.
■      Ifconditionschange—newonesareaddedoroldonesareremoved—thediagramhasto be adapted accordingly. That will be a time-consuming mess while rearranging symbols and sequence ﬂows.
■      If the customer’s credit also has to be checked as part of other processes (within a non-bindingrequest,forexample),theconditionswillhavetobemodeledredundantly—and then maintained.
This way of dealing with complex decisions is absolutely not best practice; rather, it is a classic mistake in process modeling. To avoid it, we need to understand such conditions as business decisions and to separate them from the routing decisions implemented by gate-ways.
Dealing with business decisions is a discipline in its own right.  As the name implies, it’s about making (often complex) decisions. The conditions on which the decisions are based determine which tasks we carry out and which tasks we omit. Being able to manage con-ditions centrally, simply, and ﬂexibly is absolutely vital to the success of process manage-ment. Forprocessmodeling, wethereforehavetoﬁndawaytoseparatebusinessdecisions from routing decisions.
To do this, we should ﬁrst select a suitable medium for modeling decisions. This is where (you guessed it) the DMN standard comes in. We detail DMN in section 5 on page 149, so we’ll only discuss one element here: the decision table.
A decision table for the question of whether the customer’s credit should be checked could look like the one in ﬁgure 4.29.
Conditions
Customer type	Order value

Decision Check credit?
Class A customer
Other regular customer
New customer

Irrelevant                    NO > $ 300,000                  YES ≤ $ 300,000                  NO ≥ $ 50,000                   YES < $ 50,000                    NO
FIGURE 4.29  Decision table for the question of checking credit.
How can we now link the decision table with the process model? To do so, we can use the business rule task as shown in ﬁgure 4.30 on the next page:
■      We introduce a business rule task Apply set of rules in front of the XOR gateway. We do so only so we can apply the modeled decision table.
■      The result of the business rule task is the decision to check or not to check credit.
■      The XOR gateway refers only to this decision, and it leads to the corresponding process ﬂow.
■      The link to the decision table is carried out directly in the task and at the attribute level.
The link displayed between the business rule task and the decision table is not part of the standard notation.  It is something that has to be supported by your BPMN tool.  At the time the BPMN standard was created, no DMN standard yet existed, so OMG deliberately left open the question of the link. It is becoming apparent, however, that software vendors
146	4  Operational process models
Credit to be checked?
Order processing
Order received

Check order details
Set of rules “Credit to check“

Apply set of rules

yes	Check credit
no

Check delivery date

Fax order confirmation
FIGURE 4.30  Receiving an order with reference to the decision table.
offeringcombinedsolutionsforBPMNandDMNseethebusinessruletaskasthepreferred way of referencing DMN models from BPMN models.
Let’s take a moment to contemplate the difference between the two decision types:
■      Routing decisions are carried out by XOR gateways, OR gateways, or conditional se-quenceﬂows. Theyaresimpleinprincipleandrepresentexactlyasmanypossiblecondi-tions as there are outgoing ﬂows. The process model therefore stores routing conditions directly.
■      Business decisions can be extremely complex, and they are routinely managed outside of the process model.  A modeled decision, however, can serve to determine relevant conditions for routing.  For example, the business decision to check credit is based on the type of customer and the order amount. It has to check a total of ﬁve combinations of conditions. It can only generate two possible results: Yes or No. These are precisely the two possibilities to which the corresponding routing decision in the XOR gateway of the process model refers.
Theoretically, the condition event can be linked to business decisions. Unfortunately, the BPMN speciﬁcation has little to say about this.  From a technical point of view, it can be interpreted as a decision engine constantly checking if a condition stored with the event is taking place. Then, if it takes place, the decision engine reports it to the workﬂow engine, and the workﬂow engine evaluates the event as having occurred.  The workﬂow engine either launches or continues the process accordingly (see ﬁgure 4.31 on the facing page).
For business-IT alignment, it is important that you understand the basic principle behind this structure because it is in no way limited to technical implementations!  We have the same problem when we think of the purely organizational implementation of the process. In our company, we have to abide by certain rules —legal requirements or safety regula-tions, for instance.  Someone has to be alert to situations to which the rules may apply. If they occur, something has to be done —a process has to be launched.  Conversely, the process may be launched or continued only once a pre-deﬁned condition has occurred.
From our point of view, the systematic management of decisions, the so-called Business Decision Management (BDM), is an elementary building block of Business Process Man-agement (BPM). In BPM, we ask ourselves the most fundamental questions, such as "What
4.5 Hands-on tips for the operational level	147
Workflow engine
Condition xy occurred
Decision engine
Check
Every X seconds

Condition xy met?
Inform workflow
Yes	engine
No
FIGURE 4.31  Condition event and decision engine.
does our company need to do to succeed?" The answer may be many different things, but surely one of those things is to make the best possible decisions as effectively as possible.
5
5.1

DMN - Introduction and overview
Understanding DMN
DMN is short for Decision Model and Notation. Like BPMN, the DMN standard is managed by OMG. Unlike BPMN, DMN is not about activities or processes. It does, however, work along the same lines: Decisions can be modeled by the business user, and the modeled decisions can be implemented in a decision engine. Just as with BPMN, the DMN standard speciﬁcation contains both a verbal description of the notation as well as an XML-based, formal metamodel. We refer to DMN version 1.2, the version current as we wrote this book. This version also introduced a way to store graphical layout information within the XML ﬁle.
A decision according to the DMN deﬁnition means deriving a result (output) from given facts (input) on the basis of a deﬁned decision logic.
Thetopicofmodelingandautomatingdecisionsisnotnew. WhenitwasknownasBusiness Rules Management and Rule Engine, it never took off. We think this was because the tools were both proprietary and fairly bulky. These hindrances are being lifted by a new genera-tion of tools as well as the agreement on the DMN standard. This is providing new impetus towardsystematicdecision-managementorBusinessDecisionManagement (BDM).Weex-pect DMN and the corresponding decision engines to spread rapidly.
BDMcanbebroadlyapplied. Sometimes, compliancerulesmakecarefulanalysisanddoc-umentation of the decision-making process necessary. More often, however, the main fo-cus of the work is about automating operational decisions using a decision engine. We’ll take a closer look at that in section 6.2.1 on page 171.
DMN deliberately focuses on operational decisions and not strategic ones. It is about the many routine decisions that need to be made repeatedly every day. The big issues, such as if your company should introduce BPMN or DMN, are unique and often do not follow set rules; that’s why modeling them is not worthwhile.
Typical examples of operational decisions are:
■      Feasibility check or authorization, such as if a customer qualiﬁes for a certain product or if a claim can be regulated automatically.
■      Validation,tocheck,forinstance,ifanapplicationoranotiﬁcationofaclaimiscomplete and its content is valid.
150	5  DMN - Introduction and overview
■      Fraud detection, for example, if a credit-card payment or notiﬁcation of claim is suspi-cious.
■      Risk assessment, as in if a credit limit is exceeded or an invoice amount can be autho-rized.
■      Calculation. Examples include estimating shipping charges and determining discounts.
■      Assigning. Think of skills-based routing.
■      Maximization, to evaluate the business value of an assignment, for instance, to deter-mine the correct priority or most appropriate customer classiﬁcation.
■      Addressing target groups, an example of which is determining products or advertising banners that may be of interest for a certain user.
In this book, we use the following terms in keeping with the DMN speciﬁcation. Decisions dependondecisionlogic,whichisdeﬁnedbyanumberofrules,andtheseoftenarelistedin a decision table. The rows in a decision table as well as conditions —we will detail Friendly Enough Expression Language (FEEL) expressions later —are therefore rules, and a decision table is a set of rules.
Decision logic
Decison table

Decision requirements
Expression language (FEEL)
if  GuestCount  in [5..10]
then Meal  =
GuestCount  * PastaBasicReceipt

Beverages
Children present?
Meal
Season	count
Guest
FIGURE 5.1  Elements of the DMN standard.
Figure 5.1 gives an overview of the content of the DMN speciﬁcation.  In this book, we offer an introduction to DMN, but we focus on those elements that, from our point of view, are most relevant to its practical application.  We believe this will be sufﬁcient to get you started.
5.2 Notation elements	151
5.2	Notation elements
5.2.1	Decision tables
Decision tables are the central element of the DMN speciﬁcation. They are the means for achieving business-IT alignment. They are fairly intuitive: The left-hand columns contain theconditionsandtheinputvalues(input),andtheright-handcolumnscontaintheresults (output). Each row corresponds to a single rule. When the condition on the left-hand side is met, then the result on the right-hand side is passed back.
Decision tables should always remain readable for the business. Technical terms, such as mapping against certain types of data, are hidden in the background. Conditions can be expressed in the FEEL expression language.
Hint: Business-IT-alignment
Decision tables have the great advantage of being easily understood by most business users, yet suitable decision engines can execute the tables directly.  Business-IT align-ment in this area is therefore fairly easy to achieve. Make the most of it!
Let’s look at an example. Assume that you want to make an extremely important decision: what meal you’re going to cook. The selected meal is therefore the desired result. What are the inputs? Well, that could depend on the time of year, and it could lead to a decision table such as in ﬁgure 5.2. (Yes, eating asparagus all spring could get tedious, but we’re only just getting started with DMN.)
Meal
U	Season
1     "Spring"
2     "Summer" 3     "Fall"
4     "Winter"

Meal
"Asparagus" "Salad" "Steak" "Goulash"
FIGURE 5.2  A simple decision table.
Even if you’re willing to accept a monotonous meal plan, it’s simply not possible to enter-tainguestswithsixmonthsofmeatdishes, particularlyassomeofthemmaybevegetarian. We’ll add another input column to our decision table. Multiple columns are always linked by AND, so all conditions have to be met; although if you leave a cell empty, that condition will not be taken into account. So in the example in ﬁgure 5.3 on the following page, there will always be asparagus in spring. Hooray!
Look more closely at the table. Two new rules provide pasta as a result. The only difference betweentheserulesistheseason. Thisworkswell,butwecancompactitbyusingacomma separator. The comma expresses OR within a cell. The table in ﬁgure 5.4 on the next page therefore has the same content but is easier to grasp.
We have limited ourselves to equality (=) in our comparisons so far. Other arithmetic com-parison operations can also be used, and we can use them explicitly in the table.  Let’s
152	5  DMN - Introduction and overview
Meal
U	Season
1	"Spring"
2	"Summer" 3	"Fall"
4	"Winter" 5	"Fall"
6	"Winter"

Vegetarian guests?
--
false false true true

Meal
"Asparagus" "Salad" "Steak" "Goulash" "Pasta" "Pasta"
FIGURE 5.3  Decision tables can contain multiple input columns. The conditions are linked by AND.
Meal
U	Season
1	"Spring"
2	"Summer" 3	"Fall"
4	"Winter"
5	"Fall", "Winter"

Vegetarian guests?
--
false false true

Meal
"Asparagus" "Salad" "Steak" "Goulash" "Pasta"
FIGURE 5.4  Within a single cell, diﬀerent conditions can be separated by a comma. The conditions are thus linked by OR.
assume you would like to offer dry-aged steak, but you can only afford it for a limited num-ber of guests.  Figure 5.5 shows the corresponding decision table.  Dry-aged steak is only served for a maximum of three guests, while larger groups get less-expensive steak.
Meal
U	Season	Vegetarian guests?	Number of guests	Meal
1     "Spring"                            -2     "Summer"                        -
3	"Fall"	false 3	"Fall"	false 4	"Winter"	false 5	"Fall", "Winter"	true

-	"Asparagus" -	"Salad"
< 4	"Dry-aged gourmet steak" >= 4	"Steak"
-	"Goulash" -	"Pasta"
FIGURE 5.5  Comparisons are not limited to equality.
There is a further way of making the table easier to read.  DMN makes it possible to link cells, and all cells that are linked have the same condition, so ﬁgure 5.6 on the next page presents a tidier version.  The difference may seem slight here, but in larger tables it can make quite a contribution to readability.
Do you want to deﬁne appropriate side dishes? It’s simple to do because DMN allows as many result columns as desired. Figure 5.7 on the facing page displays the decision table.
You’ve probably spent the last few examples wondering why we constantly write true and false in the table instead of yes or no, or why we put seasons and meals in quotes.  It is
5.2 Notation elements	153
Meal
U	Season	Vegetarian guests?	Number of guests	Meal
1 2 3 3 4 5

"Spring"                               -"Summer"                           -
"Fall"	false
"Winter"                             false "Fall", "Winter"                  true

-	"Asparagus" -	"Salad"
< 4	"Dry-aged gourmet steak" >= 4	"Steak"
-	"Goulash" -	"Pasta"
FIGURE 5.6  Cells can be linked for better readability.
Meal
U	Season	Vegetarian guests?	Meal	Side dish
1     "Spring"                               -2     "Summer"                           -
3	"Fall"	false 4	"Winter"	false 5	"Fall", "Winter"	true

"Asparagus" "Salad" "Steak" "Goulash" "Pasta"

"Potatoes" "Bread"
"Fried potatoes" "Rice"
"Salad"
FIGURE 5.7  Several result columns are possible.
to accommodate the FEEL expression language; it always has to be possible to translate a decision table into a valid FEEL. Let’s take a closer look at this.
Tooling
As DMN decision tables can potentially be executed, they therefore have to be translated into correct FEEL, so tables need to contain valid expressions. Tools can help a lot with this by oﬀering views that, for instance, hide certain FEEL characteristics in the interests of business-IT alignment. So it may serve you to ﬁnd a tool that will display yes and no while still storing true and false in the background.
5.2.2	Expressions in decision tables
We use FEEL to express conditions in tables. To be more precise, tables are translated into FEEL in the background as exempliﬁed in ﬁgure 5.8 on the next page. The following ele-ments of the decision table exist:
■      The input expression is deﬁned in the column header. During automation, at the latest, variables are referenced here or complex expressions (calculations) are used.  You can hide the technical expressions so that the column header remains technically readable.
■      An input entry is an individual cell.  Usually, you enter concrete values (literals) there. According to the standard, you cannot use calculations or function calls in cells, though manufacturer extensions may make it possible.
■      The output expression is the column header of a result. Typically, this is the name of the result variable.
154	5  DMN - Introduction and overview
Party.Season
Input Expression

Output Expression Meal
InpIuntpEuxt pErnetsrsyion
= "Salad"
= "Summer"	InpOuut tEpuxtpErenstsryion
FEEL Expression
If
Party.Season = "Summer" Then
Meal = "Salad"
FIGURE 5.8  Decision tables are translated into FEEL expressions.
■      An output entry is a result cell. It usually contains a speciﬁc value (literal), but in princi-ple, it also can be an expression. Calculations or function calls are therefore allowed.
It may be best next to look at some more examples, and to focus on common construc-tions within decision tables. Further details on FEEL (which by the way can also be applied outside of decision tables), will follow in section 5.2.4 on page 159.
In the previous section, we got familiar with simple comparisons, but what happens if you want to cook a spinach dish for exactly 6, 7, or 8 guests? You could use the comma (6, 7, 8), although that would be annoying when dealing with larger value ranges. This is why FEEL recognizes ranges, which makes the table in ﬁgure 5.9 possible.
Meal
U
1 2 3 4 5

Season
"Spring"
not("Spring")

Number of guests
<= 4 5 [6..8] >= 9 -

Meal
"Green asparagus" "White asparagus" "Spinach"
"Pasta" "Lasagne"
FIGURE 5.9  Using [..] to express ranges.
We’ve actually hidden a bit more FEEL here. The NOT function negates a condition, mean-ing that we only eat lasagna when it’s not spring.
We said that the comma acts as an OR link; it can be used with as many conditions as you wish.  A superstitious mathematician could even eat green asparagus only with a prime number of guests during spring, as shown in ﬁgure 5.10 on the facing page.
5.2 Notation elements	155
Meal
U	Season
1     "Spring" 2     "Spring"
5	not("Spring")

Number of guests
<= 3, 5, 7, 13, 17
4, 6, [8..12], [14..16], >17 -

Meal
"Green asparagus" "White asparagus" "Lasagne"
FIGURE 5.10  Complex OR links between conditions are possible with commas.
You should pay particular attention to the possibilities provided by logical links. There are limits on what can be expressed in a decision table —and to be honest, we’ve encountered them all. For instance, you may not link conditions in one cell by AND. Instead, you would have to split conditions across columns. Figure 5.11 shows how the range [6..8] would have to be split. It also shows a further example of the NOT function.
Meal
U	Season	Number of guests    Number of guests	Meal
1 2 3 4 5

"Spring", "Summer"
not("Spring", "Summer)

<= 4	-	"Green asparagus" 5	-	"White asparagus" >=6	<=8	"Spinach"
>= 9	-	"Pasta"
-	-	"Lasagne"
FIGURE 5.11  An AND link between two conditions is only possible by using two columns.
If you want to carve out exclusions, they need to appear within brackets. In other words, you cannot write:
not("spring"),  not("summer")
Because it is always either not spring or not summer.
Finally, we want to mention that FEEL also recognizes other types of data such as time, date, and duration. This means that you can easily express the fact that you want fondue on New Year’s Eve. This is shown in ﬁgure 5.12.
Meal
U	Season
1	-

Date
date("2016-12-31")

Meal
"Fondue"
2	"Spring"
3	"Summer" 4	"Fall"
5	"Winter"

---
not( date("2016-12-31") )

"Asparagus" "Salad" "Steak" "Goulash"
FIGURE 5.12  Thanks to the date data type, we can count on fondue on New Year’s Eve!
As you can see, we need to check the rule for winter to exempt New Year’s Eve. This has to do with the hit policy. We are currently using the unique hit policy, which is indicated by
156	5  DMN - Introduction and overview
the U in the header of the left-most column of the table. Exactly one rule (that is, one row) of the table has to correspond. We cannot eat fondue and goulash; it simply isn’t allowed. That may seem unfair, but it is clearly what the table expresses. Let’s take a closer look.
5.2.3	Hit policy
The hit policy determines how many rules may apply and what happens if several rules applyatonce. Theﬁrstletterofthehitpolicyappearsastheheaderoftheleft-mostcolumn of the table. All our examples so far show U for the hit policy unique.
Unique (U): Unique hit
The unique hit policy means that exactly one rule (in other words, one row of the table) will apply. This hit policy is standard, and it is the default if no hit policy is speciﬁed. You could leave out the U, but we recommend including the hit policy designation to avoid misunderstandings.
Typical applications for the unique hit policy are:
■      Determining discounts
■      Determining the employee responsible for a task
As we saw in ﬁgure 5.12 on the previous page, unique is not always the best hit policy to rely on to arrive at a clear table of rules.
First (F): The ﬁrst hit
The hit policy ﬁrst (F) makes the example table much clearer, as shown in ﬁgure 5.13. Only the ﬁrst matching row determines the result, all other rows are irrelevant, and the order goes from top to bottom. Now we can write very simple rules to ensure that our exceptions aredealtwithhigherup, andwecandeﬁnestandardoutcomeslowerdown. Havingfondue onNewYear’sEveisaclearexception,andifitdoesn’tapply,thenthereisnoneedtoensure that it is not New Year’s Eve, although it may still be winter.
Meal
F	Season
1	-

Date
date("2016-12-31")

Meal
"Fondue"
2	"Spring"	-3	"Summer"	-4	"Fall"	-5	"Winter"	-

"Asparagus" "Salad" "Steak" "Goulash"
FIGURE 5.13  The ﬁrst matching row determines the result when using the ﬁrst hit policy.
One consequence of the ﬁrst hit policy is that the order of the rows must be taken into accountwhilemaintainingrules. Largesetsofrulesmakethismoredifﬁcult, andofcourse, the author must know what the F means.
Typical applications for the ﬁrst hit policy are:
5.2 Notation elements	157
■      Determining credit worthiness.  By putting them at or near the top, clear rules can be established for black sheep or existing customers. Rules for new customers can then be evaluated using a more comprehensive table.
■      Assessing risk or detecting fraud. It is possible that various risks may apply, although it is often sufﬁcient to determine the ﬁrst risk.
Priority (P): The most important hit policy
Another variety is the priority (P) hit policy.   In DMN, priority is deﬁned by the result columns.  We can now tell you something we left out earlier:  In columns, you can enu-merate the applicable values. These values then apply in the precise order in which they are enumerated. The priority in ﬁgure 5.14 is therefore:
1.  Exception
2.  Normal
Meal
P	Season
2     "Spring"
3     "Summer" 4     "Fall"
1     -
5     "Winter"

Date
---
date("2016-12-31") -

Relevance
Exception, Normal Normal
Normal Normal Exception
Normal

Meal
"Asparagus" "Salad" "Steak" "Fondue" "Goulash"
FIGURE 5.14  The results column can deﬁne a priority that determines the result.
To determine the priority ofa rule, we look ﬁrstat the left-mostresults column(not the left-most column in the table). All applicable rules with result values in this column are then sorted by priority, and the result with the highest priority becomes the one selected. In our example, it is essential for the relevance column to be the ﬁrst results column, and that the entries in the cells are empty. If several results with the highest priority exist, then the next results column to the right becomes determinative among them.
One advantage of the priority hit policy is that the order of rows makes no difference. That may mean easier maintenance, but it also may mean greater difﬁculty in recognizing when one rule trumps another or how conﬂicts are resolved.
Typical applications for the priority hit policy are:
■      Assessing risk when different levels of risk exist, and we’re only interested in the highest level detected.
Collect (C): All hits
Up until now, only one row (or rule) has determined our result.  That doesn’t necessarily have to be the case.  Let’s assume that you want to decide what drinks to serve at your dinner party as well. You’ll offer beer, wine, soft drinks, and water.
We need the collect (C) hit policy. This policy collects the results of all matching rows. The result of the decision is therefore a list of results.
158	5  DMN - Introduction and overview
Drinks
C	Meal
1	"Asparagus"
2	not("Asparagus") 3	-
4	-

Children present?
--
true -

Drink
"White wine" "Beer"
"Soft drinks" "Water"
FIGURE 5.15  A list of appropriate drinks is the result of a decision table that applies the collect hit policy.
Figure 5.15 shows a decision table for various combinations of drinks.  If we decide on asparagus, then white wine is offered. If children are present, we’ll offer soft drinks. And no matter what food we serve, there will always be water.
Typical applications for the collect hit policy are:
■      Assessing risk where all risks must be collected
■      Detecting fraud or validating where all anomalies must be collected
Collect with aggregation: The sum of the hits
Suppose your party is to be a costume party, and you want to assess the guests’ outﬁts. Of course, this too can be handled by a decision table. Basically, it is like your bank assessing yourcreditratingusingascoringmodel. Weattributeacertainnumberofpointstovarious factors; the sum of points determines a score for each costume.
This situationmay leadto a decisiontable like the one inﬁgure 5.16. Note thatwe canpun-ish factors by attributing negative points for a boring costume, for instance.  By applying this decision table to each guest in costume, we can receive a corresponding assessment, and DMN will even tally the score results. How did that become possible? Notice the small C+ in the header of the left-most column of the table.
Costume scoring
C+	Manufacturing method
1     "Self-sewn"

Make-up
-

Creativity factor
-

Realistic?	Score
-	20
2     "Made out of other costumes"   -3     "Bought"                                          -
4     -	"None" 5     -	"A little"
6     -	"Serious" 7     -	-
8     -                                                         -9     -                                                         -10    -                                                         -

-	-	10 -	-	0
-	-	-10 -	-	10 -	-	20 "Boring"	-	-20 "Very creative"	-	20 -	true	5
-	false	0
FIGURE 5.16  The aggregation function calculates a total score as a result in the decision table.
DMN recognizes aggregationfunctionsinconnectionwith thecollect hitpolicy. The aggre-gation functions available are:
5.2 Notation elements	159
■      C+: Adds the values.
■      C<: Applies the smallest value.
■      C>: Applies the largest value.
■      C#: Counts the hits.
Of course, you could take a different approach and decide that the factor with the highest number of points is determinative.  In that case, you simply enter C>, since you are now interested in the maximum.
A typical application for the collect hit policy is:
■      Scoring.
Hit policies - an overview
We have described the hit policies we consider relevant.  For the sake of completeness, however, here is a list all the hit policies made possible by the standard. First, the single hit policies, which allow for exactly one unambiguous result:
■      Unique: Exactly one row has to match.
■      First: The ﬁrst row that matches determines the result.
■      Any: As many rows as desired may match, all of which then have to provide the same result.
■      Priority: The row with the highest priority matches.
Second, these multiple hit policies allow several results to be passed back:
■      Collect: The result is a list of all results without a deﬁned order. Optionally, one of the following aggregate functions can be added:  + (total), < (minimum), > (maximum), # (count). The use of aggregate functions of course means that only one result is passed back, so strictly speaking, the Collect hit policy behaves more as a single-hit policy.
■      Rule order: A list of results in the same order as the table rows.
■      Output order: A list of results in order of priority.
Most situations can be addressed by using a combination of different hit policies, as we saw with the meal-planning example. In that case, the hit policy will have an effect on the readability and maintainability of the table. It is often worth trying different varieties until you have a feel for what will work best. We also recommend real-world testing as early as possible. In practice, we often use simulator for testing decision tables. We provide a free simulator online at https://camunda.org/dmn/simulator/.
5.2.4	Advanced FEEL
We have mentioned FEEL several times. This is the Friendly Enough Expression Language, andwehaveapplieditindecisiontables. WhenstandardizingFEEL,theaimwastoachieve an expression language understandable to business users but also formally precise so that it can be executed directly by engines. If you were to say that that goal is simply not pos-sible, then we would disagree. Consider Excel. We have seen clients using Excel formulas written by business users that would severely test people with IT degrees.  In any event,
160	5  DMN - Introduction and overview
though, most of the formulas needed are easy enough for most users to read and under-stand.
Besidesdecisiontables, FEELcanbeusedinsimpledecisionlogicwithouttables. Thismay seem a bit confusing at ﬁrst, but there are indeed some decisions in which it makes little sense to invest effort in a table.  If you recall assessing the fancy costumes in our earlier example, a sensible rule would have been: The costume with the highest number of points wins. Shouldtherebeequalpoints,thenaﬁnalresultisdecidedalphabeticallybysurname. You could now describe this as a FEEL expression.
One step at a time, however.  Let’s start with a simple FEEL expression you already know from ﬁgure 5.8 on page 154.
if
Party.Season  =  "Summer" then
Meal  =  "Salad"
This is a rule that can be applied.  It doesn’t have to be expressed in a decision table (al-though a table still may be a better choice in terms of business-IT alignment).
We’ll go deeper into the nature of FEEL in the rest of the chapter. If the examples given so far have been sufﬁcient for you to make your decision tables, you can skip the following details.  But if you are deﬁning rules to be executed or just want to understand certain expressions better, you will ﬁnd these details helpful.
Types of data
You can provide speciﬁc values as literals in FEEL. The following data types are permitted: ■      Text (string): Surround with quotes. Example: "Summer"
■      Numbers (number): Write without quotes. Example: 42 ■      Yes/no (Boolean): Write true or false
■      Time and date (time, date): Write as functions using the patterns HH:MM:SS and YYYY-MM-DD. Example: date("1980-01-01")
■      Duration (in days, months, or years): Example: "P1DT2H" for 1 day and 2 hours
Besides speciﬁc values, you can reference variables to be provided by an engine at the mo-ment of execution. Write the names of variables without quotes. Be careful! The following two lines, for instance, do not express the same thing:
Season  =  "Summer" Season  =  Summer
The ﬁrst expression compares the text string Summer as a literal. The second expression compares the value of a variable named Summer. So you have to pay close attention to the type of data.
By the way, complex objects can be used as variables, so the party itself could be an object with several attributes:
5.2 Notation elements	161
Party.Season  =  "Summer" Party.NumberOfGuests  >  17
Values for dates always have to be generated by the date function, otherwise they will not be treated as a date but instead as text. If you wanted to verify that the party is only taking place after BPMCon 2016, you would write:
Party.Date  >  date("2016-09-16")
The DMN speciﬁcation allows text strings to be displayed in italics instead of in quotes, and for date values likewise to be displayed in bold and italics. This helps with the display, but correct values still have to be generated in the background. Since these details can easily be overlooked, we are not great fans of these alternative representations.
Operators
The most important operators are: ■      Comparisons: =, !=, >, >=, <, <=.
■      Ranges:  [1..10], ]0..11[, (0..11).  All of these ranges mean 1 to 10, inclusive, because ][ or () do not include the limit values, whereas [] does.  We recommend using only one construction per project if possible. So far, [1..10] has proven to be the best solution, at least for whole numbers.
■      Negation: not().
■      Calculations: You can use basic arithmetic operators to carry out mathematical calcula-tions.
The following examples show a few operators in action. For these, we use the logical AND operator, which is only available in FEEL and not in S-FEEL:
if
Party.Date  =  date("2016-09-16")  and Party.NumberOfGuests  in  [25..100]  and Party.CoolnessFactor  >  5  and
not(  Party.FocusZeroCode  ) then
Recommendation  =  "Party  at  same  time  as  BPMCon!  But  not  enough participants.  Ignore."
if
Party.NumberOfGuests  +  Party.NumberOfPrebookings  >  500 then
Recommendation  =  "Find  new  venue"
162	5  DMN - Introduction and overview
5.2.5	Decision requirements
Some decisions cannot be expressed in a simple table.  Often, one decision depends on anotherone. Thesesituationscanbemodeledusingthedecisionrequirementsgraph(DRG) and visualized as a decision requirements diagram (DRD).
At your dinner party, you want to decide which drinks to serve. This of course depends on the meal. After all, you would like to serve a good white wine to accompany the delicious asparagus, right?
The output of this decision	Drinks
is input for the next decision
Decision
Meal

Children present?
Season

Input Number
of guests
FIGURE 5.17  The decision requirements diagram (DRD) displays decisions, input values, and relationships between decisions.
The DRD in ﬁgure 5.17 shows the decisions that need to be taken, what the necessary in-putsare, andhowdecisionsrelatetooneanother. Thisishowyouusetheresultofthemeal decision as an input value for a drinks decision.
DRD is a good tool for discussing decision structures, so you might do a workshop with your spouse. During the workshop, he or she points out that some guests will prefer non-alcoholic beverages. On the basis of the DRD, you may decide to outsource this decision to avoid over-complicating the drink decision table. You change the DRD as shown in ﬁg-ure 5.18 on the facing page.
This has a further advantage: In the future, you will be able to introduce additional reasons for not serving alcohol without having to modify the drink decision. Furthermore, the logic is re-usable. That will be an advantage if you need make sure your desserts are alcohol-free as well.
A decision node in a DRD is linked to decision logic. This means that FEEL or a decision table can be linked in the background. When discussing DRDs in a working session, by the way, it can be extremely helpful to set up example decision tables, as they make a situation a lot easier to grasp. Figure 5.19 on the next page shows an example of this. It is probably exactlywhatyouandyourspousedrewonthekitchenwhiteboardwhileplanningtheparty.
Not all inputs contained in the table necessarily have to be represented graphically.  On the contrary, in practice, it sometimes may be desirable to select your own granularity. You maywishtoseeonlytheparty asanobjectintheDRD,buttousethetabletogointodetails such as the date or the number of guests.
5.3 Practical tips	163
Drinks
Meal	Non-alcoholic
Season

Number of guests

Children present?

Dry alcoholics present?
FIGURE 5.18  This DRD has outsourced the decision on whether or not alcohol is okay.
Meal
Season

Drinks
Guest count
Non-alcoholic
Children present?

Dry alcoholics present?
FIGURE 5.19  Decision nodes in a DRD are linked to decision logic —usually decision tables.
DMN makes it possible to diagram a complex decision requirement graph (DRG) through various diagrams (DRD). This means that each diagram may show only fragments to ex-plain a particular situation. This is comparable to BPMN, in which you can, in theory, also draw several business process diagrams for a single collaboration. This is rare in practice —and we haven’t yet actually experienced it with DMN. For the sake of simplicity, you can usually assume that a DRG equals a DRD.
5.3	Practical tips
5.3.1	Linking BPMN and DMN
For processes, decisions need to be made regularly.  In section 4.5.6 on page 144, we ex-plained when and why these decisions should not be modeled with gateways in process
164	5  DMN - Introduction and overview
models.  Instead, BPMN offers its own type of task to link sets of rules: the business rule task. (At the time BPMN was being standardized, we spoke of business rules management instead of decision management as we do today.)
The approach is simple: As soon as a BPMN process arrives in the Business Rule Task, the set of rules is evaluated. Then the result of the decision is present in the process, and it can be evaluated, for instance, by a gateway. In section 6.2.6 on page 175 we look more closely at the technical integration of workﬂows and decision engines; they are often integrated into one engine. The speciﬁc link to DMN has not yet been standardized because BPMN is signiﬁcantly older than DMN, although this reality is cushioned by vendor extensions.
Figure 5.20 recalls an example from earlier in the book. During a risk assessment, the DMN set of rules applies, and the result triggers a routing decision in the process. You may wish to review section 4.5.6 on page 144 and think again about the difference between business decisions and routing decisions.
FIGURE 5.20  Logic for business decisions in DMN can be called from BPMN processes. The result is often used for routing decisions in the process.
5.3.2	Decisions with a decision ﬂow
Let’s assume you want to decide on a place and date for your party. That shouldn’t be too difﬁcult. Back in the workshop with your spouse, you sketch the diagram in ﬁgure 5.21 on the facing page on the kitchen whiteboard.
This seem straightforward enough, but it doesn’t quite work out once you start working on a decision table.
5.3 Practical tips	165
Location
Appointment	Weather
School holidays
Day of week
FIGURE 5.21  A simple decision?

International soccer match
Competing parties
■      You really can’t generate a decision table to evaluate all possible dates. First, you would determine all relevant days, let’s say Saturdays in May or June.  Second, you evaluate those dates to ﬁnd the most appropriate one.
■      You want to decide on a date, the one with the highest evaluation. This decision is not suitable for a table, but it can be rendered as a simple expression.
■      With the date in hand, you can decide on a venue.  You’ll need more information ﬁrst, such as the weather forecast.
As you can see, the decision is complicated, and it requires that a certain order be main-tained at certain stages. The DMN standard is entirely mute on this topic, but in practice it has proved useful to model a decision ﬂow in such cases. Naturally, we use BPMN.
Figure 5.22 shows the decision ﬂow for our party. As you can see, we ﬁrst collected all dates of interest.  We did it here as a script task but it could also have been a service task.  The business rule task is then carried out once for each date, and it scores them. With a score for each date, it’s easy to determine the most suitable one. Then, for this date only, we have to pull up a weather report —and that can truly be a service call. Now we can decide on the venue.
For all identified appointments

Appointment with highest score

Only for the chosen appointment
Determine all Saturdays in thedesired
Decision required	month

Determine appointment score

Choose appointment

Get weather report

Determine location
Decision made
FIGURE 5.22  The decision ﬂow provides order for complex decisions.
Tohaveafullsetofrulesforourdecision,wehavetoimplementthetwonecessarydecision tables. See the examples in ﬁgure 5.23 on the following page.
This example shows a typical pattern when trying to pick out something from a large num-ber of values. We call it the decision funnel. Typically, it consists of the steps depicted in ﬁgure 5.24 on the next page:
166	5  DMN - Introduction and overview
C+
soccer match?
Appointment score
Distance from
School holidays?
1     true 2     -
3     -4     -

competing party (in   International      Score km)
-	-	-5 <20	-	-50 [20..50]	-	-20 -	true	-10

Location
U	Season
1     "Winter", "Fall" 2
3     "Spring", "Summer" 4

Weather
-"Rain"
"Changeable" "Sun"

Venue
"Hire restaurant" "Dining room" "Balcony" "Garden"
FIGURE 5.23  Decision tables to be used in the decision ﬂow.
1
Decision about search criteria

2
Filter (hard criteria)
a. Programmed, SQL, …	b. DMN

3
Score (soft criteria)

4
Select e.g. best score
Entity Entity
Criteria	Entity

Entity
Entity

Chosen Entity	entity
FIGURE 5.24  To select a value, you often go through the decision funnel.
1.  You decide on certain search criteria such as all Saturdays in May and June.  In this case, it is an informal decision reached by gut feeling.  This also could be modeled by DMN, however, by assessing the correct months and possible weekdays according to the requirements of the party.
2.  From a large volume of data, you seek the elements that match your criteria. For perfor-mance reasons, this is typically not done with DMN but with programmed services or SQL queries to a database.
3.  You may ﬁlter the results again with DMN to apply rules that exclude certain results. (Our example does not show this.)
4.  You evaluate all elements in the current list, usually with a DMN scoring table.
5.  You select exactly one element, usually the one with the highest score, although this doesn’t always have to be the case.  In tenders, for instance, sometimes the second-cheapest option is selected.
Decision ﬂows are a powerful tool and we enjoy using them. A word of warning, however: Even if the decision ﬂow is also modeled in BPMN, it should remain strictly separated from the actual business processes. Always create a separate BPMN model for a decision ﬂow, which is then called up in one node of the business process —just as with a decision table. Otherwise you will end up mixing the process ﬂow with business decisions and, as we’ve already said, we do not believe that to be a good idea.
5.3 Practical tips	167
Technically, a decision ﬂow can be automated using a normal workﬂow engine as can any other BPMN process.
5.3.3	The life cycle of decisions
When we started working with DMN, a decision life cycle emerged.  It is similar to Ca-munda’s BPM life cycle from ﬁgure 1.1.3 on page 2.  Again, we tried to compromise be-tween overly-correct complexity and simpliﬁed presentation. You see our compromise in ﬁgure 5.25.
Workshops, Interviews, Proces Models,
Documentation, ...
Decision Discovery
Live Editing

DRD Modeling,
Domain Model & IT Systems, Sample Rules
Decision Analysis

Decision Design

DRD Modeling,
Decision Table Structure, Test Case Structure
Rule Authoring
Decision	Rule Authoring Operation

Decision Tables, Test Case Authoring
Decision Validation

Decision Validation

Test Case Execution, Simulation, ...
Small rule changes without full development & deployment cycle

Decision Deployment

Leverage rapid prototyping & fast iterations
Change Management, Software Development, ...
FIGURE 5.25  The life cycle of decisions.
The life cycle assumes that you need to implement one decision.  For this decision, you should collect as much information as possible during a ﬁrst discovery. Using that infor-mation, you can start your analysis. During the analysis, DRDs like the ones introduced in section 5.2.5 on page 162 are useful tools. You also should start drafting tables early so that you can render the rules as speciﬁcally as possible for all concerned.
Once you ﬁnish this preliminary work, you can verify if all necessary input data is truly available —and where it came from.  We often ﬁnd that during this early phase wishful thinking collides with reality.  You realize that desired rules cannot be implemented be-cause necessary information is either missing or painfully difﬁcult to obtain. It is good to catch these problems early, however, as you can still take countermeasures. Perhaps you can change the rules, for instance, or make the additional effort to acquire the required information. Costs and beneﬁts are easy to see at this point.
168	5  DMN - Introduction and overview
Once agreement has been reached about the early phases, you can begin to design. First, create the structure (the columns) of the decision table. Provide some sample rules (a few rows). This work may be done by specialists or the IT department if the table is to be auto-mated later on. Second, record the rules fully. The business may do this part, or it should at leastreviewthetableandtakeoverownership. Theyshouldnotdelegatethisresponsibility.
If the project is headed toward an automated outcome, deﬁne test cases during design. Thisisalwaysimportantlaterwhenitistimetovalidatethesetofrules. Alsoensurethatthe test cases are recorded in a form understandable to the business that will be maintaining them.  Common worksheets in Microsoft Excel have proved useful for this, but there are specialized test frameworks available as well.
Rules should be validated once they are complete. For the simplest cases, it can be enough justtorunthetablethroughafreeonlinesimulatorsuchashttps://camunda.org/dmn/simulator/. Youalsocansimulatedecisionsusinghistoricdata. Inthebest-casescenario,youmayhave
access to automated tests based on test cases previously deﬁned.
The deployment of a decision varies with the type of decision. It can range from compre-hensive change-management procedures and software releases to simple working instruc-tions by email.
Once the decisions are in production, the desire is often expressed to live edit them. Re-member this rule of thumb: It is comparatively easy to adapt the rows in a table, but it is less easy to change columns —in other words, the structure.
Decision engines offer the possibility of changing the tables by a push of a button during runtime. In production. Immediately. This sounds great, and it usually makes clients’ eyes light up ...but after that ﬂash of enthusiasm, the eyes narrow with skepticism. It doesn’t take long for someone to ask: "But who’s going to push this button? What actually happens if something goes wrong?  Does the change then really go live immediately?  That’s a bit scary, isn’t it?"
Those are exactly the right questions. Unfortunately, there are no universal answers. The bestthingtodoistothinkaboutyourorganizationandyourplans. Onethingremainstrue: The are no technical hurdles to having a rule change go live in real time without involving IT.
6
6.1

Workﬂow Automation
Purpose and beneﬁt
This chapter is about automating business processes and decisions with software.   Of course, this can be done using traditional software development, but it is much more interesting —especially in the context of business-IT alignment —to use an engine.  We introduce this possibility in this chapter, and we detail the advantages it offers.
Since engines can operate with both standards presented in this book (BPMN and DMN), we use engine as an umbrella term for:
■      Workﬂow engines. These carry out structured processes in BPMN. They are also known as process engines.
■      Decision engines, which make decisions on the basis of DMN. These are also known as rule engines or business rule engines.
Products exist that integrate both standards.
A engine reads models as XML ﬁles, and it executes the models directly. The models, act-ing as source code of a software solution, must be precisely deﬁned and detailed.  That’s important.  After all, the engine cannot interpret things that aren’t deﬁned.  That models equate to source code also is a huge opportunity; the models always represent reality! To make a change, you adapt the model.
With process models in BPMN, we have the freedom that only the automated parts end up in an engine. This brings us to a second important aspect of our framework, which we explain more in section 6.3 on page 176: If human and technological process ﬂows are sen-sibly connected, you stand a good chance of keeping the documented work organization up to date.  Suitable tools can project technical modiﬁcations into the human ﬂows and, in the context of process monitoring, show what has been executed by the engine in ways easy for non-technical users to understand.
170	6  Workﬂow Automation
6.2	Basics
6.2.1	Model execution with workﬂow and decision engines
The engine is a software component for executing BPMN or DMN models.
Workﬂow engine
For workﬂow or process automation, the workﬂow engine needs the business process to be in a BPMN model that contains all technical details required for execution. While running, process instances are generated for each process run. The workﬂow engine calculates the control ﬂow and always knows what has to be done next. This actualizes the token concept introduced in section 2.1.4 on page 26. To be precise, it is not the business process that is automated but rather the control over that process.
An engine recognizes two fundamentally different types of activities:  those that require humaninteractionandallothersthatrunautomatically. Thelattermaybeservicecalls,but they also may be evaluations of gateways, events, or sentries. For human interaction, user or human tasks are used. Usually, engines contain a list of tasks comparable to an email inbox in that they let the user know which tasks still have to be completed. If you open a task, you get a preconﬁgured screen mask that makes it possible to view and process data or make decisions. See the overview of how the workﬂow engine functions in ﬁgure 6.1.
Executable process model

Modeling
Monitoring and reporting
Workflow engine

Human workflow management
Measure running time
Task assignment

Automated service call

Automatic decision

Automated service call

Task assignment
Service orchestration
Process participant	IT system	IT system	Process participant
FIGURE 6.1  How the workﬂow engine works.
As you can see, the engine has to do more than simply manage the control ﬂow because it is necessary to also account for the data ﬂow in the process.  This means that during one process instance, data can be added which the engine then manages together with the state. Usually, this data is also stored in a database so that it can be restored after a system failure.
6.2 Basics	171
Decision engine
MakingdecisionsbasedonaDMNmodelhassomewhatdifferentrequirements. Adecision engine is software that can make decisions automatically based on business rules. No state needs to be maintained. The primary aim is to distinguish business logic from program or process logic, which means you can make fundamental changes to business rules without having to change program code or redesign the business process.
Service consumer / client
Request	Result
Order
Value = 35.750 Content = ...

WENN
kunde: Kunde.Typ = Neukunde UND
Bestellung.Höhe >= 50.000 € DANN
kunde.bonitätPrüfen
Customer Type = new
Name = Camunda ...

Decision engine
Decision model (rules)
Facts (Data)
FIGURE 6.2  An overview of the decision engine.
You can picture the decision engine as a black box (see ﬁgure 6.2).  The engine responds to a request according to the rules it knows.  To evaluate the rules, the engine uses data —so called facts.  Typically, the facts are contained within the request.  They may also be provided from an external source such as a database.
Advantages of engines
Besidesmanagingthecontrolanddataﬂow, atypicalworkﬂowordecisionengineprovides many additional functions:
■      Versioningofmodels: Business processes are long-running by nature. An order process, for instance, may take from a few days to several months.  This means that when you modify a process, some instances still may be running.  Engines can process different versions of a model simultaneously, thus making a transition to a new process possible by phasing out the old version.
■      Data collection, key performance indicators, and reports: The engine can collect data automatically while managing processes or decision instances.   For an order, for in-stance, it can collect when authorization has been occurred, when shipping has been initiated or completed, and so on. This data can be aggregated and reported on, provid-ing a good overview of efﬁciency and potential bottlenecks within the process. Once it
172	6  Workﬂow Automation
has been well aggregated, it also provides an overview of the process landscape. A fur-ther possibility is business activity monitoring (BAM), an approach meant to recognize patterns in real time and issue warnings or to intervene autonomously.
■      Technicalmonitoringandadministration: Theengineoffersthechancetoviewcurrent status of the process instances. This opens various possibilities for intervention such as aborting or restarting a faulty instance.
6.2.2	Executing the BPMN and DMN standards
Models in BPMN and DMN can be stored as XML ﬁles.  Each standard deﬁnes a precise XML schema.  The information relevant for execution is stored in XML, as are the coor-dinates and other details for graphical representation called diagram interchange.  This makes it possible to use models in different tools without losing the layout. The conﬁgura-tions needed for the graphical layout and for execution are stored in the same XML ﬁle.
Both standards also deﬁne execution semantics, which means that for each notation ele-ment, there is a precise deﬁnition for how the engine should act. Precise deﬁnition makes it possible for models to be carried out in any standards-compatible engine without pro-prietary extensions.  In section 6.4.3 on page 183, we outline everything that needs to be taken into account in this context.
In this book, we do not delve into the complete execution semantics nor the details on the XML schema. We deliberately avoid XML source code —and we even removed some code thatwasinearliereditions—becauseitshouldtobetransparenttoyouasauser. Ofcourse, you are welcome to pore over further examples at http://camunda.org, for instance, or in the ofﬁcial example documents.
6.2.3	Alternative automation languages
Web Services Business Process Execution Language (WS-BPEL) is an XML-based language that combines web services into more powerful services.  Services are combined as pro-cesses; this is called orchestration. WS-BPEL was introduced in 2002 by major IT compa-nies including IBM and Microsoft.
The acceptance and use of BPEL peaked around 2010. After BPMN 2.0 was released, BPEL started to decline, although some experts still maintain that it provides some functions that are missing in BPMN. Either way, from what we are seeing, it is obvious that few BPEL projects are left, and only a few workﬂow engines still support it.
We don’t think it makes much sense for you to occupy yourself with BPEL now.  We do, however, offer respect to the authors of the standard; it was an important milestone on the road to BPMN 2.0.
For those interested in the history, here is why we think BPMN prevailed over BPEL:
■      Control ﬂow as graph: In contrast to BPELs’ block structure, BPMN processes are graph-oriented. Functionally modeled processes can thus be executed without problems. This challenged the vendors of workﬂow engines, but they found practical solutions even for complicated gateway designs. Those solutions may not satisfy theorists in certain eso-teric special cases, but for practitioners, they represent a useful compromise.
6.2 Basics	173
■      No close binding to web services and XML: BPMN, in contrast to BPEL, deliberately leaves open the question of applying Web Services and XML in a workﬂow engine. These technologies may be the defaults, but we have seen that it is often better to use other technologies. If a project focuses entirely on a Java architecture, for instance, it makes sense to apply a Java workﬂow engine to avoid the lengthy trip through web services. So far, this has required proprietary tools, but BPMN 2.0 enables such engines to be inte-grated through the standard as well.
■      Graphical notation: Most BPEL tools provide a graphical view of a process, but this is not standardized. Also, the resulting block-oriented diagrams are dissimilar to the func-tional model. In contrast, BPMN processes have a well-deﬁned appearance that is en-tirely aligned with the concepts and ideas of the functional models.  This is a big step toward aligning business and IT.
We published a summary evaluation on the future of BPEL at http://BPEL.de.
Besides the BPMN and BPEL standards, there is also the XML Process Deﬁnition Language (XPDL) from the Workﬂow Management Coalition. Like BPEL, XPDL is no longer relevant. There are, obviously, manufacturers and related service providers who claim otherwise. There are also many language-proprietary workﬂow engines with a wide variety of archi-tectural approaches. We can’t provide an overview of products with proprietary languages. We note, however, that these are increasingly adapting to BPMN as they issue new releases.
6.2.4	When is it worth using a workﬂow engine?
Why should you even use a workﬂow engine in your projects? Can’t you just implement the process diagrams you’ve generated in your preferred programming language?
Surely, this question is justiﬁed. As is so often the case, however, the answer is: It depends. Let’s step back and look at automation in its entirety.  The rule of thumb is that process automation is worth it especially for business processes that exhibit the following:
■      High number of repetitions: The work put into automation is worthwhile only if many instances can be executed. Otherwise, the cost of development may exceed the savings in process costs.
■      Standardization: If processes are barely structured, and they run differently all the time, then an engine is not appropriate. The majority of instances therefore should follow the same pattern.
■      Richininformation: Basically, processes that carry a lot of information are better suited toautomationbecausecomputershandleinformationverywell. Ifphysicalobjectshave to be moved often, automation is more difﬁcult and less exciting.
■      High potential degree of automation: Of course, task automation can increase the efﬁ-ciency of a process. Some tasks, such as booking in an ERP system, are well suited to au-tomating with an engine. The data no longer has to be entered manually into the mask. Some manual tasks are not suitable for automation —calling up clients, for instance.
Would you like to automate your business processes? Let’s return to the question of why you should use an engine:
■      Visibility: A main advantage of using an engine is that the process is not only available as source code (XML, Java, and so on), but also as a diagram. This means that the exe-
174	6  Workﬂow Automation
cution of the process is not buried deep in the software; it is rendered visible. This ad-vantage is essential because it makes it easy to discover how the process is implemented. Truth, as we know, lies in the source code, and suddenly it becomes accessible and un-derstandable for everyone. What an advantage when it comes to discussing weak points, possible improvements, and modiﬁcations!  Without the engine, IT specialists have to embark on a quasi-archaeological search to unearth how the process was actually im-plemented. Process automation provides the transparency necessary to make sensible re-engineering possible. Being able to ensure that an automated process is truly being carried out as described —and being able to prove it with log data afterward —is also immensely helpful for meeting compliance requirements.
■      Agility: Often, BPM and SOA are compared to Lego. You simply construct your new pro-cess from existing services as if the services were Lego building blocks. A customer once said to us: "Take a look at Lego kits nowadays. You get highly complex and specialized building blocks that you cannot easily reuse at other points." And he’s right —that’s ex-actlywhathappensinITtoday. Ifwewanttoobtainacomplexendproductsuchasacool Lego spaceship, then we can’t work with simple building blocks. This also means that we can’tjustplacetheblockswhereverwechoose. Doesthatmeannoagility? Wedon’tthink so, becausewethinktheagilitycomesfromincreasedtransparencythatmakeschanging processes feasible in the ﬁrst place. It doesn’t work at the push of a button, but at least we can estimate what consequences a process change will have and where we’ll have to intervene. The visibility of the process also leads to services of suitable granularity, and it supports the sensible modularization of IT systems.
■      Quality: Imagine a mail-order ﬁrm of your choosing. If you call them to ﬁnd out where your order is, there are two possible answers:  "Let me ﬁnd out for you; please wait a minute," or the immediate:  "Your order is currently waiting at xy." A mail-order ﬁrm that can offer the second answer probably uses an engine that offers a more precise look at the process deﬁnitions and process instances.  Escalations in the case of excessive waiting times don’t have to come from frustrated customers but rather from the engine itself.
In theory, you can achieve these advantages by building your own engine.  Perhaps you could also build your own database, but would you? Probably not. Instead you would trust reliable products. If they were available free of charge, so much the better!
6.2.5	When is it worth using a decision engine?
When it comes to decisions and their underlying rules, there are two basic possibilities for execution:
■      Programming as source code
■      Decision engine
Even today, it is common to program decisions in a classic programming language. As an approach, this has some disadvantages that need to be weighed:
■      Translation: Rulesalwayshavetobetranslatedfromthespeciﬁcationintoprogramcode by a software developer. This is true both for the initial development and for subsequent modiﬁcations. Even developers regularly fail to ﬁnd the implemented decision logic in
6.2 Basics	175
the source code that was generated, making subsequent modiﬁcations laborious and prone to mistakes.
■      Release cycles: Because they are programmed into software, decisions are subject to the same release cycles as other software components.  Comprehensive test and approval cycles can take a long time, and that can be a problem when business rules change fre-quently. That is why there is a call for a more agile approach in this area in particular.
■      Readability: Rules hidden in program code cannot be understood by the business de-partments. Thismakesvalidationdifﬁcult. Determiningtheimplementedbusinessrules from looking at evolved systems is extremely difﬁcult and furthermore, the logic often is spread across the entire system.
■      Traceability:  If a decision is made, it is desirable to record why, for example, a credit check was not necessary —be it for legal reasons, internal traceability, or even to be able to show this information directly to the customer.  This means that the customer even could be given the names of the rules that resulted in his or her declined application. Emulating this in source code is extremely cumbersome.
According to our assessment, the tools of the past that were a great obstacle to the univer-sal spread of rule engines. Platforms known as business rule management systems (BRMS) were typically expensive, proprietary, and bulky. With DMN, however, a new generation of engines and tools have entered the market, and this will lead to an expansion of decision engines and DMN. Already, there are some open-source projects in this area. Gone are the days when decision (or rule) engines were outmoded or too expensive. The integration of modern decision engines has become easy, and it explains their increased popularity.
To sum up, we point out that from a business-IT alignment perspective, decision engines represent low hanging fruit that you should not overlook.
6.2.6	Workﬂow and decision engines in interaction
Ifyouwanttouseaworkﬂowengineandadecisionenginetogether,youshoulddecideﬁrst if you want to use an integrated product or two separate engines.  From an architectural point of view, we recommend keeping the two concepts clearly separated, but that does not mean you can’t use an integrated product.
The decision engine intervenes in the process intermittently. It is explicitly called to do so, as shown in ﬁgure 6.3 on the next page.  A big advantage of this is that you can provide decisions as a service that components outside of the process can also use.  Our credit check, forinstance, willsurelybeusedatotherpointsintheprocess. Ideally, fromthepoint ofviewoftheprocess,itshouldn’tmatterifadecisionengineoraconventionallydeveloped software component is working behind the scenes as long as the result is correct.
Our modeling etiquette
Rules for a decision should be written independently of their current use in the process. Try to imagine a second use case in a diﬀerent process or even in a diﬀerent context. If you can apply the rule in the second situation without having to modify it, you end up with better rules —and ones that may be reusable even outside of the current process.
176	6  Workﬂow Automation
Input data	Result	Do this
Workflow engine
Check
Do that
Evaluate decision
Decision engine
Rules
Additional data
FIGURE 6.3  The decision engine interacting with the workﬂow engine.
By the way, the technical connection plays a more subordinate role here, and it mainly depends on the technology of the workﬂow engine. BPMN deﬁnes three connection pos-sibilities for the business rule task: business rule web service, generic web service, or other technologies.  Of course, manufacturers prefer to offer the decision engines within their own portfolios, but we know from experience that it is usually okay to use other engines and to connect them through web services , REST, or Java. From a design point of view, the use of other engines doesn’t really matter. Direct integration into a product, however, often has an advantage when it comes to monitoring.
6.3	Automating technical process ﬂows
6.3.1	Model requirements
Technical process ﬂows must be syntactically and semantically correct, but they must also contain all the technical details necessary for automation with the workﬂow engine. The model must be precisely built, leave no room for interpretation, and all cases of technical error or exceptions have to be dealt with.  After all, this is the source code for a software solution!
Thisisalsothemaindifferencebetweentheframeworkdescribedinthisbookandprevious approaches. The precise modeling, however, also poses a huge challenge for the process analyst. Many tool vendors have tried to hide this complexity in their own technical mod-els, and those models have never worked. From experience, we know that an operational process model with human and technical ﬂows can make business-IT alignment possible
6.3 Automating technical process ﬂows	177
ƐƚƌĂƚĞŐŝĐƉƌŽĐĞƐƐŵŽĚĞů

Content:  Process overview Goal: Fast comprehension
Semantics: Logically abstract
ŽƉĞƌĂƚŝŽŶĂůƉƌŽĐĞƐƐŵŽĚĞů
ŚƵŵĂŶ ƉƌŽĐĞƐƐĨůŽǁ

ƚĞĐŚŶŝĐĂů ƉƌŽĐĞƐƐĨůŽǁ

Content: Operational processes Goal:  Coordinate details between
human process flow and technical process flow (automation)
Semantics: Physically specific
FIGURE 6.4  Technical process ﬂows in the Camunda house.
while meeting the same kinds of requirements you would expect of software —provided that the necessary tooling exists. (We go into this again in section 7.4.2 on page 204.)
6.3.2	Procedure
The success of a technical ﬂow when implemented depends on the procedure for devel-oping the ﬂow.  This is where business collides with IT. In our experience, prospects for success depend not only on the process analyst’s skill, but also on his or her collaboration and communication with the process engineer.
Development typically has these steps:
1.  Clarify the target-state process at the organizational level. These are the human ﬂows we discussed in section 4 on page 117.
2.  Decide on the technology, language, and the workﬂow engine.
3.  If you apply a BPMN engine (see section 6.2.2 on page 172), all you need to do is reﬁne the deﬁnition of the technical ﬂows. If you use another technology, you need to map the technical ﬂows to the language of that technology.
4.  Iteratively reﬁne and specify the operational process model as new questions arise.
5.  Test and execute the process with established methods of software development.
We have only examined the workﬂow aspect of process control so far. For technical imple-mentation, it is essential to reconcile other aspects of software technology. (See ﬁgure 4.14 on page 130 especially.) In the next section, we examine some technical aspects still miss-ing from the operational process model such as:
■      Specifying data in the desired technology such as XML or Java.
■      Deﬁning service calls in the desired technology, for example, web services.
■      Detailing human tasks such as assigning users to groups or determining the forms to display.
178	6  Workﬂow Automation
HR clerk
Automatic
Workflow engine
6.3.3	The executable process model
Starting with the previously deﬁned process model, we use it as input for the technical ﬂow (see ﬁgure 4.13 on page 129), but we only consider the workﬂow engine’s pool. Figure 6.5 represents this process. Before, we did not show that the job advertisement was executed on different platforms.  Instead, we extracted it as subprocesses.  For simplicity, we now embed it.
To illustrate this, we also show MajorJobs.com as a separate pool, mainly to show the mes-sage ﬂow. We will specify the exact content of the message later.
So far, the process doesn’t look all that technical, does it? Many of the details necessary for automation are hidden in the underlying model, and that’s available as an XML ﬁle.  For now, we want to examine several aspects step-by-step. We do not cover the whole process here to save space, but you can see the full example at http://www.bpm-guide.de/bpm-java/.
From a merely visual point of view, the technical ﬂow in this example corresponds to the technical ﬂow deﬁned in the last chapter.  Isn’t that brilliant?  For those concerned with details, note that we changed two more things:
■      We added the job advertisement data object because we have to store certain data in running process instances.
■      Wechangedsendconﬁrmationofsuccessfromasendtasktoascripttask. Why? Whilethe conﬁrmationcouldbesentbydifferentmeans,itwillprobablybebyemail,andtheemail could come through an automated service or some built-in capability of the workﬂow engine. In our example, we assumed the latter, and this leads to the use of a script task in the process.
The displayed process still doesn’t look too technical, does it? The crux of the matter is that the many details necessary for automation are hidden under the hood. As we said, they are buried in the underlying model, which exists as an XML ﬁle. In particular, these are:
■      Specifying data in the desired technology such as XML or Java
■      Executing the gateway with expression language
MajorJobs.com
Publish job ad on
MajorJobs.com	MajorJobs.com
Job advertisement

Selected
channels	Publish
job ad on
web site
company web site
Blog
Publish job ad on blog

Send confirmation of success
Job advertised
Write job description

Check job description

Correct job description
No
Yes

Trigger advertisement
OK?
Hiring dept.
Manager
FIGURE 6.5  Executable process model of the job advertisement.
6.3 Automating technical process ﬂows	179
■      Deﬁning the service calls in the desired technology such as REST, Java, or web services
■      Human task details such as assignment to user groups or forms to be displayed
Let’s take a closer look.
Data modeling and expressions
In the process diagram, the job advertisement is represented as a data object. BPMN re-frains from implementing detailed technical data modeling.  Instead, it provides expan-sion points to accommodate diverse technologies. The default setting for this is the XML schema, although we could use Java or .NET data types just as well. By the way, data in the process does not necessarily have to be visualized in the graphical model.
The speciﬁcation also recognizes formal languages for representing conditions, which are called expressions. The formal language therefore is called expression language.
Expressions can glean new information from existing data and, in the easiest case, a simple true-or-false assessment takes place. A good application example is the data-based exclu-sive gateway: depending on the process, at the time of execution, the token will leave the gateway through a given sequence ﬂow.
In BPMN, the standard setting is to use the XPath expression language.  XPath is a query language that works directly on XML data and therefore makes sense in combination with the XML schema for data types. This language also can be exchanged. In connection with Java data type, for instance, Java Uniﬁed Expression Language (JUEL) could be used.
This ability to conﬁgure a data type and the expression language to match it offers great ﬂexibility.  It also means that vendors can develop lightweight engines that are close to programming languages.  This is what we have done with Camunda BPM. On the other hand, it should be noted that proprietary developments like this can lead to processes that can’t run on different engines. We come back to this topic in section 6.4.3 on page 183.
Service calls
You can call IT systems from a BPMN process. You can use various elements:
■      Service task: Synchronous communication, during which you obtain a response straight away, is represented by a service task.  The BPMN process remains in the service task until it receives the response.
■      Send and receive task: In the case of asynchronous communication, the send task sends a message or calls a service, acknowledging receipt of the request. The actual response takes place asynchronously and is then modeled by a receive task or a corresponding event.
Inbothcases, weuselogictoextendthetasktocalltheservice. IfthecallisaSOAPwebser-vice, the call can be carried out in a completely standardized fashion. To do so, we have to deﬁnedataobjectsandmessagesaswellasincomingandoutgoingdatamappings. BPMN, however, is not ﬁrmly tied to SOAP, meaning that other technologies such as Java or REST-based services can be connected directly.
In section 7.4.3 on page 204 we go into our own platform, Camunda BPM, which we have used extensively in practice. This takes a different approach to service calls in that it pro-vides extensions so that you can link a service task directly to Java code or corresponding
180	6  Workﬂow Automation
expressions.  While this is a deliberate deviation from the standard, we are not violating it because the standard permits extensions.  Overall, we ﬁnd that the extensions make it much easier for Java developers to deal with process deﬁnition.  Success depends on the individual customer’s situation. Most of our clients seem to think it is a worthwhile trade-off.
User tasks
Human interaction takes place in the form of a user task. The existence of user tasks in the process leads to tasks being placed in task management and tasks ending up on a user’s task list. Only after the user completes the task does the process continue.
The exact technological connection is often a detail in the implementation of the partic-ular workﬂow engine, making seamless integration possible.  If it is essential for you to be independent of a speciﬁc engine, there is generally a standardized way using web ser-vices: WS-HumanTask (WS-HT). This comprehensive speciﬁcation deﬁnes user tasks in a detailed and powerful way. Aspects such as responsibilities, delegation, escalation, or even meta information for the display can be deﬁned. In real life, however, WS-HT is often too complex to be used easily.
Forms for tasks or other interface components, by the way, are completely left out by BPMN. This is where workﬂow engine vendors go off in different directions.
6.4	Practical tips
6.4.1	Embedded and decentralized workﬂow engines
If you want to run your BPMN models on a workﬂow engine, the question immediately arises: howtorunthisengine? Inthepast,theimageofthecentralworkﬂowengineorBPM suite dominated.  Various operational processes were operated on this central platform. The main advantage was that the platform only had to be operated once, so that fewer people had to be familiar with it and perhaps licensing costs could be saved.
However, this view does not ﬁt into modern architectures around microservices.  In sec-tion 1.6 on page 19 and section 4.5.3 on page 140, we talked about BPMN monoliths and showed that an operative business process also has to consider system boundaries.
Thisalsorunsthroughthetechnicalinfrastructure, becauseonewantstogranttheindivid-ual microservice teams as much autonomy as possible. A microservice is actually deﬁned only by its responsibility and the API. The use of a workﬂow engine and the selection of the concrete product is an implementation detail that should be left to the team itself. Of course, autonomy in practice usually has its limits, since companies want to avoid a pro-liferation of technologies and often form competence centers for key technologies such as workﬂow engines.
But nevertheless the workﬂow engine is logically part of a microservice as shown in ﬁgure 6.6. It is not a central infrastructure or a microservice in itself. This view becomes possible becauselightweightworkﬂowenginestoday, unlikecomplexBPMsuitesinthepast, canbe
6.4 Practical tips	181
UI,
business logic, entities,
data, Workflow Engine	…
Microservice Insurance Application
API
Workflow Engine

UI,
business logic, entities,
data, …
Microservice Policy
FIGURE 6.6  In microservice architectures, the workﬂow engine is usually an implementation detail and not a central infrastructure.
operated very easily. In this book we don’t want to go further into these details and instead refer to relevant tutorials and how-tos on the Internet, for example about our open source platform Camunda BPM.
This view is essential in microservice architectures. We often ﬁnd that BPMN tools are re-jectedbyarchitectsordevelopersbecausetheyautomaticallythinkofcentralizedormono-lithic BPM systems.  And in the world of microservices, which is characterized by decen-tralization and autonomy, such a tool has no place! So it is all the more important for us to spread the knowledge that a workﬂow engine can also be used decentrally in a microser-vice. Then it quickly becomes an essential building block in harmony with your microser-vices architecture.
6.4.2	The low-code trap
Once people get familiar with the idea of a workﬂow engine, we often run into a problem: the expectation that the magical BPM suite will solve everything. Ideally, we feed the suite
182	6  Workﬂow Automation
on models developed by the business before IT systems are automatically integrated and human workﬂow management just works magically. Finally, we create a dashboard of key performance indicators. These enable the business to recognize process problems in real time and to resolve problems for themselves.
This scenario sounds too good to be true, and in practice, it is. Developing process appli-cations is always a form of software development. The promise that this can be taken on by business users in the future is appealing, but it is a promise that cannot be kept. We have seen this over and over. At the end of the day, you need comprehensive wizards and forms to develop process applications in a model-driven way, and the wizards and forms are so complex that they overwhelm the average business user.
What happens then? The company’s own IT department is called in to take over develop-ment. Unfortunately, the ﬁrst thing the company’s software engineers have to do is ﬁgure outtheBPMsuite. Afterall,theycan’tjustapplytheirpriorknowledgeofprogramminglan-guages because the technology has been hidden behind the wizards and forms. Ironically, the aim of making development faster and easier is completely thwarted.
During our many years of BPM project experience, we have come to realize that this is ex-actly where the core problem with the classic BPM suite lies. It is especially pronounced in companies that already have been carrying out software development —in Java, for in-stance. The following disadvantages arise:
■      High programming effort: Because software development is vendor speciﬁc, in-house developersneedtolearnandpracticethevendor’sspeciﬁcplatform. Therelatedexpense is not a one-off but instead continuous, with retraining required to maintain knowledge. Existing knowledge (in Java, for example) cannot be applied. In addition, existing tools, techniques, and best practices of software development (unit testing, for example) can be applied partially or not at all. This severely limits the developers’ productivity, and as a result, technical implementation is much more complex than it at ﬁrst appears.
■      Inability to model distinctive parts of a process: Because the development approach is model-driven, the possibilities for technical implementation are limited.  Compare this to a painter:  On a blank canvas, an artist can paint a picture exactly the way she imagines. Another artist paints by numbers. He can create stunning images, but only by daubing predetermined colors onto predetermined places. This second artist can create only what was predesigned.
Painting by numbers in BPM suites is like using off-the-shelf application software. Often it is sufﬁciently ﬂexible for standard support processes (vacation requests, for example, or invoicing), but the limited possibilities for technical implementation remain insufﬁ-cient for capturing and implementing core business processes.
■      Inability to integrate into existing IT: On an operational level, the drawbacks of off-the-shelf applications also apply to traditional BPM suites: they cannot be incorporated easily into existing IT structures.
■      Specialized developers needed:  As we mentioned, a model-driven development ap-proach is inevitably vendor speciﬁc, so there’s no escaping the fact that you will need developers trained in a particular BPM suite. Such developers are scarce, and if they are not available, it is much easier to ﬁnd developers for popular programming languages such as Java.
6.4 Practical tips	183
■      Vendor lock-in: Consequently, there is a strong vendor dependency as the vendor and its partners are usually the only ones with developers with the required level of exper-tise. This is acceptable in the context of support processes (invoicing, vacation requests, and so on), but it represents unacceptable risk when capturing and implementing core business processes.
Tous,itseemsthattraditionalBPMsuitesare...stuckinthemiddle...neitherﬁshnorfowl. They are as unsuitable, compared to existing software development, as off-the-shelf appli-cation products, and they don’t even offer an out-of-the-box solution for process automa-tion. This dilemma has resulted from an unsuccessful search for compromise between the two extremes and also, to a large extent, to a more academic ﬂow during the last decade: model-driven software development. The modest growth of BPM suite vendors during the same decade seems to conﬁrm our assessment.
Does this mean that using BPM software for process automation is a bad idea? Of course not, but it does mean that the right approach is not as simple as we might wish. In prac-tice, it is a hybrid approach that proves best, where certain parts —the process itself —are model-driven while other parts —complex user interfaces for instance —are developed through classic programming. You therefore have to accept that software development will require software developers in the future. Sounds fairly logical, doesn’t it?
In section 7.4.3 on page 204, we present the Camunda BPM platform as an example that supports the hybrid approach and is available as an open source project.
6.4.3	The myth of engine interchangeability
We have indicated that some aspects may be solved differently in different products. The ﬂexibility of the standards gives vendors latitude in selecting technology.  Can a process model then be executable on different engines? Usually not. That is, we have not yet seen a model that covers real requirements and was able to do it completely without vendor extensions.
We think that BPMN engine interchangeability is of limited concern. Consider how much time the SQL standard for databases has had to mature. Still, you often want to fall back on featuresofaproductthatyouknow. Weﬁndthatlegitimate. Anyrequirementforswapping around the workﬂow engine without having to touch your process solution should not be given too much weight.
Most projects end up buying a clearly simpliﬁed process execution, such as using Java shortcuts, while sacriﬁcing interchangeability.  This is further catalyzed by the fact that Webservices are not exactly touted as the technology of the future, and many projects pre-fer other technologies.
In short: Don’t make complete interchangeability a sticking point. Just trust that the nota-tion, meaning the BPMN model structures agreed upon with the business (without execu-tion attributes), can survive a switch in engines.
184	6  Workﬂow Automation
6.4.4	Modeling or programming
Okay, so you’re going to use a BPMN engine. The next questions are which aspects will be expressed through technical process models, and which requirements may it be better to continue addressing with classical software development? As is so often the case, there is nogenerallyapplicableanswertothisquestion. Evenifsomeofthefollowingfactorssound trivial to you, our experience shows that you will do well not to overlook:
■      Technology and architecture: Depending on the workﬂow engine and the overall archi-tecture to be used, it can be either simple or difﬁcult to execute certain requirements within a process. Some engines, for example, make it possible directly to integrate Java code, connectors, or script language. Others restrict the possibilities to web services.
■      Existing infrastructure: Few projects start from scratch. Existing systems and services should be reused or integrated. Processes can be triggered using an existing scheduler, for example, and not the workﬂow engine itself. These peripheral conditions need to be taken into account.
■      Roles within the project:  It is important to account for existing roles and know-how within the project.  Often, there are developers involved who can implement certain functionalities quickly with classical programming but who will need a long time to do so with the workﬂow engine. On the other hand, there are also projects involving trained process engineers, and they work better with process models than with programming languages.
We often see that once a workﬂow engine has been procured, there is impetus to use it come hell or high water, and process models quickly follow that are so detailed that you can’t see the forest for all the trees. These models do not help when communicating with thebusiness, andthey are no easiertomaintainthanclassical programmingcode. Besides, the IT department will hate the more detailed models, and that’s no good to anyone. Suc-cess is all about ﬁnding the right granularity. Modeled processes are a piece of the puzzle, but they are only one piece.
Order received

Order delivery

Order delivered
Order delivered

Internal post-processing

Order fullfilled
Status requested
Workflow engine
Status inquiry
Customer
FIGURE 6.7  A bad example of modeling. It models too many aspects of the process.
Figure 6.7 shows an example of going too far. The model shows a customer status inquiry explicitly.  At the moment, it doesn’t matter if we’re modeling this process with a signal
6.4 Practical tips	185
Workflow engine
Order received

Order delivery

Internal post-processing

Order fullfilled
Status request of workflow engine
Workflow
engine
or
software
service
Customer
FIGURE 6.8  The model improved by removing status inquiry from the process.
event (as shown), or with a condition event, or perhaps even with a terminating end event; you can see how complicated the process becomes.  It probably isn’t such a good idea to integrate the inquiry into the actual order process.  It would be better to model it in its own process or to use a simple service to query the state of the workﬂow engine’s instance. The only requirement on the engine is that the status must be retrievable. Now look at the modelinginﬁgure6.8. Whethertheinquiryiscarriedoutasaprocessorasasimpleservice depends on the architecture.
Hint: Business-IT-alignment
Business-IT alignment doesn’t mean that software can no longer be developed conven-tionally. It does mean introducing the workﬂow engine and graphical views of technical processes as additional tools.  But beware of process models that are too ﬁnely granu-lar!  Use diagrams in a way that enables business users to understand the technically executable models.
6.4.5	Overcoming technical challenges
InautomationprojectsbasedaroundBPMNandDMN,therearesomepatternsandpitfalls that we would call typical. They depend on the technical environments and the tools used. Vendors address many problems with their features and extensions, so it is hardly worth going into too much detail in this book. Instead, let us give you some examples that will support your understanding of the kinds of problems you may encounter.
Data in the process
An exciting discussion always takes place in a project: How much data do we want to store in the process? Surely we’ll need all order data for an order process, won’t we? Our recom-mendation would be the opposite: Store as little as possible —but as much as necessary. It is usually a good idea to store order data in the preceding system for orders. Then, for the process itself, just reference the order number. If the process needs more information to
186	6  Workﬂow Automation
Sales
support a decision at a gateway, for example, it can load the order data using a service call. This has advantages:
■      The data is always up-to-date and there is no risk of divergence.
■      You do notneedtostore data redundantly inthe processwhere itmay persistindifferent versions —meaning multiple times.
Exceptions conﬁrm the rule, however, and our experience shows that there are times to keep data in the process:
■      The preceding system is too slow. Constant loading leads to a performance issue. In this case, you could use a cache, or you could abuse the engine as a cache.
■      You want to keep a copy of the data as it existed at a particular moment in the process and to use it for the duration of the process run.
■      Your BPM platform does not make it possible to load data in the background.  If this means you have to model a service task over and over just to load the order, your model quickly will become unreadable. As we said, it’s about ﬁnding the right balance between graphical modeling and programming behind the scene.
■      You only store data needed for controlling the process ﬂow, for example, decisions in user tasks not available from other systems.
■      Often it may be desirable to store messages in an as transmitted form. This can make it easier to repeat service calls or to identify errors.
Being ready-to-receive to receive events
From an automation point of view, intermediate events deserve a closer look. First, con-sider the semantics of the ready-to-receive state we mentioned in section 2.6 on page 43. Remember that, strictly speaking, incoming events are lost if no process instance is ready
Delivery requested
Send invoice
Sales

Some engines can buffer the message until the token arrives here
Delivery sent
Route planning system
Delivery requested
Send invoice
Delivery sent
Route planning system
FIGURE 6.9  Never miss a message, even if the process is not ready to receive. A feature of the workﬂow engine or explicit modeling?
6.4 Practical tips	187
to receive them. Looking at the example in the upper part of ﬁgure 6.9 on the facing page, a delivery order is sent to route planning, then the invoice goes out. If send invoice is a hu-mantask, itmaytakesometime. Thedeliverysent messagemaycomeinbeforetheinvoice is ready, but we don’t want to lose the message.
In technical modeling, pragmatism usually gains the upper hand —and modeling that is completely correct can seem unclear. In principle, workﬂow engines can solve the issue of an out-of-sequence message by buffering the message. This is an extension of the BPMN standard.  If you have this functionality at your disposal, we recommend that you make your approach visible in the model with an annotation.
By the way, buffering a message in an engine usually raises an immediate question: What happens if a process never pulls the event out of the queue? The message sender can’t be informed. This meansthat sophisticatederror handlingneeds to recognize whena process instance terminates the correlated event. As you can already tell, this is no mean feat.
You may have no choice but to restructure the model. You can wait for the event in parallel. As ﬁgure 6.9 on the preceding page shows in the lower part, a working alternative is not difﬁcult. This restructuring shouldn’t cause a problem for IT, should it? At the very least, the diagram has become more complicated, and that’s a problem in terms of business-IT alignment. Even this modeling does not always have to be consistent because in some technicalenvironmentstheanswermayarrivebeforetheprocessmovestowardthereceive event. Here, again, the devil is in the details.
Testing processes
Testing processes and decisions is crucial. Executable models equate to source code, after all. They need testing in the same way and, as is now common in software development, the tests should be automated. Automated testing has the great advantage of being repeat-able at any time at no additional cost. If you change the process, you can repeat the testing to conﬁrm that you haven’t broken anything.  Of course this approach means that when you change the model sufﬁciently, you also have to adapt the test cases. It may seem at ﬁrst that testing comes at the price of agility, but our experience suggests that you have to take a longer view. Agility is preserved over time because otherwise, at some point, no changes will be possible. You will have become too worried about breaking something.
There are now exciting frameworks for automating tests that make the writing of tests easy to read or that allow test cases to use tables or languages readable by normal people.  In addition, mocks make it possible for process tests that are not necessarily integration tests. In other words, during a test, services from the surrounding systems are not called up. This then makes unit tests possible that can be automated easily and without placing a burden on the environment —as long as the engine supports them.
Processes are typically tested with speciﬁc scenarios that illustrate a run-through of the BPMN model.
6.4.6	Acceptance criteria when introducing a BPM platform
If you want to introduce a BPM platform, there are more than technological challenges to overcome. Some aspects we have already addressed:
188	6  Workﬂow Automation
■      The relevance of business-IT alignment through a suitable methodology as suggested in this book.
■      The roundtrip, so that all stakeholders understand the executed models that represent the truth.
■      The right granularity of models, so that they contain only business-motivated issues.
The approach taken when introducing a BPM platform also is important, in particular the choice of tool and the ﬁrst steps undertaken with the platform.  In our experience with projects, the approach shown in ﬁgure 6.10 has proved itself.
3UR]HVV $UFKLWHNWXUXQG /DQGNDUWH HQWZLFNHOQ
$WILUVWGRMXVWHQRXJKWRLGHQWLI\OLJKWKRXVHSURFHVVDQGWRDUJXHIRU%30DSSURDFK
%303RWHQWLDO DQDO\VLHUHQ

3URGXNWH HYDOXLHUHQXQG .DQGLGDW DXVZlKOHQ

/HXFKWWXUP
3URMHNW	3URMHNWYRUEHUHLWHW DXVZlKOHQ
3URRIRI
&RQFHSW32&	32&XPJHVHW]W GXUFKIKUHQ
3LORWHQWZLFNHOQ

%HWULHE YRUEHUHLWHQ

/LYHVHW]HQ                           3LORWSURMHNW XPJHVHW]W
3LORW YHUEHVVHUQ
3LORWUHYLHZHQ	    ZHJHQ /HXFKWWXWP
&KDUDNWHU

%HUHLWIUQHXH 3URMHNWH
:HLWHUH 3UR]HVVH XPVHW]HQ
(LJHQH DQJHSDVVWH %303ODWIRUP HUVWHOOHQ

'RDVOLWWOHDVSRVVLEOH DVODWHDVSRVVLEOH
FIGURE 6.10  Best practice for introducing a BPM platform.
It’s hard to carry out a sensible evaluation. We regularly see long tables with feature wishes sent to vendors of BPM platforms.  The expected answers are yes, no, maybe —so that a score can be easily tallied.  Of course, the following happens:  The vendor who wants to obtain a high number of points replies yes as often as possible. That’s how he expects to get hisfootinthedoorduringanearlyevaluationphase. Featuresmayhurriedlybeintroduced justtobeabletohavemoreyesanswers. Whetherornotthefeatureisreallyagoodsolution for the fundamental requirements is sometimes secondary. We had a revealing experience of this when an employee of a potential client called us up secretly and said: "You said no at some places where your competitors said yes. I know that your software is better than the competition’s in this area. Please don’t be too honest, otherwise we will end up having to choose the wrong tool!"
As we keep saying, process automation projects are always software development projects. If you accept this, then you can see it is not necessary for every requirement to be covered by a zero-code tool.  You will remain able to solve many requirements with conventional
6.4 Practical tips	189
software development, and you won’t necessarily need to hear yes to every item on your wish list. A maybe may sufﬁce when it means it can be implemented in the project.
What is appropriately decisive? We would ask: Does the platform offer extensions so that you can implement requirements yourself if needed? Questions of implementation effort remain, of course, and of course, prefabrication by the vendor remains desirable. But the worst thing is a boarded-up platform that leaves you at a dead end. Too rarely do prospec-tive clients inspect the BPM vendor’s philosophy or vision deeply enough to understand if there is consonance with their own.
Once you have determined a suitable candidate, we recommend a proof of concept (POC) that implements one of your processes in the planned target environment. By all means, let the vendor assist with this; it will be quicker. In any event, make certain you are present to truly experience how process applications are generated, what effort goes into them, and what kind of know-how is required. Also be alert to tricks that the vendor’s consultants may have up their sleeves, tricks they may be applying secretly to hide shortcomings in their own products.
Prior to the POC, you have to be absolutely clear about your goals. Are you seeking to verify if the tool will ﬁt into your architecture and is able, for example, to call up your speciﬁc services correctly? Do you have a whole catalog of questions you are seeking to put to the vendor? Are you looking to showcase a wide variety of choices as a way of selling BPM or a particular tool to decision makers within your own company? The POC will be designed differently for different goals. It’s therefore essential for all parties to be clear on what the goal is.
Once you decide on a tool, you should move quickly to implement a suitable process. Put this process into live operation! Suitable processes should be:
■      Relevant, preferably close to the core processes of the business.
■      Not too small, otherwise it will seem too easy, and it will make it difﬁcult to show off the project as a BPM success story.
■      Not too big, or you risk taking too long to deliver results.
■      Not a political mineﬁeld. Unfortunately, this often is the case with business processes.
■      Suitable for displaying the advantages of BPM. Remember that the ﬁrst project will be used to decide on how to proceed.
■      Not too demanding on organizational change. Suggesting too much change only gener-ates resistance that can be overcome only with a lot of willpower and endurance. It isn’t helpful to expect much change while also introducing a new technological platform. On the other hand, organizational change cannot be completely avoided —and a desire for change is usually what triggers the introduction of the BPM platform in the ﬁrst place.
In the context of that ﬁnal point, by the way, it may be a good idea to keep an existing task listandtoentertasksforthenewBPMplatformintoit. Thisimpliesthatendusers(process participants) do not need to use either a new interface nor two different task lists. If you are replacing an existing workﬂow management tool, the change could be transparent to end users.
In your ﬁrst project, you should move forward as quickly as possible and not spend too muchtimeonconventions,patterns,orsettingupyourownprocess-applicationblueprint. You will learn so much during the ﬁrst project that you will be better off to plan time after
190	6  Workﬂow Automation
the project for analysis and documentation of lessons learned and best practices. Best of all will be to review your process once more after the fact.  It will surely have a spotlight on it, and you can hope that many others will seek to copy what you did. To summarize: Revising your ﬁrst project afterwards will cost you a lot less than trying to get it completely right the ﬁrst time. In principle, this is us recommending an agile approach.
Armed with this, you can venture out conﬁdently to meet your next projects. We hope you have lots of fun automating your business processes!  Further information on BPM tools can be found in section 7.4.1 on page 202.
7
7.1	Goals

Introducing BPMN on a broad base
Over the last several years, we have helped many organizations introduce BPMN, and not just for a few people or for a few processes.  Our work was intended to introduce BPMN broadly, and to model processes in a standardized way throughout an entire division or even a whole company.
"At our company, one person draws processes using Visio, another describes them in Word orPowerPoint,andathirdusesExcel. SomebodyalsointroducedaBPMtoolatsomepoint, but that has its own notation. Now we have an excess of different process models, and that complicates our work considerably!"
We hear this type of statement often as we prepare to introduce BPMN. It is a mistake sim-ply to buy a new BPMN tool and then to expect instant improvement.  Even if all a com-pany’s modelers start using BPMN as a common language, its complexity can still result in widely divergent models. Even worse, it can result in modelers who become overwhelmed, and then frustrated, and who then give up. It doesn’t help that process modeling and mod-elers are generally underrated. Have you heard anything like the following?
"Most importantly, the tool must be easy to operate. That way, we can ﬁnd an inexpensive studenttraineetointerviewthestafftoﬁndouthowthey work, andthenthetraineesimply draws the diagrams. Can’t be that hard!"
But it is hard.  We believe that most of the infamously unhandy process wallpapers from the nineties continue to gather dust in ofﬁce cabinets because of this misunderstanding. Those who think of process modeling as merely a laborious task produce much paper and little beneﬁt.
In contrast, a successful introduction starts with clarifying and prioritizing concrete goals. This is harder in practice than it may seem because, too often, goals are expressed in a vague manner. A few examples:
■      We want to make our processes transparent. ■      We want to maximize customer orientation. ■      We want to optimize the process efﬁciency.
All thosegoalssoundplausible, don’tthey? Ifyou, asaprojectmanager, weregiventheseas directivesbymanagement,youwouldn’tquestionthem. Ouradvicethough,istodoexactly that, and as quickly as possible! Why? Because these goals are not S.M.A.R.T. (S.M.A.R.T. is
192	7  Introducing BPMN on a broad base
ZŽůĞƐ
DĞƚŚŽĚƐ	'ŽĂůƐ	dŽŽůƐ
WƌŽĐĞƐƐĞƐ
FIGURE 7.1  Clarifying goals is critical.
an acronym for Speciﬁc, Measurable, Attainable, Relevant, and Timely. See the Wikipedia entry at http://en.wikipedia.org/wiki/SMART_criteria.)
■      Speciﬁc: Clear, precisely expressed goals leave little room for interpretation.  What ex-actly is meant by transparent processes, for example? Does it mean that they are all docu-mented? To what level? In what form? For which target group? How does one recognize when an appropriate level of transparency has been reached?
■      Measurable: You have to be able to verify that you’ve reached a goal.  So how will you know if customer orientation has improved, much less been maximized? Besides, how does that goal connect to your BPM or BPMN project?
■      Acceptable: The people responsible for executing against the goal must accept it as ad-equate and attainable. If you expect your team of three people to optimize all processes in a 1,000-person company within six months, don’t be surprised if the project fails.
■      Relevant: Do your goals matter to the people your work will affect? Are they in keeping with your organization’s purpose and suitable for the environment in which it operates?
■      Timely: Without expressing clearly when the goal should be attained, expect resources to be pulled off-task constantly to deal with more urgent, short-term issues. Your project ﬁzzles out.
Almost as important as clearly deﬁned goals is unambiguous priorities.   Perhaps your project team can’t really achieve all the stated goals. Without clear priorities, however, the team may try to achieve all goals equally —and it may fail to achieve them equally too! Process documentation is a frequent victim of this: Somehow or other, you get it done as quickly as possible. You check it off ofﬁcially without blowing the budget or the schedule. The result is a sad excuse for documentation, and it ends up gathering dust next to the process wallpaper. It’s a waste of time and energy from the outset.
With clearly deﬁned goals and unambiguous priorities, you can discern what roles, meth-ods, tools, and meta processes will be required to apply BPMN successfully. These are the four topics to keep constantly in mind while preparing to introduce BPMN, and while in-troducing BPMN. We will explain each in detail in the following sections.
7.2 Roles	193
In the end, success depends on recognizing what your goals imply.  If all the processes within a company, for example, are to be documented to achieve ISO 9001:2000 certiﬁca-tion, then the roles, methods, tools, and meta processes you deﬁne for that goal will be different from what you deﬁne to automate certain core processes with a technical BPM platform. It is also important to take the goals of the BPM or BPMN project seriously, and to carry the project through in all its details.
7.2	Roles
7.2.1	Of gurus, followers, and unbelievers
As with so many things, the successful introduction of BPMN depends on the people in-volved. It is false to believe that BPMN or process modeling can be learned along the way. They’re too complicated for that, and both things require a lot of practice and experience before modeling processes in BPMN becomes second nature. Consequently, an organiza-tion must recognize that BPMN cannot be rolled out widely or quickly. First, create kind of an epicenter —a group of top-notch experts in methods —BPMN gurus. These people should possess certain attributes:
■      They really understand BPMN completely.
■      Even if they don’t have years of experience in BPMN, they can build it quickly, practicing its implementation as often as possible.
■      They are highly interested in BPMN, certainly, but also in Business Process Management ingeneral,andtheysupportandinspiretheirfellowworkerswiththeirpassionandcom-petence.
■      They are accepted and appreciated as the authoritative BPMN experts within the orga-nization.
We don’t claim that gurus like these are enough to ensure success, but we can say applying BPMN on a broad base without these gurus is doomed to fail in most cases.
At the opposite end of the know-how scale are the unbelievers.  Don’t worry.  It isn’t as though you have to convert these people to your way of thinking. The unbelievers are sim-ply all the people in the organization who have no interest in BPMN and who view it, at most, as an instrument for process improvement. They are not keen to deal with the sym-bols,thesyntacticalrules,andcertainlynotthesubtletiesoftokenﬂows. Asyou’veguessed, the unbelievers are the majority of your fellow workers. They are executives like the pro-cess owner or process manager, and they are also the process participants who work in the processes.
You shouldn’t resent the unbelievers for their attitudes, nor should you think about chang-ing them. Focus instead on how best to involve your colleagues on the front lines in work-ing with BPMN. You can’t really expect unbelievers to create meaningful and formally cor-rect BPMN process models; the learning curve is too steep.
If you think of our framework, you can expect unbelievers to model no deeper than the strategic level. Even then, expect that the gurus will have to check the model for quality. It’s
194	7  Introducing BPMN on a broad base
unreasonable to expect unbelievers to model operational process models, much less tech-nical process ﬂows. Reading the models is a different matter: Most unbelievers are able to interpret operational process diagrams after a brief explanation of the symbols (especially if they are shown only their own pools as described in section 4.3 on page 122). So we need not only to distinguish among the levels, but to distinguish also if a given person can create a model him- or herself, or just interpret it (see ﬁgure 7.2).
^ƚƌĂƚĞŐŝĐŵŽĚĞů KƉĞƌĂƚŝŽŶĂůŵŽĚĞů ,ƵŵĂŶƉƌŽĐĞƐƐĨůŽǁ KƉĞƌĂƚŝŽŶĂůŵŽĚĞů dĞĐŚŶŝĐĂůƉƌŽĐĞƐƐĨůŽǁ

'ƵƌƵƐ
DŽĚĞů                  ZĞĂĚ zĞƐ                      zĞƐ
zĞƐ	zĞƐ
>ŝŵŝƚĞĚ	zĞƐ

&ŽůůŽǁĞƌƐ DŽĚĞů	ZĞĂĚ
zĞƐ	zĞƐ
>ŝŵŝƚĞĚ	zĞƐ
EŽ	zĞƐ

hŶďĞůŝĞǀĞƌƐ DŽĚĞů	ZĞĂĚ >ŝŵŝƚĞĚ                   zĞƐ
EŽ	zĞƐ
EŽ	>ŝŵŝƚĞĚ
FIGURE 7.2  Model processes or read models: Who can do what?
In larger organizations, it may not be enough to differentiate between gurus and unbeliev-ers. Just as a religious guru needs followers, a BPMN guru sometimes needs someone else to disseminate the good news, or who can negotiate between the guru and the unbelievers. These BPMN followers, as we call them, ﬁnd BPMN interesting, but are not as crazy about it as are the gurus.  Because they work alongside their unbelieving colleagues, they usu-ally know the daily business well. But they were given the time or had tasks that exposed them to BPMN as supported by the gurus to the extent that they can do process modeling to a certain standard. Followers have become able to transfer the activities of unbeliever colleagues into meaningful process models.  They feel comfortable approaching the gu-rus with questions or problems or to seek advice on how best to model given situations. The followers are, to some extent, the representatives of the respective divisions regarding BPMN issues. As such, they can take some of the workload off gurus and unbelievers alike.
7.2.2	Anchoring in the organization
First of all, organizations should not hire external consultants as BPMN gurus, at least not on a continuing basis.  We have been in that situation often, and from a short-term eco-nomic point of view, it is not that bad for a management consulting ﬁrm. But if a company wants to be successful with BPMN in the long term, the consultant must advise against such a strategy. BPMN gurus within the company are supporters as well as driving forces, and they need to be available every day. It is a decisive role that cannot be ﬁlled by external consultants who are in-house sporadically and only for a limited time.
Potential BPMN gurus are likely to pop up in the company’s business operations or IT de-partments. Thisresultsinaninterestingsituation: Gurustatuscomeswithacertaincontrol over BPM. If both business operations and IT departments exist, who gets control? Things can get political fast, and they can devolve into unproductive feuding.
There’s no single right answer for how to deal with this question. Some project organizers claim BPM (under the label of process management) for themselves. No one can deny that IT plays a much bigger role in BPM than it did in the 1990s, but IT experts don’t necessarily understand BPM from the organizational point of view. Similarly, geniuses in operations
7.2 Roles	195
may lack insight into the technical aspects. Project responsibility belongs in the hands of someone who understands and appreciates both points of view. As a general rule, anyone who is inclined to dismiss the competences and concerns of either party is a poor choice to lead the project. The following two quotes vividly illustrate what we mean:
■      Business operations:  "We have no idea what the IT guys down there actually do, and basically, we don’t care. IT has to function; how they do it is not our problem. We only give speciﬁcations. It’s not for nothing that they say ’IT follows business!’"
■      IT: "We sometimes ask ourselves what those ops guys are actually paid for.  Sitting in meetings all day long, drawing arrows and rectangles...that’s not really work, is it? And then, when they ﬁnally give us their requirements, they are so absurd that we can’t do anything with them! Anyway, we understand what’s needed better than they do."
The only solution in such a situation is to form a joint committee, a BPM Competence Center (BPM CC). The Center involves the BPMN gurus, who act as the contact persons for the BPM representatives from the various divisions (see ﬁgure 7.3).
dŽƉŵĂŶĂŐĞŵĞŶƚ ;DĂŶĂŐĞŵĞŶƚďŽĂƌĚ͕ĞƚĐ͘Ϳ
WDŽŵƉĞƚĞŶĐĞ ĞŶƚĞƌ;WDEŐƵƌƵƐͿ
ŝǀŝƐŝŽŶ
WƌŽĐĞƐƐƌĞƉƌĞƐĞŶƚĂƚŝǀĞ ;WDEĨŽůůŽǁĞƌͿ
WDEͲhŶŐůćƵďŝŐĞƌ WƌŽĐĞƐƐƉĂƌƚŝĐŝƉĂŶƚƐ ;WDEƵŶďĞůŝĞǀĞƌƐͿ
WDEͲhŶŐůćƵďŝŐĞƌ

ŝǀŝƐŝŽŶ
WƌŽĐĞƐƐƌĞƉƌĞƐĞŶƚĂƚŝǀĞ ;WDEĨŽůůŽǁĞƌͿ
WDEͲhŶŐůćƵďŝŐĞƌ WƌŽĐĞƐƐƉĂƌƚŝĐŝƉĂŶƚƐ ;WDEƵŶďĞůŝĞǀĞƌƐͿ
WDEͲhŶŐůćƵďŝŐĞƌ

ŝǀŝƐŝŽŶ
WƌŽĐĞƐƐƌĞƉƌĞƐĞŶƚĂƚŝǀĞ ;WDEĨŽůůŽǁĞƌͿ
WDEͲhŶŐůćƵďŝŐĞƌ WƌŽĐĞƐƐƉĂƌƚŝĐŝƉĂŶƚƐ ;WDEƵŶďĞůŝĞǀĞƌƐͿ
WDEͲhŶŐůćƵďŝŐĞƌ

ŝǀŝƐŝŽŶ
WƌŽĐĞƐƐƌĞƉƌĞƐĞŶƚĂƚŝǀĞ ;WDEĨŽůůŽǁĞƌͿ
WDEͲhŶŐůćƵďŝŐĞƌ WƌŽĐĞƐƐƉĂƌƚŝĐŝƉĂŶƚƐ ;WDEƵŶďĞůŝĞǀĞƌƐͿ
WDEͲhŶŐůćƵďŝŐĞƌ
FIGURE 7.3  Typical allocation of BPMN gurus, followers, and unbelievers in an organization.
7.2.3	Training of BPMN gurus
If the success of introducing BPMN depends on the in-house gurus, how can you help your candidates become qualiﬁed?  Reading this book may not be a bad start, and attending one of our excellent workshops (or one of another provider) also may help. Certainly, hu-mans learn best by doing, so you can’t start applying BPMN early enough. Without prac-tical application, gurus-in-training quickly start to lose what they learned in even the best workshops. We have found the following process successful:
1.  Read the BPMN book to understand the basics and to be able to assess if BPMN can be helpful to your work.
2.  Attend a workshop or hold one in your company.
196	7  Introducing BPMN on a broad base
3.  Use BPMN, ideally in your own work, but if that’s not practical, try modeling kitchen recipes (seriously!).
4.  Optional: Have your modeled processes reviewed and corrected by a BPMN expert, per-haps an external consultant or trainer.
There is another step, not always easy to realize, but it has proved astonishingly fruitful: In initial training, we show typical beginner’s mistakes. These nevertheless crop up within a few weeks when we review students’ models.  For some reason, such mistakes have to occur in your own work before the lesson sinks in. This applies even more to certain best practices that can be applied when modeling processes.
Those most serious about achieving guru status can get ofﬁcial certiﬁcation from the Ob-jectManagementGroup(OMG).AnOMGCertiﬁedExpertinBPM(OCEB)issomeonewho, depending on the stage of certiﬁcation, has passed the OMG’s test. The ﬁrst test certiﬁes at the fundamental level, that is, in the basic essentials of BPM. About 40% of these questions refer to BPMN and get fairly well to the heart of the matter. You can expect that someone certiﬁed at the OCEB Fundamental level to have a good knowledge of BPMN. After Fun-damental come Intermediate and Advanced certiﬁcations.  There are business and tech-nical variants for each level. This depends on where the participant wants to focus his or her competencies. (See ﬁgure 7.4.) If you want to know more about OCEB, visit the OMG homepage (www.omg.org/oceb/) or a training at Camunda (http://camunda.com/oceb/).
%XVLQHVV$GYDQFHG
%XVLQHVV,QWHUPHGLDWH

7HFKQLFDO$GYDQFHG
7HFKQLFDO,QWHUPHGLDWH
)XQGDPHQWDO
FIGURE 7.4  Stages of certiﬁcation pursuant to OCEB.
7.3	Methods
BPMN alone will not be sufﬁcient to model the business reality in most projects.
Documenting the process landscape presumably requires something like a process map, that is, a clear representation of all processes in the company. You then reﬁne the process map until you end up with individual BPMN sequence diagrams.  You may wish to link these with organizational charts to show the relationships between operational and orga-nizational structure. Perhaps you’ll even decide to write operating procedures down to the most detailed level, and then assign these to tasks in the BPMN diagram.
On the other hand, if you want to model processes in the context of IT projects, you will probably need to deﬁne data structures as well as describe the pure process, which can be represented in the IT solution. You therefore resort to UML class diagrams, which you have
7.3 Methods	197
to link reasonably with your BPMN diagrams. The same applies to screen designs, use case diagrams, and so on (see section 4.4.5 on page 132).
The ﬁrst questions in the methodical cluster are therefore: In what methodical context is BPMNtobeappliedandhowcantheBPMNdiagramsbecombinedsensiblywiththeother modeling notations?
Thenextquestionisaboutmodelingconventions,theguidelinesforprocessmodelingwith BPMN. It almost always makes sense to deﬁne BPMN guidelines, because:
■      BPMN is a comprehensive modeling language, and it may overtax beginners.
■      You can model the same situation in different ways in BPMN, which complicates both standardized modeling and the mutual understanding we hope for when reading mod-els.
■      A guideline is a hands-on aid to orientation, which increases the acceptance of the nota-tion, especially for beginners.
■      The bottom line is that guidelines make modeling easier and faster while ensuring high quality in the process models.
Which guidelines make sense depends on what you want to achieve with BPMN. If your goal is process documentation, you will need different guidelines from someone whose goal is requirement engineering for IT projects.  Think about the Camunda house in this context: The choice of the modeling level and thus the choice of method arise from what you want your modeling to accomplish.
Regardless of the goals, we have established that the following categories make sense in all guidelines.
7.3.1	Range of symbols
For a start, deﬁne a subset of available symbols. This helps, especially in the beginning, if everyone isn’t familiar with the whole set. For BPMN followers who may not achieve a deep mastery of BPMN, the smaller, clearer palette works.
The range of symbols we use depends on the level at which we are working. In section 3.3 on page 102, we introduced the subset for the strategic level. At the operational level, we normally restrict the palette for human process ﬂows only a little.  For technical process ﬂows, the range depends on the BPMN symbols supported by the designated workﬂow en-gine. Regrettably, we cannot assume that every ofﬁcially BPMN-compatible BPM software product actually recognizes all the symbols.
On the other hand, it can make sense to extend the palette with custom artifacts (sec-tion2.11.2onpage88). Thatmayseemcontradictoryatﬁrst: restricttherange,thenextend it? Custom artifacts frequently solve modeling problems that the default BPMN symbol set cannotsolve. Weknowseveralinsurancecompanies,forinstance,whichhavetodocument risks in their processes for legal purposes. These BPMN users include a red warning trian-gle among their symbols, and they use it whenever it makes sense.  The important thing here is to observe the syntactical rules for artifacts and never connect the custom symbols directly to the sequence ﬂow —always link them by associations to ﬂow objects.
198	7  Introducing BPMN on a broad base
7.3.2	Naming conventions
Within the scope of the modeling etiquette in section 2 on page 23, we enlarged upon the pattern we use to designate certain symbols. For example, we use the pattern [verb] + [ob-ject] for tasks, and the pattern [object] + [state] for events.  There are situations in which you cannot follow these conventions, of course, though you should try.  Beginners espe-cially tend to make mistakes that can be prevented by following naming conventions. Fig-ure 7.5 shows an extreme example. Do you think it’s unlikely even for a beginner to make such an obvious mistake? We have experienced it often. If the modeler follows a naming convention when labeling tasks, the chances are good that he or she will see the mistake and self-correct.
Another example is shown in ﬁgure 7.6.
Application OK
Process terminated
Check application
Process started
Application not OK
Process terminated
FIGURE 7.5  Wrong: The branching conditions are contained in the tasks.
Variant 1
Variant 2

New transaction to be processed
New transaction to be processed

Process transaction
Process transaction

Close transaction
Close transaction

Transaction closed
FIGURE 7.6  Variant 1 violates the naming convention for events.
This isn’t a mistake, but rather a difference of opinion on whether the close transaction activity should be modeled as an event or as a task. You may think that it is clearly a task, but in practice, we ﬁnd that ﬁnal activities like this often slip in. This may even be correct for certain end events like the message end event. Particularly in the beginning, however, a mutual understanding on what a none end event symbolizes should be established, and thatitmeansnothingotherthansettingastatus. Withoutthisunderstanding,someofyour co-workers may model the ﬁnal activity as an end event (as in variant 1), and others may model it explicitly as a task (as in variant 2). In more complex models, this kind of small difference can grow into another hurdle for understanding and acceptance.
7.3 Methods	199
When securing naming conventions in a guideline, we use a simple pattern, which we also apply to other guidelines:
■      Speciﬁcation: One short, concise sentence speciﬁes the actual guideline.
■      Explanation: A short explanation helps the modelers to understand the intention and to accept the guideline.
■      Example: Accordingtoexperience, mostmodelerstakeanimmediatelookatthesample process model illustrating the implementation of the guideline.
■      Counter-example:  One or more counter-examples also help to drive home what the guideline means.
Other reasonable naming conventions may deal with the labeling of subprocesses, gate-ways, and pools.
7.3.3	Layout
This category deals with guidelines about the visual appearance of process diagrams. They make diagrams more uniform and somewhat more readable by guiding the sequence ﬂows in ways that do not confuse. For example, a guideline may specify how to represent XOR gateways:
■      Speciﬁcation: Always represent the XOR gateway with an X in its middle.
■      Explanation: The X instantly distinguishes the gateway from other types of gateways, and so it reduces the risk of confusion.
■      Example and counter-example: See ﬁgure 7.7.
OK?
Example	Yes
No
Counter-example

OK?
Yes
No
FIGURE 7.7  Example and counter-example for representing an XOR gateway.
7.3.4	Modeling alternatives
While the layout only affects the visual representation, guidelines from this category de-termine which of the various BPMN options should be used to model certain situations. These situations, however, must be presented as very general and abstract; they should not refer to speciﬁc contents of processes or process fragments. That’s the case with the design patterns in the next section.
200	7  Introducing BPMN on a broad base
The example refers to applying end events:
■      Speciﬁcation: End events with a similar content should be summarized in one symbol. End events differing in content should be modeled separately.
■      Explanation: This way, the viewer will know faster that different end states are possible, and he or she will recognize the respective state sooner.
■      Example and counter-example: See ﬁgure 7.8.
([DPSOH
<HV

<HV
&KHFN FRQWHQWRI DSSOLFDWLRQ

5HJLVWHU FKHFN SDVVHG
2."

$SSOLFDWLRQ LV2.
$SSOLFDWLRQ WRFKHFN

&KHFN
DSSOLFDWLRQIRU	2." FRPSOHWHQHVV

1R

1RWHSUREOHPV UHJDUGLQJ FRQWHQW
1R	   1RWH PLVVLQJ
GHWDLOV

$SSOLFDWLRQLV QRW2.
&RXQWHU H[DPSOH

<HV
&KHFN <HV	FRQWHQWRI
DSSOLFDWLRQ

5HJLVWHU FKHFN SDVVHG
2."

$SSOLFDWLRQ LV2.
$SSOLFDWLRQ WRFKHFN

&KHFN
DSSOLFDWLRQIRU	2." FRPSOHWHQHVV

1R

1RWHSUREOHPV UHJDUGLQJ
FRQWHQW	$SSOLFDWLRQLV QRW2.
1R	   1RWH PLVVLQJ
GHWDLOV

$SSOLFDWLRQLV QRWRN
FIGURE 7.8  The positive example has one consolidated end event in case the application is not okay.
7.3.5	Design patterns
We describe design patterns differently than we do guidelines.  A design pattern is like a recipe: Itcanguideyou,butitrequiressomeabstractionforthepatterntoapplyindifferent situations. Compared to guidelines, design patterns are much more ﬂexible.
7.3 Methods	201
■      Requirement: Describes in what situation the design pattern can be helpful.
■      Recommendation:  Refers to a pattern (from among those that follow), then recom-mends it. The recommendation may depend on the section of the Camunda house that the model falls into.
■      Available design patterns:  The design patterns suitable for the situation are shown through examples.
For example, here are the design patterns for a two-stage escalation:
Requirement
I want my interaction partner to do something, so I send her a message: an invoice to be paid, an item to be delivered, or an instruction to be executed.
My interaction partner does not react. After a while, I remind her of my request, and I may set a new deadline.  If necessary, I can repeat this several times, but eventually I have to escalate the process (by forwarding the invoice to a debt collector, by canceling the order for the item, or by informing a superior of non-performance).
Recommendation
From the following design patterns, we recommend event-based gateway with loop.  It is clear, easily understood, and formally correct. Because modeling technical process ﬂows depends on the workﬂow engine, however, if the selected engine cannot interpret the event-based gateway, you can instead use attached timer events.
Available design patterns
Figure 7.9 on the following page illustrates the available design patterns using the example of ordering a pizza:
■      Event-based gateway with loop: If the pizza has not arrived after an hour, we inquire where it is. Before inquiring, however, we see if we’ve already inquired. This ensures that the inquiry is made only once. Because the process returns to the event-based gateway after the inquiry, the maximum waiting time is two hours.  In addition to the clarity, this pattern allows you to exercise extra patience without having to change the model signiﬁcantly:  Just replace the inquired before question with inquired twice already or even inquired ten times already.
■      Chain-link of event-based gateways: The model behavior is identical to the previous one, otherwise it would not be a valid pattern for this scenario. But now we are chain-linking the event-based gateways. This is less clear and harder to adjust, but you see the number of escalation stages at a glance.
■      Attached timer events: We can model the required behavior without any event-based gatewaybyusinginterruptingandnon-interruptingtimerevents. Wewouldattachthese to a receive task (see section 2.7 on page 61).
202	7  Introducing BPMN on a broad base
Event-based gateway with loop

Order pizza
Hunger noticed

Pizza received
1 hour

Inquired before?
Yes
No

Eat pizza
Cancel order
Inquire

Hunger satisfied
Order canceled
Chain-link of event-based gateways

Order pizza
Hunger noticed

Pizza received
Inquire
1 hour

Pizza received

Eat pizza
Cancel order

Hunger satisfied
1 hour	  Order canceled
Attached timer events

Hunger noticed

Order pizza	Wait for pizza
1 hour	2 hours

Eat pizza
Cancel order

Hunger satisfied
Order canceled
Inquire
Inquired
FIGURE 7.9  Design patterns for modeling a two-stage escalation.
7.4	Tools
7.4.1	Deﬁnition of your own BPM stack
Inthepreviouschapters, wereferredoverandovertothetypicalthingsrequiredofaBPMN tool, by which we mean a software product used to model processes in BPMN: to show the modelstoothers,toanalyzeimprovements,andtodevisenewandimprovedprocesses. We also mentioned workﬂow engines, which execute the BPMN process models technically. A third issue is the development environment that process engineers use to enhance a pro-cessmodeldevisedwiththeBPMNmodelingtool. Thisiswheretheengineerscombinethe model with other technical components such as an Enterprise Service Bus, entity or data models, or user interfaces so that it can be executed in the workﬂow engine. Because the workﬂow engine can rarely function independently, it also needs an environment to take care of executing all the peripheral components of the process such as the user interface. An execution environment complements the development environment.
A rough list of the components in an integral BPM stack is therefore:
■      The BPMN modeling tool
■      The development environment
■      The workﬂow engine
7.4 Tools	203
■      The other technical components of a process application
■      The execution environment
If you don’t plan to implement process applications, and your only interest is in the BPMN modeling tool, skip the next section.  Otherwise, what approach do you want to use for implementing the BPM stack? There are two strategies:
■      Use a product that integrates the entire stack (a one-product stack).
■      Use a combination of products (a composite stack, often referred to as best of breed).
This is not an all-or-nothing supplier decision. There are suppliers who offer a complete composite stack. But will you tolerate the troubles of a loosely coupled stack for the free-dom to swap products in and out? The components of a one-product stack may be more smoothly integrated, meaning it is easier to handle. Because so many things are prefabri-cated, you can develop process applications faster.
With a composite stack, you usually have more design freedom, and you can develop pro-cess applications that are better and more highly customized. The components in a com-posite stack are optimized for their respective purposes (for example, the BPMN modeling tool for process modeling), meaning that they can be superior to the corresponding com-ponents in a one-product stack.  The single product has to be all-in-one.  Okay, maybe it does everything, but it does nothing right!
Are you going to get the source code? That’s a big factor in the one-product vs. composite stack decision. Source code usually is not available with one-product solutions, whereas source code often is available for the composite stack. And while cost is a factor, you re-ally shouldn’t think about saving money on licenses because of open source. (Just because source code is available doesn’t make it open source. Depending on the license, software published with an open-source license can be used for free and even embedded in your own products.) There also are products available for a lump sum or monthly fee that in-cludethesourcecode. Theadvantagesofhavingthesourcecodearenotaboutcosts;rather they are about these potential beneﬁts:
■      You have less dependence on the manufacturer (vendor lock-in).
■      You limit your risk in case the manufacturer is taken over or becomes insolvent.
■      Yougainadeeperandmorenuancedviewintothesoftware. Itisn’tablackboxanymore.
■      You obtain the greatest ﬂexibility in developing applications for your process.
■      You secure the capability to integrate the stack with the company infrastructure:  test automation, version management, deployment, and so on.
Using a composite, open-source BPM stack may only interest you if you have software de-velopers who can work with it. This usually means those who can program in Java. If you employ Java developers, then a stack such as the one we describe in section 7.4.3 on the following page, should be of particular interest. Otherwise, you may be better off sticking with a one-product stack or looking to Software as a Service (SaaS). SaaS represents the easiest and most economical way to create process applications. You’ll need to accept that SaaS platforms, however, create an even higher dependence on the manufacturer and less ﬂexibility in your application development than do other one-platform stacks.
204	7  Introducing BPMN on a broad base
7.4.2	The BPMN modeling tool
"Afoolwithatoolisstillafool."Thisworldlywisdomcertainlyappliestoprocessmodeling, butthatdoesn’tmaketoolchoicesecondaryorevenirrelevant,assomepeoplebelieve. The best craftsman can’t do anything without his tools —except maybe MacGyver.
Ingeneral,youshouldchooseatoolthatcanrepresentalltheBPMNsymbols. Thisway,the choice of which symbols you can do without belongs to you and not to the tool manufac-turer (see section 7.3.1 on page 197). If you want to tinker with BPMN before committing the entire company to it, consider a lower-cost solution. You can switch later.
Camunda provides a free modeling tool that supports BPMN and DMN. It saves models as standard XML ﬁles, meaning that you can execute the models directly in corresponding engines. Camunda Modeler is part of the Camunda BPM Platform; ﬁnd it at:
https://camunda.org/download/modeler/
Currently, Camunda Modeler is a desktop application. We developed it using components that can be used directly in a web browser. A cloud offering that allows collaborative mod-eling is also available at:
https://cawemo.com/
Camunda Modeler focuses on creating models to be executed. While it is user friendly and ideally suited for use by business analysts, it doesn’t provide extensive functions for docu-menting processes. For that, we recommend the following products (listed alphabetically):
■      BOC Adonis (http://www.boc-group.com/)
■      ibo Prometheus (https://www.ibo.de)
■      Signavio Process Editor (http://www.signavio.com/)
All three products support the BPMN standard for modeling as well as for documenting processes. For example, you can add additional work instructions or generate handbooks for employees.   These products let you export your models in BPMN standard format, which can then be used in a BPMN workﬂow engine.  The tools also enable importing, which makes technologically driven changes accessible to business users.
We have experience with all three tools, and we have used them with our own workﬂow engine. We present our engine in the next section.
7.4.3	Camunda BPM: An open source BPM platform
After several years of experience in BPM projects and with many BPM software products, we decided in 2011 to develop our own BPM platform for process automation.  You can call Camunda BPM a open source, composite BPM stack intended mainly for developing process applications in Java. That is why we call it a BPM platform and not a BPM suite.
The basic components are:
■      Modeler: The modeling tool supporting BPMN and DMN already mentioned.
■      Engine: The execution engine that can execute these models.
■      Tasklist: A web application to process user tasks.
7.4 Tools	205
■      Cockpit: A web application to monitor and administer running processes, view reports, or leverage Business Activity Monitoring (BAM).
■      Cycle:  A web application used for the BPMN roundtrip to synchronize the develop-ment environment of the IT department with various business-oriented BPMN mod-eling tools.
■      Admin: A web application to administer users, groups, and authorizations.
It may seem unusual —maybe even impertinent —for us to introduce our own product in a general reference book about BPMN. When we released the ﬁrst edition of this book, Camunda was a consulting company only.  Despite the need for really good, all-around technical BPM platforms, however, we discovered that there weren’t any.  We decided to develop one ourselves.  As declared Open Source followers, we made our product freely available, and we ﬁnanced the entire project with add-on features and support.
The result was so successful that we transformed Camunda into a software vendor in short order. Thatdoesn’tmean,however,thatwe’velostourpassionforthemethodicalquestions of the BPMN application. Quite the contrary!
Many notable companies and authorities now work with our platform, and they are well satisﬁed.  We are conﬁdent that we are contributing to the successful application of the three standards, and so we think it is useful to readers if we reference our product in this book.
You can ﬁnd more information about the Camunda BPM platform in the following places:
■      http://camunda.com/bpm has a description applicable to management.
■      http://camunda.org describes the Open Source project, and it includes downloadable ﬁles and documentation.
7.4.4	It can’t always be software
In your ﬁrst group discussions about a process, it can be constructive to avoid any model-ing using software tools. Why?
■      Only the person at the computer can model. All suggestions by other participants in the workshop have to be ﬁltered through that person. That’s a hurdle.
■      The person working at the computer may not have mastery of the tool, especially in the beginning. This can mean delays and distraction from the work on the modeling itself.
■      Participants often have too much regard for the process model as shown by the software. Eventhoughtheyallknowitisaworkinprogress,theinherentlytidyappearanceinhibits spontaneous ideas, criticism, and suggestions.
The alternative is to draw on an ofﬁce white board, though this can become inconvenient when remodeling or drawing the BPMN symbols.  It gets easier if you prepare movable cards in advance of your workshop. They are easy to make:
1.  Print symbols for tasks and subprocesses on A6 (4x5-inch) stock.  Use A7 (3x4-inch) stock for all other symbols.
2.  Laminate the cards.
3.  Attach self-adhesive magnetic tape to the backs.
206	7  Introducing BPMN on a broad base
FIGURE 7.10  Card with self-adhesive magnetic tape on the back.
Originally, we used a print shop for the printing and laminating; attaching the magnetic strip involved some cumbersome handiwork (ﬁgure 7.10), but it was worthwhile. Partici-pants have used our cards like this:
1.  Use a marker to label the small cards.
2.  Start laying out the process only by placing and moving the cards around.
3.  As you reach agreements, draw lines to connect the cards where that is helpful.
Add lines for ﬂows, pools, lanes, and so on only toward the end of the procedure.  Doing this while the picture is still evolving is too cumbersome (see ﬁgure 7.11 on the next page).
All this is helpful for exercises, initial surveys, and discussions of simple processes. It also worksforroughlyrepresentingcomplexprocessesortorepresentprocessfragmentsdetail. Everyonecanjoinin, andthereisno computeror softwareto inhibitparticipation. You can even add custom artifacts. At the end, you transfer this work into the tool.
At the Hasso Plattner Institute in Potsdam, Dr.  Alexander Lübbe has developed tangible bpm (t.bpm). The approach uses Plexiglas blocks in the shapes of BPMN activities, events, gateways, and data.  Participants use the blocks to model processes on a table (see ﬁg-ure 7.12 on the facing page), demonstrating their ideas by placing and arranging the blocks on the shared work surface.  The result is captured in the process model.  Alex’s research proves that t.bpm strongly motivates participants to contribute, and the process model they design themselves receives a great deal of critical checking during the workshop. An-other result of the teamwork is high acceptance for the solution. For more information, see www.t-bpm.de.
7.4 Tools	207
FIGURE 7.11  After the lines are drawn, shifting them is a little impractical.
FIGURE 7.12  Tangible BPM in use.
208	7  Introducing BPMN on a broad base
WƌŽĐĞƐƐŽǁŶĞƌ
7.5	Meta-processes
In section 1.1.3 on page 2, we introduced the Camunda BPM life cycle for business pro-cesses and its stages:
■      Survey
■      Documentation
■      Analysis
■      Design
■      Implementation
■      Controlling
These stages can be themselves seen as processes; they form meta-processes, and we have to clarify exactly how these meta-processes are to be handled, at least if BPMN is to be applied in more than one project or across teams of varying composition. This responsi-bility lies reasonably with the BPMN gurus.  By describing meta-processes, the issues of roles, methods, and tools grow together. We can examine this with the example of a typical process to survey and document business processes (ﬁgure 7.13):
Process is to be documented
WƌŽĐĞƐƐŵĂŶĂŐĞƌ

Document process

on strategic level

Correct process model
WDE ŐƵŝĚĞůŝŶĞƐ
WD
WƌŽĐĞƐƐĚŽĐƵŵĞŶƚĂƚŝŽŶ

Formal review of process model

No
Formally OK?
Yes

Publish process model

Process model published
Review content of process model

No
Yes
Content OK?
FIGURE 7.13  The meta-process of process documentation as it is lived in many companies.
The background of this meta-process is the documentation of a large number of business processes.  The managers of the respective processes, who could be BPMN followers in competence, carry out this documentation in a decentralized manner. They are only sup-posed to document their processes at the strategic level, because doing so at the opera-tional level across the whole organization is too much effort. When the strategic process diagrams are done, the BPM Competence Center (BPM CC), which includes the BPMN gurus, formally reviews them. Among other things, the BPM CC checks to see if the mod-els comply with deﬁned BPMN guidelines.  The process managers correct their models as needed, otherwise, the process owner reviews the content and approves the documen-tation.  The BPM CC then takes care of publishing the approved documentation, on the intranet, for instance.
7.5 Meta-processes	209
This is just one example of a meta-process, and it may not apply to every kind of com-pany. A completely different process may be better suited to your case. We only wanted to illustrate meta-processes are about and why it is important to clarify them.
8   Tips to get started
8.1	Develop your own style
WehaveexplainedBPMNandillustrateditshands-onapplicationbasedonourframework. Now it’s your turn.  You have to consider what you want to do with BPMN and develop your own procedures and associated conventions. You can resort to our framework, which —deliberately —allows enough room for creativity. So familiarize yourself with BPMN and then decide when you want to apply which symbols and constructs.
It is best to develop your BPMN style not in an abstract way, but rather by working with it, with actual processes from your company. Start with processes that are relatively straight-forward, for example:
■      Making a vacation request
■      Receiving invoices, including veriﬁcation and release
■      Ordering ofﬁce supplies
Yes, you could start by jumping on your core processes, trying to survey and document them completely.  These are wonderfully suitable as long-term undertakings, and maybe you could beneﬁt from them in your next life. For starting out, however, we cannot recom-mend these as BPMN projects.
For starting out, you should prefer a compact and easily manageable support process, and you should model it strategically, that is, with a focus on operations and results. When or-dering ofﬁce supplies, for instance, an employee urgently needs something.  She reports this need, the purchasing department procures the item, and the employee receives it and is happy. Now proceed to the operational level, where you can go into the detailed opera-tional handling, perhaps taking into account that the purchasing department won’t order the items immediately.  Instead, purchasing may accumulate all ofﬁce product requests into a larger order.  Then, from your operational process model, you can derive a simple technical process ﬂow and even implement it.  Voila, you have just automated a process that is transparent, efﬁcient, and agile. You’re ready to tackle a more difﬁcult process, like those invoices.
The devil is always in the details, even with relatively simple processes.  And you have to be aware that these processes often do not contain all the possible problems you will en-counter in your core processes. The bottom line is still what we explained in the introduc-tion: BPM works best step-by-step, and when you have a map and compass.
212	8  Tips to get started
8.2	Find fellow suﬀerers
You are not alone. Many people in many organizations already have experience in BPMN and workﬂow automation tools. Find and contact them. Exchange information with them. Search in the typical places of the web, like search engines or social networks. Camunda itself also provides a forum, a lot of case-studdies and regular meetings around the world.
A community is not just a chance to extract knowledge from others for free. If all you do is ask questions without providing any answers, or criticize without offering ideas for im-provement, eventually no one will want to talk to you.  Beneﬁt from the ideas and expe-rience of others, of course, but share your ideas and experience as well.  To give is not only more blessed than to receive, it also creates more success. Does that sound esoteric? Maybe, but it works!
8.3	Get started
Thank you for reading our book. We hope it will help you to improve the processes in your organization. Ideally, good processes free everyone to focus on the things that truly create value. If our book helps you to do that, then we have achieved our goal.
Do you have feedback about the book? Do you have ideas for improving our BPMN frame-work?   We are eager to hear from you.   Please email us at bpmn@camunda.com.   And maybe we’ll meet up in some of our BPMN classroom trainings!  You ﬁnd details online: http://www.camunda.com/bpmn/.
We’ve kept you long enough. Go get started!
Bibliography
[Cam18]  CAMUNDA: A Recap of The 2018 Microservices Orchestration Survey. https://blog.
[Eur09]
[Obj09]

camunda.com/post/2018/09/microservices-orchestration-survey-results-2018/, 2018
EUROPEAN ASSOCIATION OF BPM: Common Body of Knowledge for BPM. Schmidt (Götz), Wettenberg, 2009
OBJECT MANAGEMENT GROUP: Business Process Modeling Notation (BPMN)
Version 1.2. http://www.omg.org/spec/BPMN/1.2/PDF, 2009
